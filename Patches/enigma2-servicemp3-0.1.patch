--- enigma2-servicemp3/configure.ac
+++ enigma2-servicemp3/configure.ac
@@ -10,11 +10,52 @@
 AC_LANG(C++)
 
 PKG_CHECK_MODULES(ENIGMA2, enigma2)
+
 AC_ARG_WITH(gstversion,
 	AS_HELP_STRING([--with-gstversion],[use gstreamer version (major.minor)]),
 	[GST_MAJORMINOR=$withval],[GST_MAJORMINOR=1.0])
 
-PKG_CHECK_MODULES(GSTREAMER, gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR)
+
+AC_ARG_ENABLE([libeplayer3],
+	[  --enable-libeplayer3          enable TDT libeplayer3 as player engine support],
+[case "${enableval}" in
+	yes) libeplayer3=true ;;
+	no)  libeplayer3=false ;;
+	*) AC_MSG_ERROR([bad value ${enableval} for --enable-libeplayer3]) ;;
+esac],[libeplayer3=false])
+AM_CONDITIONAL(ENABLE_LIBEPLAYER3, [test x$libeplayer3 = xtrue])
+if test "$enable_libeplayer3" = "yes"; then
+	AC_DEFINE(ENABLE_LIBEPLAYER3, 1 ,[include TDT libeplayer3 as player engine support])
+fi
+
+AC_ARG_ENABLE([mediafwgstreamer],
+	[  --enable-mediafwgstreamer     enable gstreamer as player engine support],
+[case "${enableval}" in
+	yes) mediafwgstreamer=true ;;
+	no)  mediafwgstreamer=false ;;
+	*) AC_MSG_ERROR([bad value ${enableval} for --enable-mediafwgstreamer]) ;;
+esac],[mediafwgstreamer=false])
+AM_CONDITIONAL(ENABLE_MEDIAFWGSTREAMER, [test x$mediafwgstreamer = xtrue])
+if test "$enable_mediafwgstreamer" = "yes"; then
+	AC_DEFINE(ENABLE_MEDIAFWGSTREAMER, 1 ,[include gstreamer as player engine support])
+fi
+
+if test "$enable_libeplayer3" = "yes"; then
+#	PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-2.0 libssl libcrypto])
+	PKG_CHECK_MODULES([AVFORMAT], [libavformat >= 53.21.1])
+	PKG_CHECK_MODULES([AVCODEC], [libavcodec >= 54.28.0])
+	# do not know which version is exactly needed here...
+	PKG_CHECK_MODULES([AVUTIL], [libavutil])
+	PKG_CHECK_MODULES([SWSCALE], [libswscale])
+	PKG_CHECK_MODULES([SWRESAMPLE], [libswresample])
+fi
+
+if test "$enable_gstreamer" = "yes"; then
+	PKG_CHECK_MODULES(GSTREAMER, gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR)
+	PKG_CHECK_MODULES(BASE, [freetype2 fribidi gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR libdvbsi++ libpng libxml-2.0 sigc++-2.0 libssl libcrypto])
+else
+	PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-2.0 libssl libcrypto])
+fi
 
 AC_DEFINE([DEBUG])
 
--- enigma2-servicemp3/m4/ax_python_devel.m4
+++ enigma2-servicemp3/m4/ax_python_devel.m4
@@ -158,9 +158,9 @@
 			print (distutils.sysconfig.get_python_inc (plat_specific=1));"`
 		if test -n "${python_path}"; then
 			if test "${plat_python_path}" != "${python_path}"; then
-				python_path="-I$python_path -I$plat_python_path"
+				python_path="-I$PY_PATH/include/python$PYTHON_VER_MAJOR -I$plat_python_path"
 			else
-				python_path="-I$python_path"
+				python_path="-I$PY_PATH/include/python$PYTHON_VER_MAJOR"
 			fi
 		fi
 		PYTHON_CPPFLAGS=$python_path
@@ -234,7 +234,8 @@
 			  "from distutils.sysconfig import get_python_lib as f; \
 			  import os; \
 			  print (os.path.join(f(plat_specific=1, standard_lib=1), 'config'));"`
-			PYTHON_LIBS="-L$ac_python_libdir -lpython$ac_python_version"
+			PYTHON_LIBS="-L$PY_PATH/lib/python$PYTHON_VER_MAJOR -lpython$ac_python_version"
+#			PYTHON_LIBS="-L$ac_python_libdir -lpython$ac_python_version"
 		fi
 
 		if test -z "PYTHON_LIBS"; then
@@ -252,8 +254,9 @@
 	#
 	AC_MSG_CHECKING([for Python site-packages path])
 	if test -z "$PYTHON_SITE_PKG"; then
-		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
-			print (distutils.sysconfig.get_python_lib(0,0));"`
+		PYTHON_SITE_PKG="$PY_PATH/lib/python$PYTHON_VER_MAJOR/site-packages"
+#		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
+#			print (distutils.sysconfig.get_python_lib(0,0));"`
 	fi
 	AC_MSG_RESULT([$PYTHON_SITE_PKG])
 	AC_SUBST([PYTHON_SITE_PKG])
--- enigma2-servicemp3/servicemp3/Makefile.am
+++ enigma2-servicemp3/servicemp3/Makefile.am
@@ -5,22 +5,70 @@
 	@PYTHON_CPPFLAGS@ \
 	-include Python.h
 
+if ENABLE_LIBEPLAYER3
+if ENABLE_MEDIAFWGSTREAMER
+AM_CPPFLAGS += \
+	-I$(top_srcdir)/../../apps/tools/libeplayer3/include
+else
+AM_CPPFLAGS += \
+	-D__STDC_CONSTANT_MACROS \
+	-D__STDC_FORMAT_MACROS \
+	-I$(top_srcdir)/../../apps/tools/eplayer3/include
+endif
+endif
+
 AM_CXXFLAGS = \
 	-Wall \
-	@ENIGMA2_CFLAGS@ \
+	@ENIGMA2_CFLAGS@
+
+if ENABLE_MEDIAFWGSTREAMER
+AM_CXXFLAGS += \
-	@GSTREAMER_CFLAGS@
+	-pthread \
+	-I$(top_srcdir)/../../tufsbox/cdkroot/usr/include/gstreamer-1.0 \
+	-I$(top_srcdir)/../../tufsbox/cdkroot/usr/include/glib-2.0 \
+	-I$(top_srcdir)/../../tufsbox/cdkroot/usr/lib/glib-2.0/include
+endif
 
 plugindir = $(libdir)/enigma2/python/Plugins/SystemPlugins/ServiceMP3
 
 plugin_LTLIBRARIES = servicemp3.la
 
 servicemp3_la_SOURCES = \
-	servicemp3.cpp \
-	servicemp3record.cpp \
 	pythonmodule.cpp
 
+if ENABLE_MEDIAFWGSTREAMER
+servicemp3_la_SOURCES += \
+	servicemp3.cpp \
+	servicemp3record.cpp \
+	servicemp3.h \
+	servicemp3record.h
+endif
+
+if ENABLE_LIBEPLAYER3
+servicemp3_la_SOURCES += \
+	serviceeplayer3.cpp \
+	serviceeplayer3.h
+endif
+
 servicemp3_la_LDFLAGS = \
-	@GSTREAMER_LIBS@ \
 	-avoid-version \
 	-module \
 	-shared
+
+if ENABLE_MEDIAFWGSTREAMER
+servicemp3_la_LDFLAGS += \
+	-lgstreamer-1.0 \
+	-lgstpbutils-1.0 \
+	-lglib-2.0 \
+	-lgobject-2.0
+if ENABLE_LIBEPLAYER3
+servicemp3_la_LDFLAGS += \
+	-leplayer3
+endif
+else
+servicemp3_la_LDFLAGS += \
+	-leplayer3 \
+	-lavformat \
+	-lswresample \
+	-L$(top_srcdir)/../../apps/tools/eplayer3
+endif
--- enigma2-servicemp3-0.1/servicemp3/pythonmodule.cpp
+++ enigma2-servicemp3/servicemp3/pythonmodule.cpp
@@ -1,5 +1,6 @@
+#if ENABLE_MEDIAFWGSTREAMER
 #include "servicemp3.h"
-
+#endif
 
 static PyMethodDef servicemp3Methods[] =
 {
--- enigma2-servicemp3/servicemp3/servicemp3.cpp
+++ enigma2-servicemp3/servicemp3/servicemp3.cpp
@@ -1,5 +1,5 @@
-	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
-	/* it's currently hardcoded to use a big-endian alsasink as sink. */
+	/* note: this requires gstreamer > 1.0 and a big list of plugins. */
+	/* it is currently hardcoded to use a big-endian alsasink as sink. */
 #include <lib/base/ebase.h>
 #include <lib/base/eerror.h>
 #include <lib/base/init_num.h>
@@ -17,11 +17,13 @@
 
 #include <string>
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
 #include <gst/pbutils/missing-plugins.h>
+#endif
 #include <sys/stat.h>
 
-#define HTTP_TIMEOUT 30
+#define HTTP_TIMEOUT 60
 
 /*
  * UNUSED variable from service reference is now used as buffer flag for gstreamer
@@ -41,7 +43,7 @@
 
 /*
  * GstPlayFlags flags from playbin2. It is the policy of GStreamer to
- * not publicly expose element-specific enums. That's why this
+ * not publicly expose element-specific enums. That is why this
  * GstPlayFlags enum has been copied here.
  */
 typedef enum
@@ -60,20 +62,13 @@
 	GST_PLAY_FLAG_FORCE_FILTERS = (1 << 11),
 } GstPlayFlags;
 
-// eServiceFactoryMP3
-
-/*
- * gstreamer suffers from a bug causing sparse streams to loose sync, after pause/resume / skip
- * see: https://bugzilla.gnome.org/show_bug.cgi?id=619434
- * As a workaround, we run the subsink in sync=false mode
- */
-#if GST_VERSION_MAJOR < 1 
-#define GSTREAMER_SUBTITLE_SYNC_MODE_BUG
-#else
-#undef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
-#endif
-/**/
-
+
+void mp3Blit(){
+	fbClass *fb = fbClass::getInstance();
+	fb->blit();
+}
+
+	// eServiceFactoryMP3
 eServiceFactoryMP3::eServiceFactoryMP3()
 {
 	ePtr<eServiceCenter> sc;
@@ -98,27 +93,48 @@
 		extensions.push_back("aac");
 		extensions.push_back("ape");
 		extensions.push_back("alac");
-		extensions.push_back("mpg");
-		extensions.push_back("vob");
+		extensions.push_back("flv");
+		extensions.push_back("m4a");
+		extensions.push_back("3gp");
+		extensions.push_back("3g2");
+		extensions.push_back("asf");
+#if defined(__sh__)
+#if !defined(ENABLE_MEDIAFWGSTREAMER) || !defined(ENABLE_LIBEPLAYER3)
+/* Hellmaster1024: if both gst and eplayer3 are enabled, this is the GST service!
+ * We only select the audio extensions (above), and leave the Video extensions for
+ * the ePlayer3 service located in serviceeplayer3
+ * If only one of GST and ePlayer3 this service handles all extensions and switches between
+ * GST and ePlayer3
+*/
 		extensions.push_back("m4v");
 		extensions.push_back("mkv");
 		extensions.push_back("avi");
 		extensions.push_back("divx");
 		extensions.push_back("dat");
-		extensions.push_back("flv");
 		extensions.push_back("mp4");
 		extensions.push_back("mov");
-		extensions.push_back("wmv");
-		extensions.push_back("asf");
-		extensions.push_back("3gp");
-		extensions.push_back("3g2");
 		extensions.push_back("mpeg");
 		extensions.push_back("mpe");
 		extensions.push_back("rm");
 		extensions.push_back("rmvb");
 		extensions.push_back("ogm");
 		extensions.push_back("ogv");
-		extensions.push_back("m3u8");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("wmv");
+#endif
+#endif
+ 		extensions.push_back("wma");
 		extensions.push_back("stream");
 		extensions.push_back("webm");
 		extensions.push_back("amr");
@@ -129,7 +145,6 @@
 		extensions.push_back("wtv");
 		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
 	}
-
 	m_service_info = new eStaticServiceMP3Info();
 }
 
@@ -139,7 +154,9 @@
 
 	eServiceCenter::getPrivInstance(sc);
 	if (sc)
+	{
 		sc->removeServiceFactory(eServiceFactoryMP3::id);
+	}
 }
 
 DEFINE_REF(eServiceFactoryMP3)
@@ -147,7 +164,7 @@
 	// iServiceHandler
 RESULT eServiceFactoryMP3::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
 {
-		// check resources...
+	// check resources...
 	ptr = new eServiceMP3(ref);
 	return 0;
 }
@@ -159,13 +176,13 @@
 		ptr = new eServiceMP3Record((eServiceReference&)ref);
 		return 0;
 	}
-	ptr=0;
+	ptr = 0;
 	return -1;
 }
 
 RESULT eServiceFactoryMP3::list(const eServiceReference &, ePtr<iListableService> &ptr)
 {
-	ptr=0;
+	ptr = 0;
 	return -1;
 }
 
@@ -199,19 +216,25 @@
 	{
 		std::list<std::string> res;
 		if (getListOfFilenames(res))
+		{
 			return -1;
-
+		}
 		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
 		if (!eraser)
+		{
 			eDebug("[eMP3ServiceOfflineOperations] FATAL !! can't get background file eraser");
-
+		}
 		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
 		{
 			eDebug("[eMP3ServiceOfflineOperations] Removing %s...", i->c_str());
 			if (eraser)
+			{
 				eraser->erase(i->c_str());
+			}
 			else
+			{
 				::unlink(i->c_str());
+			}
 		}
 	}
 	return 0;
@@ -236,10 +259,9 @@
 	return 0;
 }
 
-// eStaticServiceMP3Info
-
-
-// eStaticServiceMP3Info is seperated from eServiceMP3 to give information
+	// eStaticServiceMP3Info
+
+// eStaticServiceMP3Info is separated from eServiceMP3 to give information
 // about unopened files.
 
 // probably eServiceMP3 should use this class as well, and eStaticServiceMP3Info
@@ -254,15 +276,21 @@
 
 RESULT eStaticServiceMP3Info::getName(const eServiceReference &ref, std::string &name)
 {
-	if ( ref.name.length() )
+	if (ref.name.length())
+	{
 		name = ref.name;
+	}
 	else
 	{
 		size_t last = ref.path.rfind('/');
 		if (last != std::string::npos)
+		{
 			name = ref.path.substr(last+1);
+		}
 		else
+		{
 			name = ref.path;
+		}
 	}
 	return 0;
 }
@@ -276,24 +304,24 @@
 {
 	switch (w)
 	{
-	case iServiceInformation::sTimeCreate:
+		case iServiceInformation::sTimeCreate:
 		{
 			struct stat s;
 			if (stat(ref.path.c_str(), &s) == 0)
 			{
 				return s.st_mtime;
 			}
-		}
-		break;
-	case iServiceInformation::sFileSize:
+			break;
+		}
+		case iServiceInformation::sFileSize:
 		{
 			struct stat s;
 			if (stat(ref.path.c_str(), &s) == 0)
 			{
 				return s.st_size;
 			}
-		}
-		break;
+			break;
+		}
 	}
 	return iServiceInformation::resNA;
 }
@@ -301,6 +329,7 @@
 long long eStaticServiceMP3Info::getFileSize(const eServiceReference &ref)
 {
 	struct stat s;
+
 	if (stat(ref.path.c_str(), &s) == 0)
 	{
 		return s.st_size;
@@ -357,6 +386,7 @@
 	return bufferSize;
 }
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 DEFINE_REF(eServiceMP3InfoContainer);
 
 eServiceMP3InfoContainer::eServiceMP3InfoContainer()
@@ -368,9 +398,7 @@
 {
 	if (bufferValue)
 	{
-#if GST_VERSION_MAJOR >= 1
 		gst_buffer_unmap(bufferValue, &map);
-#endif
 		gst_buffer_unref(bufferValue);
 		bufferValue = NULL;
 		bufferData = NULL;
@@ -398,17 +426,13 @@
 {
 	bufferValue = buffer;
 	gst_buffer_ref(bufferValue);
-#if GST_VERSION_MAJOR < 1
-	bufferData = GST_BUFFER_DATA(bufferValue);
-	bufferSize = GST_BUFFER_SIZE(bufferValue);
-#else
 	gst_buffer_map(bufferValue, &map, GST_MAP_READ);
 	bufferData = map.data;
 	bufferSize = map.size;
+}
 #endif
-}
-
-// eServiceMP3
+
+	// eServiceMP3
 int eServiceMP3::ac3_delay = 0,
     eServiceMP3::pcm_delay = 0;
 
@@ -420,34 +444,40 @@
 	m_pump(eApp, 1)
 {
 	m_subtitle_sync_timer = eTimer::create(eApp);
+#if defined ENABLE_MEDIAFWGSTREAMER
 	m_stream_tags = 0;
+#endif
 	m_currentAudioStream = -1;
 	m_currentSubtitleStream = -1;
 	m_cachedSubtitleStream = -2; /* report subtitle stream to be 'cached'. TODO: use an actual cache. */
 	m_subtitle_widget = 0;
 	m_currentTrickRatio = 1.0;
 	m_buffer_size = 5 * 1024 * 1024;
+#if defined ENABLE_MEDIAFWGSTREAMER
 	m_ignore_buffering_messages = 0;
 	m_is_live = false;
 	m_use_prefillbuffer = false;
 	m_paused = false;
 	m_seek_paused = false;
 	m_cuesheet_loaded = false; /* cuesheet CVR */
-#if GST_VERSION_MAJOR >= 1
 	m_use_chapter_entries = false; /* TOC chapter support CVR */
 	m_last_seek_pos = 0; /* CVR last seek position */
-#endif
 	m_useragent = "Enigma2 HbbTV/1.1.1 (+PVR+RTSP+DL;OpenPLi;;;)";
 	m_extra_headers = "";
 	m_download_buffer_path = "";
+#endif
 	m_prev_decoder_time = -1;
 	m_decoder_time_valid_state = 0;
 	m_errorInfo.missing_codec = "";
+#if defined ENABLE_MEDIAFWGSTREAMER
 	audioSink = videoSink = NULL;
 	m_decoder = NULL;
+#endif
 
 	CONNECT(m_subtitle_sync_timer->timeout, eServiceMP3::pushSubtitles);
+#if defined ENABLE_MEDIAFWGSTREAMER
 	CONNECT(m_pump.recv_msg, eServiceMP3::gstPoll);
+#endif
 	CONNECT(m_nownext_timer->timeout, eServiceMP3::updateEpgCacheNowNext);
 	m_aspect = m_width = m_height = m_framerate = m_progressive = m_gamma = -1;
 
@@ -470,20 +500,32 @@
 			size_t hpos_start = pos + 11;
 			size_t hpos_end = m_extra_headers.find('&', hpos_start);
 			if (hpos_end != std::string::npos)
+			{
 				m_useragent = m_extra_headers.substr(hpos_start, hpos_end - hpos_start);
+			}
 			else
+			{
 				m_useragent = m_extra_headers.substr(hpos_start);
+			}
 		}
 	}
 	else
+	{
 		filename = m_ref.path.c_str();
+	}
 	const char *ext = strrchr(filename, '.');
 	if (!ext)
+	{
 		ext = filename + strlen(filename);
-
+	}
+#if defined ENABLE_MEDIAFWGSTREAMER
 	m_sourceinfo.is_video = FALSE;
 	m_sourceinfo.audiotype = atUnknown;
-	if (strcasecmp(ext, ".mpeg") == 0 || strcasecmp(ext, ".mpe") == 0 || strcasecmp(ext, ".mpg") == 0 || strcasecmp(ext, ".vob") == 0 || strcasecmp(ext, ".bin") == 0)
+	if (strcasecmp(ext, ".mpeg") == 0
+	||  strcasecmp(ext, ".mpe") == 0
+	||  strcasecmp(ext, ".mpg") == 0
+	||  strcasecmp(ext, ".vob") == 0
+	||  strcasecmp(ext, ".bin") == 0)
 	{
 		m_sourceinfo.containertype = ctMPEGPS;
 		m_sourceinfo.is_video = TRUE;
@@ -498,22 +540,29 @@
 		m_sourceinfo.containertype = ctMKV;
 		m_sourceinfo.is_video = TRUE;
 	}
-	else if (strcasecmp(ext, ".ogm") == 0 || strcasecmp(ext, ".ogv") == 0)
+	else if (strcasecmp(ext, ".ogm") == 0
+	||       strcasecmp(ext, ".ogv") == 0)
 	{
 		m_sourceinfo.containertype = ctOGG;
 		m_sourceinfo.is_video = TRUE;
 	}
-	else if (strcasecmp(ext, ".avi") == 0 || strcasecmp(ext, ".divx") == 0)
+	else if (strcasecmp(ext, ".avi") == 0
+	||       strcasecmp(ext, ".divx") == 0)
 	{
 		m_sourceinfo.containertype = ctAVI;
 		m_sourceinfo.is_video = TRUE;
 	}
-	else if (strcasecmp(ext, ".mp4") == 0 || strcasecmp(ext, ".mov") == 0 || strcasecmp(ext, ".m4v") == 0 || strcasecmp(ext, ".3gp") == 0 || strcasecmp(ext, ".3g2") == 0)
+	else if (strcasecmp(ext, ".mp4") == 0
+	||       strcasecmp(ext, ".mov") == 0
+	||       strcasecmp(ext, ".m4v") == 0
+	||       strcasecmp(ext, ".3gp") == 0
+	||       strcasecmp(ext, ".3g2") == 0)
 	{
 		m_sourceinfo.containertype = ctMP4;
 		m_sourceinfo.is_video = TRUE;
 	}
-	else if (strcasecmp(ext, ".asf") == 0 || strcasecmp(ext, ".wmv") == 0)
+	else if (strcasecmp(ext, ".asf") == 0
+	||       strcasecmp(ext, ".wmv") == 0)
 	{
 		m_sourceinfo.containertype = ctASF;
 		m_sourceinfo.is_video = TRUE;
@@ -523,35 +572,55 @@
 		m_sourceinfo.containertype = ctWEBM;
 		m_sourceinfo.is_video = TRUE;
 	}
-	else if (strcasecmp(ext, ".m4a") == 0 || strcasecmp(ext, ".alac") == 0)
+	else if (strcasecmp(ext, ".m4a") == 0
+	||       strcasecmp(ext, ".alac") == 0)
 	{
 		m_sourceinfo.containertype = ctMP4;
 		m_sourceinfo.audiotype = atAAC;
 	}
-	else if (strcasecmp(ext, ".m3u8") == 0)
-		m_sourceinfo.is_hls = TRUE;
+//	else if (strcasecmp(ext, ".m3u8") != 0)
+//	{
+//		m_sourceinfo.is_hls = TRUE;
+//	}
 	else if (strcasecmp(ext, ".mp3") == 0)
+	{
 		m_sourceinfo.audiotype = atMP3;
+	}
 	else if (strcasecmp(ext, ".wma") == 0)
+	{
 		m_sourceinfo.audiotype = atWMA;
-	else if (strcasecmp(ext, ".wav") == 0 || strcasecmp(ext, ".wave") == 0 || strcasecmp(ext, ".wv") == 0)
+	}
+	else if (strcasecmp(ext, ".wav") == 0
+	||       strcasecmp(ext, ".wave") == 0
+	||       strcasecmp(ext, ".wv") == 0)
+	{
 		m_sourceinfo.audiotype = atPCM;
+	}
 	else if (strcasecmp(ext, ".dts") == 0)
+	{
 		m_sourceinfo.audiotype = atDTS;
+	}
 	else if (strcasecmp(ext, ".flac") == 0)
+	{
 		m_sourceinfo.audiotype = atFLAC;
+	}
 	else if (strcasecmp(ext, ".ac3") == 0)
+	{
 		m_sourceinfo.audiotype = atAC3;
+	}
 	else if (strcasecmp(ext, ".cda") == 0)
+	{
 		m_sourceinfo.containertype = ctCDA;
+	}
 	if (strcasecmp(ext, ".dat") == 0)
 	{
 		m_sourceinfo.containertype = ctVCD;
 		m_sourceinfo.is_video = TRUE;
 	}
 	if (strstr(filename, "://"))
+	{
 		m_sourceinfo.is_streaming = TRUE;
-
+	}
 	gchar *uri;
 	gchar *suburi = NULL;
 
@@ -568,17 +637,18 @@
 		filename = filename_str.c_str();
 	}
 
-	if ( m_sourceinfo.is_streaming )
+	if (m_sourceinfo.is_streaming)
 	{
 		if (eConfigManager::getConfigBoolValue("config.mediaplayer.useAlternateUserAgent"))
+		{
 			m_useragent = eConfigManager::getConfigValue("config.mediaplayer.alternateUserAgent");
-
+		}
 		uri = g_strdup_printf ("%s", filename);
 
-		if ( m_ref.getData(7) & BUFFERING_ENABLED )
+		if (m_ref.getData(7) & BUFFERING_ENABLED)
 		{
 			m_use_prefillbuffer = true;
-			if ( m_ref.getData(7) & PROGRESSIVE_DOWNLOAD )
+			if (m_ref.getData(7) & PROGRESSIVE_DOWNLOAD)
 			{
 				/* progressive download buffering */
 				if (::access("/hdd/movie", X_OK) >= 0)
@@ -589,12 +659,12 @@
 			}
 		}
 	}
-	else if ( m_sourceinfo.containertype == ctCDA )
+	else if (m_sourceinfo.containertype == ctCDA)
 	{
 		int i_track = atoi(filename+(strlen(filename) - 6));
 		uri = g_strdup_printf ("cdda://%i", i_track);
 	}
-	else if ( m_sourceinfo.containertype == ctVCD )
+	else if (m_sourceinfo.containertype == ctVCD)
 	{
 		int ret = -1;
 		int fd = open(filename,O_RDONLY);
@@ -605,23 +675,26 @@
 			close(fd);
 			delete [] tmp;
 		}
-		if ( ret == -1 ) // this is a "REAL" VCD
+		if (ret == -1) // this is a "REAL" VCD
+		{
 			uri = g_strdup_printf ("vcd://");
+		}
 		else
+		{
 			uri = g_filename_to_uri(filename, NULL, NULL);
+		}
 	}
 	else
+	{
 		uri = g_filename_to_uri(filename, NULL, NULL);
-
+	}
 	eDebug("[eServiceMP3] playbin uri=%s", uri);
 	if (suburi != NULL)
+	{
 		eDebug("[eServiceMP3] playbin suburi=%s", suburi);
-#if GST_VERSION_MAJOR < 1
-	m_gst_playbin = gst_element_factory_make("playbin2", "playbin");
-#else
+	}
 	m_gst_playbin = gst_element_factory_make("playbin", "playbin");
-#endif
-	if ( m_gst_playbin )
+	if (m_gst_playbin)
 	{
 		/*
 		 * avoid video conversion, let the dvbmediasink handle that using native video flag
@@ -630,7 +703,7 @@
 		guint flags = GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_VIDEO | \
 				GST_PLAY_FLAG_TEXT | GST_PLAY_FLAG_NATIVE_VIDEO;
 
-		if ( m_sourceinfo.is_streaming )
+		if (m_sourceinfo.is_streaming)
 		{
 			g_signal_connect (G_OBJECT (m_gst_playbin), "notify::source", G_CALLBACK (playbinNotifySource), this);
 			if (m_download_buffer_path != "")
@@ -650,34 +723,32 @@
 			g_object_set(G_OBJECT(m_gst_playbin), "buffer-duration", 5LL * GST_SECOND, NULL);
 			g_object_set(G_OBJECT(m_gst_playbin), "buffer-size", m_buffer_size, NULL);
 			if (m_sourceinfo.is_hls)
+			{
 				g_object_set(G_OBJECT(m_gst_playbin), "connection-speed", (guint64)(4495000LL), NULL);
+			}
 		}
 		g_object_set (G_OBJECT (m_gst_playbin), "flags", flags, NULL);
 		g_object_set (G_OBJECT (m_gst_playbin), "uri", uri, NULL);
 		GstElement *subsink = gst_element_factory_make("subsink", "subtitle_sink");
 		if (!subsink)
-			eDebug("[eServiceMP3] sorry, can't play: missing gst-plugin-subsink");
+		{
+			eDebug("[eServiceMP3] sorry, cannot play: gst-plugin-subsink missing");
+		}
 		else
 		{
 			m_subs_to_pull_handler_id = g_signal_connect (subsink, "new-buffer", G_CALLBACK (gstCBsubtitleAvail), this);
-#if GST_VERSION_MAJOR < 1
-			g_object_set (G_OBJECT (subsink), "caps", gst_caps_from_string("text/plain; text/x-plain; text/x-raw; text/x-pango-markup; video/x-dvd-subpicture; subpicture/x-pgs"), NULL);
-#else
 			g_object_set (G_OBJECT (subsink), "caps", gst_caps_from_string("text/plain; text/x-plain; text/x-raw; text/x-pango-markup; subpicture/x-dvd; subpicture/x-pgs"), NULL);
-#endif
 			g_object_set (G_OBJECT (m_gst_playbin), "text-sink", subsink, NULL);
 			g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
 		}
 		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE (m_gst_playbin));
-#if GST_VERSION_MAJOR < 1
-		gst_bus_set_sync_handler(bus, gstBusSyncHandler, this);
-#else
 		gst_bus_set_sync_handler(bus, gstBusSyncHandler, this, NULL);
-#endif
 		gst_object_unref(bus);
 
 		if (suburi != NULL)
+		{
 			g_object_set (G_OBJECT (m_gst_playbin), "suburi", suburi, NULL);
+		}
 		else
 		{
 			char srt_filename[ext - filename + 5];
@@ -690,7 +761,8 @@
 				g_object_set (G_OBJECT (m_gst_playbin), "suburi", g_filename_to_uri(srt_filename, NULL, NULL), NULL);
 			}
 		}
-	} else
+	}
+	else
 	{
 		m_event((iPlayableService*)this, evUser+12);
 		m_gst_playbin = 0;
@@ -700,11 +772,232 @@
 	}
 	g_free(uri);
 	if (suburi != NULL)
+	{
 		g_free(suburi);
+	}
+#else //eplayer3 code
+	player = (Context_t*) malloc(sizeof(Context_t));
+
+	if (player)
+	{
+		player->playback  = &PlaybackHandler;
+		player->output    = &OutputHandler;
+		player->container = &ContainerHandler;
+		player->manager   = &ManagerHandler;
+		printf("%s\n", player->output->Name);
+	}
+
+	//Registration of output devices
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+		player->output->Command(player,OUTPUT_ADD, (void*)"video");
+		player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+	}
+
+	if (player && player->output && player->output->subtitle)
+	{
+		fbClass *fb = fbClass::getInstance();
+		SubtitleOutputDef_t out;
+		out.screen_width = fb->getScreenResX();
+		out.screen_height = fb->getScreenResY();
+		out.shareFramebuffer = 1;
+		out.framebufferFD = fb->getFD();
+		out.destination = fb->getLFB_Direct();
+		out.destStride = fb->Stride();
+		out.framebufferBlit = mp3Blit;
+		player->output->subtitle->Command(player, (OutputCmd_t)OUTPUT_SET_SUBTITLE_OUTPUT, (void*) &out);
+	}
+
+	//create playback path
+	char file[800] = {""};
+
+	if (!strncmp("http://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else if (!strncmp("rtsp://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else if (!strncmp("rtmp://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else if (!strncmp("rtmpe://", m_ref.path.c_str(), 8))
+	{
+		;
+	}
+	else if (!strncmp("rtmpt://", m_ref.path.c_str(), 8))
+	{
+		;
+	}
+	else if (!strncmp("rtmps://", m_ref.path.c_str(), 8))
+	{
+		;
+	}
+	else if (!strncmp("rtmpte://", m_ref.path.c_str(), 9))
+	{
+		;
+	}
+	else if (!strncmp("rtp://", m_ref.path.c_str(), 6))
+	{
+		;
+	}
+	else if (!strncmp("upnp://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else if (!strncmp("mms://", m_ref.path.c_str(), 6))
+	{
+		;
+	}
+	else if (!strncmp("file://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else
+	{
+		strcat(file, "file://");
+	}
+	strcat(file, m_ref.path.c_str());
+
+	//try to open file
+	if (player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0)
+	{
+		//VIDEO
+		//We dont have to register video tracks, or do we ?
+		//AUDIO
+		if (player && player->manager && player->manager->audio)
+		{
+			char ** TrackList = NULL;
+			player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("AudioTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					audioStream audio;
+					audio.language_code = TrackList[i];
+
+					// atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+					if (    !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+					{
+						audio.type = atMP3;
+					}
+					else if (!strncmp("A_MP3",      TrackList[i+1], 5))
+					{
+						audio.type = atMP3;
+					}
+					else if (!strncmp("A_AC3",      TrackList[i+1], 5))
+					{
+						audio.type = atAC3;
+					}
+					else if (!strncmp("A_DTS",      TrackList[i+1], 5))
+					{
+						audio.type = atDTS;
+					}
+					else if (!strncmp("A_AAC",      TrackList[i+1], 5))
+					{
+						audio.type = atAAC;
+					}
+					else if (!strncmp("A_PCM",      TrackList[i+1], 5))
+					{
+						audio.type = atPCM;
+					}
+					else if (!strncmp("A_VORBIS",   TrackList[i+1], 8))
+					{
+						audio.type = atOGG;
+					}
+					else if (!strncmp("A_FLAC",     TrackList[i+1], 6))
+					{
+						audio.type = atFLAC;
+					}
+					else
+					{
+						audio.type = atUnknown;
+					}
+					m_audioStreams.push_back(audio);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		//SUB
+		if (player && player->manager && player->manager->subtitle)
+		{
+			char ** TrackList = NULL;
+			player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("[ServiceMP3] SubtitleTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					subtitleStream sub;
+					sub.language_code = TrackList[i];
+					//  stPlainText, stSSA, stSRT
+					if (!strncmp("S_TEXT/SSA", TrackList[i + 1], 10)
+					||  !strncmp("S_SSA", TrackList[i + 1], 5))
+					{
+						sub.type = stSSA;
+					}
+					else if (!strncmp("S_TEXT/ASS", TrackList[i + 1], 10)
+					||       !strncmp("S_AAS", TrackList[i + 1], 5))
+					{
+						sub.type = stSSA;
+					}
+					else if (!strncmp("S_TEXT/SRT", TrackList[i + 1], 10)
+					||       !strncmp("S_SRT", TrackList[i + 1], 5))
+					{
+						sub.type = stSRT;
+					}
+					else
+					{
+						sub.type = stPlainText;
+					}
+					m_subtitleStreams.push_back(sub);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		m_event(this, evStart);
+	}
+	else
+	{
+		//Creation failed, no playback support for insert file, so delete playback context
+		//FIXME: How to tell e2 that we failed?
+		if (player && player->output)
+		{
+			player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+			player->output->Command(player,OUTPUT_DEL, (void*)"video");
+			player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+		}
+
+		if (player && player->playback)
+		{
+			player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+		}
+		if (player)
+		{
+			free(player);
+		}
+		player = NULL;
+	}
+	//m_state = stRunning;
+	eDebug("[ServiceMP3] eServiceMP3-<\n");
+#endif
 }
 
 eServiceMP3::~eServiceMP3()
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	// disconnect subtitle callback
 	GstElement *subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
 
@@ -713,32 +1006,34 @@
 		g_signal_handler_disconnect (subsink, m_subs_to_pull_handler_id);
 		gst_object_unref(subsink);
 	}
-
-	if (m_subtitle_widget) m_subtitle_widget->destroy();
+#endif
+
+	if (m_subtitle_widget)
+	{
+		 m_subtitle_widget->destroy();
+	}
 	m_subtitle_widget = 0;
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		// disconnect sync handler callback
 		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE (m_gst_playbin));
-#if GST_VERSION_MAJOR < 1
-		gst_bus_set_sync_handler(bus, NULL, NULL);
-#else
 		gst_bus_set_sync_handler(bus, NULL, NULL, NULL);
+		gst_object_unref(bus);
+	}
 #endif
-		gst_object_unref(bus);
-	}
-
 	stop();
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (m_decoder)
 	{
 		m_decoder = NULL;
 	}
-
 	if (m_stream_tags)
+	{
 		gst_tag_list_free(m_stream_tags);
-
+	}
 	if (audioSink)
 	{
 		gst_object_unref(GST_OBJECT(audioSink));
@@ -752,8 +1047,9 @@
 	if (m_gst_playbin)
 	{
 		gst_object_unref (GST_OBJECT (m_gst_playbin));
-		eDebug("[eServiceMP3] destruct!");
-	}
+		eDebug("[eServiceMP3] pipeline destructed");
+	}
+#endif
 }
 
 void eServiceMP3::updateEpgCacheNowNext()
@@ -803,18 +1099,33 @@
 
 DEFINE_REF(eServiceMP3);
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 DEFINE_REF(GstMessageContainer);
+#endif
 
 RESULT eServiceMP3::connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+#if defined ENABLE_MEDIAFWGSTREAMER
+#else //eplayer3 code
+	m_event(this, evSeekableStatusChanged);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::start()
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	ASSERT(m_state == stIdle);
-
+#else //eplayer3 code
+	if (m_state != stIdle)
+	{
+		eDebug("eServiceMP3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+#endif
+
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		eDebug("[eServiceMP3] starting pipeline");
@@ -823,29 +1134,45 @@
 
 		switch(ret)
 		{
-		case GST_STATE_CHANGE_FAILURE:
-			eDebug("[eServiceMP3] failed to start pipeline");
-			stop();
-			break;
-		case GST_STATE_CHANGE_SUCCESS:
-			m_is_live = false;
-			break;
-		case GST_STATE_CHANGE_NO_PREROLL:
-			m_is_live = true;
-			break;
-		default:
-			break;
-		}
-	}
-
+			case GST_STATE_CHANGE_FAILURE:
+			{
+				eDebug("[eServiceMP3] failed to start pipeline");
+				stop();
+				break;
+			}
+			case GST_STATE_CHANGE_SUCCESS:
+			{
+				m_is_live = false;
+				break;
+			}
+			case GST_STATE_CHANGE_NO_PREROLL:
+			{
+				m_is_live = true;
+				break;
+			}
+			default:
+			{
+				break;
+			}
+		}
+	}
+#else //eplayer3 code
+	if (player && player->output && player->playback)
+	{
+		player->output->Command(player, OUTPUT_OPEN, NULL);
+		player->playback->Command(player, PLAYBACK_PLAY, NULL);
+	}
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::stop()
 {
+//#if defined ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state == stStopped)
+	{
 		return -1;
-
+	}
 	eDebug("[eServiceMP3] stop %s", m_ref.path.c_str());
 	m_state = stStopped;
 
@@ -860,61 +1187,162 @@
 
 	ret = gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
 	if (ret != GST_STATE_CHANGE_SUCCESS)
+	{
 		eDebug("[eServiceMP3] stop GST_STATE_NULL failure");
-
+	}
 	saveCuesheet();
 	m_nownext_timer->stop();
 
+//#else	//eplayer3code
+//#endif //gstreamer
 	return 0;
 }
 
 RESULT eServiceMP3::pause(ePtr<iPauseableService> &ptr)
 {
-	ptr=this;
+	ptr = this;
 	return 0;
 }
 
+#if defined ENABLE_MEDIAFWGSTREAMER
+#else //eplayer3 code
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+		{
+			return speed_mapping[i+1];
+		}
+		i += 2;
+	}
+	return -1;
+}
+#endif //gstreamer
+
 RESULT eServiceMP3::setSlowMotion(int ratio)
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (!ratio)
+	{
 		return 0;
-	eDebug("[eServiceMP3] setSlowMotion ratio=%f",1.0/(gdouble)ratio);
+	}
+	eDebug("[eServiceMP3] setSlowMotion ratio=%.1f", 1.0/(gdouble)ratio);
 	return trickSeek(1.0/(gdouble)ratio);
+#else //eplayer3 code
+// konfetti: in libeplayer3 we changed this because I do not like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+		{
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+		}
+		if (result != 0)
+		{
+			return -1;
+		}
+	}
+	return 0;
+#endif //gstreamer
 }
 
 RESULT eServiceMP3::setFastForward(int ratio)
 {
-	eDebug("[eServiceMP3] setFastForward ratio=%i",ratio);
+#if defined ENABLE_MEDIAFWGSTREAMER
+	eDebug("[eServiceMP3] setFastForward ratio=%i", ratio);
 	return trickSeek(ratio);
-}
-
-		// iPausableService
+#else //eplayer3 code
+// konfetti: in libeplayer3 we changed this because I do not like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+		{
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+		}
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+		}
+		else
+		{
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+		}
+		if (result != 0)
+		{
+			return -1;
+		}
+	}
+	return 0;
+#endif //gstreamer
+}
+
+	// iPausableService
 RESULT eServiceMP3::pause()
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
+	{
 		return -1;
-
+	}
 	eDebug("[eServiceMP3] pause");
 	trickSeek(0.0);
-
+#else //eplayer3 code
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+	}
+#endif //gstreamer
 	return 0;
 }
 
 RESULT eServiceMP3::unpause()
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
+	{
 		return -1;
-
-	/* no need to unpase if we are not paused already */
+	}
+	/* no need to unpause if we are not paused already */
 	if (m_currentTrickRatio == 1.0 && !m_paused)
 	{
-		eDebug("[eServiceMP3] trickSeek no need to unpause!");
+		eDebug("[eServiceMP3] trickSeek; no need to unpause!");
 		return 0;
 	}
-
+#else //eplayer3 code
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+		return 0;
+	}
+#endif //gstreamer
 	eDebug("[eServiceMP3] unpause");
 	trickSeek(1.0);
-
 	return 0;
 }
 
@@ -927,93 +1355,108 @@
 
 RESULT eServiceMP3::getLength(pts_t &pts)
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
+	{
 		return -1;
-
+	}
 	GstFormat fmt = GST_FORMAT_TIME;
 	gint64 len;
-#if GST_VERSION_MAJOR < 1
-	if (!gst_element_query_duration(m_gst_playbin, &fmt, &len))
-#else
 	if (!gst_element_query_duration(m_gst_playbin, fmt, &len))
-#endif
+	{
 		return -1;
-		/* len is in nanoseconds. we have 90 000 pts per second. */
-
+	}
+	/* len is in nanoseconds. we have 90 000 pts per second. */
 	pts = len / 11111LL;
+#else //eplayer3 code
+	double length = 0;
+
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+	}
+	if (length <= 0)
+	{
+		return -1;
+	}
+	pts = length * 90000;
+#endif //gstreamer
 	return 0;
 }
 
 RESULT eServiceMP3::seekToImpl(pts_t to)
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 		/* convert pts to nanoseconds */
-#if GST_VERSION_MAJOR < 1
-	gint64 time_nanoseconds = to * 11111LL;
-	if (!gst_element_seek (m_gst_playbin, m_currentTrickRatio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT),
-		GST_SEEK_TYPE_SET, time_nanoseconds,
-		GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
-#else
 	m_last_seek_pos = to * 11111LL;
 	if (!gst_element_seek (m_gst_playbin, m_currentTrickRatio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT),
 		GST_SEEK_TYPE_SET, m_last_seek_pos,
 		GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
-#endif
 	{
 		eDebug("[eServiceMP3] seekTo failed");
 		return -1;
 	}
-
 	if (m_paused)
 	{
-#if GST_VERSION_MAJOR < 1
-		m_seek_paused = true;
-		gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
-#else
 		m_event((iPlayableService*)this, evUpdatedInfo);
-#endif
-	}
-
+	}
 	return 0;
 }
+#endif //gstreamer
 
 RESULT eServiceMP3::seekTo(pts_t to)
 {
 	RESULT ret = -1;
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		m_prev_decoder_time = -1;
 		m_decoder_time_valid_state = 0;
 		ret = seekToImpl(to);
 	}
-
+#else //eplayer3 code
+	float pos = (to / 90000.0) - 10;
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+	}
+	ret = 0;
+#endif //gstreamer
 	return ret;
 }
 
-
+#if defined ENABLE_MEDIAFWGSTREAMER
 RESULT eServiceMP3::trickSeek(gdouble ratio)
 {
 	if (!m_gst_playbin)
+	{
 		return -1;
+	}
 	GstState state, pending;
 	if (ratio > -0.01 && ratio < 0.01)
 	{
 		gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
 		/* pipeline sometimes block due to audio track issue off gstreamer.
 		If the pipeline is blocked up on pending state change to paused ,
-        this issue is solved be just reslecting the current audio track.*/
+		this issue is solved be just reselecting the current audio track.*/
 		gst_element_get_state(m_gst_playbin, &state, &pending, 1 * GST_SECOND);
 		if (state == GST_STATE_PLAYING && pending == GST_STATE_PAUSED)
 		{
 			if (m_currentAudioStream >= 0)
+			{
 				selectTrack(m_currentAudioStream);
+			}
 			else
+			{
 				selectTrack(0);
+			}
 		}
 		return 0;
 	}
 
 	bool unpause = (m_currentTrickRatio == 1.0 && ratio == 1.0);
+
 	if (unpause)
 	{
 		GstElement *source = NULL;
@@ -1045,14 +1488,16 @@
 		if (!strcmp(name, "filesrc") || !strcmp(name, "souphttpsrc"))
 		{
 			GstStateChangeReturn ret;
-			/* make sure that last state change was successfull */
+			/* make sure that last state change was successful */
 			ret = gst_element_get_state(m_gst_playbin, &state, &pending, 0);
 			if (ret == GST_STATE_CHANGE_SUCCESS)
 			{
 				gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
 				ret = gst_element_get_state(m_gst_playbin, &state, &pending, 0);
 				if (ret == GST_STATE_CHANGE_SUCCESS)
+				{
 					return 0;
+				}
 			}
 			eDebugNoNewLineStart("[eServiceMP3] trickSeek - invalid state, state:%s pending:%s ret:%s",
 				gst_element_state_get_name(state),
@@ -1064,7 +1509,7 @@
 			eDebugNoNewLineStart("[eServiceMP3] trickSeek - source '%s' is not supported", name);
 		}
 seek_unpause:
-		eDebugNoNewLine(", doing seeking unpause\n");
+		eDebug(", doing seeking unpause");
 	}
 
 	m_currentTrickRatio = ratio;
@@ -1080,18 +1525,23 @@
 
 	gst_element_get_state(m_gst_playbin, &state, &pending, 1 * GST_SECOND);
 	if (state != GST_STATE_PLAYING)
+	{
 		gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
-
+	}
 	if (validposition)
 	{
 		if (ratio >= 0.0)
 		{
-			gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, pos, GST_SEEK_TYPE_SET, -1);
+			gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME,
+				(GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP),
+				GST_SEEK_TYPE_SET, pos, GST_SEEK_TYPE_SET, -1);
 		}
 		else
 		{
 			/* note that most elements will not support negative speed */
-			gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, pos);
+			gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME,
+				(GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP),
+				GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, pos);
 		}
 	}
 
@@ -1099,33 +1549,44 @@
 	m_decoder_time_valid_state = 0;
 	return 0;
 }
-
+#endif //gstreamer
 
 RESULT eServiceMP3::seekRelative(int direction, pts_t to)
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin)
+	{
 		return -1;
-
+	}
+#endif //gstreamer
 	pts_t ppos;
-	if (getPlayPosition(ppos) < 0) return -1;
+	if (getPlayPosition(ppos) < 0)
+	{
+		return -1;
+	}
 	ppos += to * direction;
 	if (ppos < 0)
+	{
 		ppos = 0;
+	}
+#if defined ENABLE_MEDIAFWGSTREAMER
 	return seekTo(ppos);
-}
-
-#if GST_VERSION_MAJOR < 1
-gint eServiceMP3::match_sinktype(GstElement *element, gpointer type)
-{
-	return strcmp(g_type_name(G_OBJECT_TYPE(element)), (const char*)type);
-}
-#else
+#else //eplayer3 code
+	float pos = direction*(to / 90000.0);
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+	}
+	return 0;
+#endif //gstreamer
+}
+
+#if defined ENABLE_MEDIAFWGSTREAMER
 gint eServiceMP3::match_sinktype(const GValue *velement, const gchar *type)
 {
 	GstElement *element = GST_ELEMENT_CAST(g_value_get_object(velement));
 	return strcmp(g_type_name(G_OBJECT_TYPE(element)), type);
 }
-#endif
 
 #if HAVE_AMLOGIC
 GstElement *getAVDecElement(GstElement *m_gst_playbin, int i, int flag)
@@ -1135,22 +1596,25 @@
 	GstElement *e = NULL;
 
 	g_signal_emit_by_name(m_gst_playbin, flag ? "get-video-pad" : "get-audio-pad", i, &pad);
-	if (pad) {
+	if (pad)
+	{
 		dec_pad = gst_pad_get_peer(pad);
-		while (dec_pad && GST_IS_GHOST_PAD(dec_pad)) {
+		while (dec_pad && GST_IS_GHOST_PAD(dec_pad))
+		{
 			gst_object_unref(dec_pad);
 			dec_pad = gst_ghost_pad_get_target(GST_GHOST_PAD(dec_pad));
 		}
-		if (dec_pad) {
+		if (dec_pad)
+		{
 			e = gst_pad_get_parent_element(dec_pad);
 			gst_object_unref(dec_pad);
 		}
 		gst_object_unref(pad);
 	}
-
 	if (!e)
+	{
 		eDebug("[eServiceMP3] no %sDecElement", flag ? "Video" : "Audio");
-
+	}
 	return e;
 }
 
@@ -1161,22 +1625,27 @@
 	GstElement * adec = NULL, *vdec = NULL;
 
 	g_object_get(G_OBJECT (m_gst_playbin), "n-audio", &n_audio, NULL);
-	for (i = 0; i < n_audio; i++) {
+	for (i = 0; i < n_audio; i++)
+	{
 		adec = getAVDecElement(m_gst_playbin, i, 0);
-		if (adec) {
+		if (adec)
+		{
 			g_object_set(G_OBJECT(adec), "pass-through", TRUE, NULL);
 			gst_object_unref(adec);
 		}
 	}
 	adec = getAVDecElement(m_gst_playbin, index, 0);
-	if (adec) {
+	if (adec)
+	{
 		g_object_set(G_OBJECT(adec), "pass-through", FALSE, NULL);
 		gst_object_unref(adec);
 	}
 	g_object_get(G_OBJECT (m_gst_playbin), "current-video", &videonum, NULL);
 	vdec = getAVDecElement(m_gst_playbin, videonum, 1);
 	if (vdec)
+	{
 		g_object_set(G_OBJECT(vdec), "pass-through", TRUE, NULL);
+	}
 }
 
 unsigned int eServiceMP3::get_pts_pcrscr(void)
@@ -1188,71 +1657,102 @@
 
 	handle = open("/sys/class/tsync/pts_pcrscr", O_RDONLY);
 	if (handle < 0)
+	{
 		return value;
-
+	}
 	size = read(handle, s, sizeof(s));
 	if (size > 0)
+	{
 		value = strtoul(s, NULL, 16);
+	}
 	close(handle);
 	return value;
 }
-#endif
+#endif //HAVE_AMLOGIC
+#endif //gstreamer
 
 RESULT eServiceMP3::getPlayPosition(pts_t &pts)
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	gint64 pos;
 	pts = 0;
 
 	if (!m_gst_playbin || m_state != stRunning)
+	{
 		return -1;
-
+	}
 #if HAVE_AMLOGIC
 	if ((pos = get_pts_pcrscr()) > 0)
+	{
 		pos *= 11111LL;
-#else
-#if GST_VERSION_MAJOR < 1
-	if (audioSink || videoSink)
+	}
 #else
 	if ((audioSink || videoSink) && !m_paused && !m_sourceinfo.is_hls)
-#endif
 	{
 		g_signal_emit_by_name(videoSink ? videoSink : audioSink, "get-decoder-time", &pos);
-		if (!GST_CLOCK_TIME_IS_VALID(pos)) return -1;
-	}
-#endif
+		if (!GST_CLOCK_TIME_IS_VALID(pos))
+		{
+			return -1;
+		}
+	}
+#endif //HAVE_AMLOGIC
 	else
 	{
 		GstFormat fmt = GST_FORMAT_TIME;
-#if GST_VERSION_MAJOR < 1
-		if (!gst_element_query_position(m_gst_playbin, &fmt, &pos))
-#else
 		if (!gst_element_query_position(m_gst_playbin, fmt, &pos))
-#endif
 		{
 			eDebug("[eServiceMP3] gst_element_query_position failed in getPlayPosition");
 			return -1;
 		}
 	}
-
 	/* pos is in nanoseconds. we have 90 000 pts per second. */
 	pts = pos / 11111LL;
+#else //eplayer3 code
+	if (player && player->playback && !player->playback->isPlaying)
+	{
+		eDebug("eServiceMP3::%s !!!!EOF!!!! < -1", __func__);
+		if(m_state == stRunning)
+		{
+			m_event((iPlayableService*)this, evEOF);
+		}
+		pts = 0;
+		return -1;
+	}
+
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+	}
+	if (vpts <= 0)
+	{
+		return -1;
+	}
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts > 0 ? vpts : pts;
+#endif //gstreamer
 	return 0;
 }
 
 RESULT eServiceMP3::setTrickmode(int trick)
 {
-		/* trickmode is not yet supported by our dvbmediasinks. */
+	/* trickmode is not yet supported by our dvbmediasinks. */
 	return -1;
 }
 
 RESULT eServiceMP3::isCurrentlySeekable()
 {
+#if defined ENABLE_MEDIAFWGSTREAMER // Hellmaster1024: 1 for skipping 3 for skipping and fast forward
 	int ret = 3; /* just assume that seeking and fast/slow winding are possible */
 
 	if (!m_gst_playbin)
+	{
 		return 0;
-
+	}
 	return ret;
+#else //eplayer3 code
+	return 3;
+#endif //gstreamer
 }
 
 RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
@@ -1269,10 +1769,14 @@
 		name = m_ref.path;
 		size_t n = name.rfind('/');
 		if (n != std::string::npos)
+		{
 			name = name.substr(n + 1);
+		}
 	}
 	else
+	{
 		name = title;
+	}
 	return 0;
 }
 
@@ -1280,7 +1784,9 @@
 {
 	evt = nownext ? m_event_next : m_event_now;
 	if (!evt)
+	{
 		return -1;
+	}
 	return 0;
 }
 
@@ -1401,135 +1907,205 @@
 	{
 		switch (w)
 		{
-		case sProvider:
-			return "IPTV";
-		case sServiceref:
-			return m_ref.toString();
-		default:
-			break;
-		}
-	}
-
-	if ( !m_stream_tags && w < sUser && w > 26 )
+			case sProvider:
+			{
+				return "IPTV";
+			}
+			case sServiceref:
+			{
+				return m_ref.toString();
+			}
+			default:
+			{
+				break;
+			}
+		}
+	}
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (!m_stream_tags && w < sUser && w > 26)
+	{
 		return "";
+	}
 	const gchar *tag = 0;
 	switch (w)
 	{
-	case sTagTitle:
-		tag = GST_TAG_TITLE;
-		break;
-	case sTagArtist:
-		tag = GST_TAG_ARTIST;
-		break;
-	case sTagAlbum:
-		tag = GST_TAG_ALBUM;
-		break;
-	case sTagTitleSortname:
-		tag = GST_TAG_TITLE_SORTNAME;
-		break;
-	case sTagArtistSortname:
-		tag = GST_TAG_ARTIST_SORTNAME;
-		break;
-	case sTagAlbumSortname:
-		tag = GST_TAG_ALBUM_SORTNAME;
-		break;
-	case sTagDate:
-		GDate *date;
-		GstDateTime *date_time;
-		if (gst_tag_list_get_date(m_stream_tags, GST_TAG_DATE, &date))
-		{
-			gchar res[5];
-			snprintf(res, sizeof(res), "%04d", g_date_get_year(date));
-			g_date_free(date);
-			return (std::string)res;
-		}
-#if GST_VERSION_MAJOR >= 1
-		else if (gst_tag_list_get_date_time(m_stream_tags, GST_TAG_DATE_TIME, &date_time))
-		{
-			if (gst_date_time_has_year(date_time))
+		case sTagTitle:
+		{
+			tag = GST_TAG_TITLE;
+			break;
+		}
+		case sTagArtist:
+		{
+			tag = GST_TAG_ARTIST;
+			break;
+		}
+		case sTagAlbum:
+		{
+			tag = GST_TAG_ALBUM;
+			break;
+		}
+		case sTagTitleSortname:
+		{
+			tag = GST_TAG_TITLE_SORTNAME;
+			break;
+		}
+		case sTagArtistSortname:
+		{
+			tag = GST_TAG_ARTIST_SORTNAME;
+			break;
+		}
+		case sTagAlbumSortname:
+		{
+			tag = GST_TAG_ALBUM_SORTNAME;
+			break;
+		}
+		case sTagDate:
+		{
+			GDate *date;
+			GstDateTime *date_time;
+			if (gst_tag_list_get_date(m_stream_tags, GST_TAG_DATE, &date))
 			{
 				gchar res[5];
-				snprintf(res, sizeof(res), "%04d", gst_date_time_get_year(date_time));
+				snprintf(res, sizeof(res), "%04d", g_date_get_year(date));
+				g_date_free(date);
+				return (std::string)res;
+			}
+			else if (gst_tag_list_get_date_time(m_stream_tags, GST_TAG_DATE_TIME, &date_time))
+			{
+				if (gst_date_time_has_year(date_time))
+				{
+					gchar res[5];
+					snprintf(res, sizeof(res), "%04d", gst_date_time_get_year(date_time));
+					gst_date_time_unref(date_time);
+					return (std::string)res;
+				}
 				gst_date_time_unref(date_time);
-				return (std::string)res;
-			}
-			gst_date_time_unref(date_time);
-		}
-#endif
-		break;
-	case sTagComposer:
-		tag = GST_TAG_COMPOSER;
-		break;
-	case sTagGenre:
-		tag = GST_TAG_GENRE;
-		break;
-	case sTagComment:
-		tag = GST_TAG_COMMENT;
-		break;
-	case sTagExtendedComment:
-		tag = GST_TAG_EXTENDED_COMMENT;
-		break;
-	case sTagLocation:
-		tag = GST_TAG_LOCATION;
-		break;
-	case sTagHomepage:
-		tag = GST_TAG_HOMEPAGE;
-		break;
-	case sTagDescription:
-		tag = GST_TAG_DESCRIPTION;
-		break;
-	case sTagVersion:
-		tag = GST_TAG_VERSION;
-		break;
-	case sTagISRC:
-		tag = GST_TAG_ISRC;
-		break;
-	case sTagOrganization:
-		tag = GST_TAG_ORGANIZATION;
-		break;
-	case sTagCopyright:
-		tag = GST_TAG_COPYRIGHT;
-		break;
-	case sTagCopyrightURI:
-		tag = GST_TAG_COPYRIGHT_URI;
-		break;
-	case sTagContact:
-		tag = GST_TAG_CONTACT;
-		break;
-	case sTagLicense:
-		tag = GST_TAG_LICENSE;
-		break;
-	case sTagLicenseURI:
-		tag = GST_TAG_LICENSE_URI;
-		break;
-	case sTagCodec:
-		tag = GST_TAG_CODEC;
-		break;
-	case sTagAudioCodec:
-		tag = GST_TAG_AUDIO_CODEC;
-		break;
-	case sTagVideoCodec:
-		tag = GST_TAG_VIDEO_CODEC;
-		break;
-	case sTagEncoder:
-		tag = GST_TAG_ENCODER;
-		break;
-	case sTagLanguageCode:
-		tag = GST_TAG_LANGUAGE_CODE;
-		break;
-	case sTagKeywords:
-		tag = GST_TAG_KEYWORDS;
-		break;
-	case sTagChannelMode:
-		tag = "channel-mode";
-		break;
-	case sUser+12:
-		return m_errorInfo.error_message;
-	default:
+			}
+			break;
+		}
+		case sTagComposer:
+		{
+			tag = GST_TAG_COMPOSER;
+			break;
+		}
+		case sTagGenre:
+		{
+			tag = GST_TAG_GENRE;
+			break;
+		}
+		case sTagComment:
+		{
+			tag = GST_TAG_COMMENT;
+			break;
+		}
+		case sTagExtendedComment:
+		{
+			tag = GST_TAG_EXTENDED_COMMENT;
+			break;
+		}
+		case sTagLocation:
+		{
+			tag = GST_TAG_LOCATION;
+			break;
+		}
+		case sTagHomepage:
+		{
+			tag = GST_TAG_HOMEPAGE;
+			break;
+		}
+		case sTagDescription:
+		{
+			tag = GST_TAG_DESCRIPTION;
+			break;
+		}
+		case sTagVersion:
+		{
+			tag = GST_TAG_VERSION;
+			break;
+		}
+		case sTagISRC:
+		{
+			tag = GST_TAG_ISRC;
+			break;
+		}
+		case sTagOrganization:
+		{
+			tag = GST_TAG_ORGANIZATION;
+			break;
+		}
+		case sTagCopyright:
+		{
+			tag = GST_TAG_COPYRIGHT;
+			break;
+		}
+		case sTagCopyrightURI:
+		{
+			tag = GST_TAG_COPYRIGHT_URI;
+			break;
+		}
+		case sTagContact:
+		{
+			tag = GST_TAG_CONTACT;
+			break;
+		}
+		case sTagLicense:
+		{
+			tag = GST_TAG_LICENSE;
+			break;
+		}
+		case sTagLicenseURI:
+		{
+			tag = GST_TAG_LICENSE_URI;
+			break;
+		}
+		case sTagCodec:
+		{
+			tag = GST_TAG_CODEC;
+			break;
+		}
+		case sTagAudioCodec:
+		{
+			tag = GST_TAG_AUDIO_CODEC;
+			break;
+		}
+		case sTagVideoCodec:
+		{
+			tag = GST_TAG_VIDEO_CODEC;
+			break;
+		}
+		case sTagEncoder:
+		{
+			tag = GST_TAG_ENCODER;
+			break;
+		}
+		case sTagLanguageCode:
+		{
+			tag = GST_TAG_LANGUAGE_CODE;
+			break;
+		}
+		case sTagKeywords:
+		{
+			tag = GST_TAG_KEYWORDS;
+			break;
+		}
+		case sTagChannelMode:
+		{
+			tag = "channel-mode";
+			break;
+		}
+		case sUser+12:
+		{
+			return m_errorInfo.error_message;
+		}
+		default:
+		{
+			return "";
+		}
+	}
+	if ( !tag )
+	{
 		return "";
 	}
-	if ( !tag )
-		return "";
 	gchar *value = NULL;
 	if (m_stream_tags && gst_tag_list_get_string(m_stream_tags, tag, &value))
 	{
@@ -1537,9 +2113,88 @@
 		g_free(value);
 		return res;
 	}
+#else //eplayer3 code
+	char * tag = NULL;
+	char * res_str = NULL;
+	switch (w)
+	{
+		case sTagTitle:
+		{
+			tag = strdup("Title");
+			break;
+		}
+		case sTagArtist:
+		{
+			tag = strdup("Artist");
+			break;
+		}
+		case sTagAlbum:
+		{
+			tag = strdup("Album");
+			break;
+		}
+		case sTagComment:
+		{
+			tag = strdup("Comment");
+			break;
+		}
+		case sTagTrackNumber:
+		{
+			tag = strdup("Track");
+			break;
+		}
+		case sTagGenre:
+		{
+			tag = strdup("Genre");
+			break;
+		}
+		case sTagDate:
+		{
+			tag = strdup("Year");
+			break;
+		}
+		case sTagVideoCodec:
+		{
+			tag = strdup("VideoType");
+			break;
+		}
+		case sTagAudioCodec:
+		{
+			tag = strdup("AudioType");
+			break;
+		}
+		default:
+		{
+			return "";
+		}
+	}
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+	free(tag);
+#endif
 	return "";
 }
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 ePtr<iServiceInfoContainer> eServiceMP3::getInfoObject(int w)
 {
 	eServiceMP3InfoContainer *container = new eServiceMP3InfoContainer;
@@ -1549,45 +2204,64 @@
 	switch (w)
 	{
 		case sTagTrackGain:
+		{
 			tag = GST_TAG_TRACK_GAIN;
 			break;
+		}
 		case sTagTrackPeak:
+		{
 			tag = GST_TAG_TRACK_PEAK;
 			break;
+		}
 		case sTagAlbumGain:
+		{
 			tag = GST_TAG_ALBUM_GAIN;
 			break;
+		}
 		case sTagAlbumPeak:
+		{
 			tag = GST_TAG_ALBUM_PEAK;
 			break;
+		}
 		case sTagReferenceLevel:
+		{
 			tag = GST_TAG_REFERENCE_LEVEL;
 			break;
+		}
 		case sTagBeatsPerMinute:
+		{
 			tag = GST_TAG_BEATS_PER_MINUTE;
 			break;
+		}
 		case sTagImage:
+		{
 			tag = GST_TAG_IMAGE;
 			isBuffer = true;
 			break;
+		}
 		case sTagPreviewImage:
+		{
 			tag = GST_TAG_PREVIEW_IMAGE;
 			isBuffer = true;
 			break;
+		}
 		case sTagAttachment:
+		{
 			tag = GST_TAG_ATTACHMENT;
 			isBuffer = true;
 			break;
+		}
 		default:
-			break;
-	}
-
+		{
+			break;
+		}
+	}
 	if (m_stream_tags && tag)
 	{
 		if (isBuffer)
 		{
 			const GValue *gv_buffer = gst_tag_list_get_value_index(m_stream_tags, tag, 0);
-			if ( gv_buffer )
+			if (gv_buffer)
 			{
 				GstBuffer *buffer;
 				buffer = gst_value_get_buffer (gv_buffer);
@@ -1603,6 +2277,7 @@
 	}
 	return retval;
 }
+#endif
 
 RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
 {
@@ -1641,13 +2316,18 @@
 
 int eServiceMP3::getCurrentTrack()
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	if (m_currentAudioStream == -1)
+	{
 		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
+	}
+#endif
 	return m_currentAudioStream;
 }
 
 RESULT eServiceMP3::selectTrack(unsigned int i)
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	bool validposition = false;
 	pts_t ppos = 0;
 	if (getPlayPosition(ppos) >= 0)
@@ -1655,32 +2335,50 @@
 		validposition = true;
 		ppos -= 90000;
 		if (ppos < 0)
+		{
 			ppos = 0;
+		}
 	}
 	if (validposition)
 	{
 		/* flush */
 		seekTo(ppos);
 	}
+#endif
 	return selectAudioStream(i);
 }
 
 int eServiceMP3::selectAudioStream(int i)
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	int current_audio;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
 #if HAVE_AMLOGIC
 	if (m_currentAudioStream != i)
+	{
 		AmlSwitchAudio(i);
-#endif
+	}
+#endif //HAVE_AMLOGIC
 	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
-	if ( current_audio == i )
-	{
-		eDebug ("[eServiceMP3] switched to audio stream %i", current_audio);
+	if (current_audio == i)
+	{
+		eDebug ("[eServiceMP3] switched to audio stream %d", current_audio);
 		m_currentAudioStream = i;
 		return 0;
 	}
 	return -1;
+#else //eplayer3 code
+	if (i != m_currentAudioStream)
+	{
+		if (player && player->playback)
+		{
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		}
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+#endif
 }
 
 int eServiceMP3::getCurrentChannel()
@@ -1700,30 +2398,24 @@
 	{
 		return -2;
 	}
-
 	info.m_description = m_audioStreams[i].codec;
 
 	if (info.m_language.empty())
 	{
 		info.m_language = m_audioStreams[i].language_code;
 	}
-
 	return 0;
 }
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 subtype_t getSubtitleType(GstPad* pad, gchar *g_codec=NULL)
 {
 	subtype_t type = stUnknown;
-#if GST_VERSION_MAJOR < 1
-	GstCaps* caps = gst_pad_get_negotiated_caps(pad);
-#else
 	GstCaps* caps = gst_pad_get_current_caps(pad);
-#endif
 	if (!caps && !g_codec)
 	{
 		caps = gst_pad_get_allowed_caps(pad);
 	}
-
 	if (caps && !gst_caps_is_empty(caps))
 	{
 		GstStructure* str = gst_caps_get_structure(caps, 0);
@@ -1733,38 +2425,57 @@
 			eDebug("[eServiceMP3] getSubtitleType::subtitle probe caps type=%s", g_type ? g_type : "(null)");
 			if (g_type)
 			{
-#if GST_VERSION_MAJOR < 1
-				if ( !strcmp(g_type, "video/x-dvd-subpicture") )
-#else
 				if ( !strcmp(g_type, "subpicture/x-dvd") )
-#endif
+				{
 					type = stVOB;
+				}
 				else if ( !strcmp(g_type, "text/x-pango-markup") )
+				{
 					type = stSRT;
+				}
 				else if ( !strcmp(g_type, "text/plain") || !strcmp(g_type, "text/x-plain") || !strcmp(g_type, "text/x-raw") )
+				{
 					type = stPlainText;
+				}
 				else if ( !strcmp(g_type, "subpicture/x-pgs") )
+				{
 					type = stPGS;
+				}
 				else
+				{
 					eDebug("[eServiceMP3] getSubtitleType::unsupported subtitle caps %s (%s)", g_type, g_codec ? g_codec : "(null)");
-			}
-		}
-	}
-	else if ( g_codec )
+				}
+			}
+		}
+	}
+	else if (g_codec)
 	{
 		eDebug("[eServiceMP3] getSubtitleType::subtitle probe codec tag=%s", g_codec);
-		if ( !strcmp(g_codec, "VOB") )
+		if (!strcmp(g_codec, "VOB"))
+		{
 			type = stVOB;
-		else if ( !strcmp(g_codec, "SubStation Alpha") || !strcmp(g_codec, "SSA") )
+		}
+		else if (!strcmp(g_codec, "SubStation Alpha")
+		||       !strcmp(g_codec, "SSA"))
+		{
 			type = stSSA;
-		else if ( !strcmp(g_codec, "ASS") )
+		}
+		else if (!strcmp(g_codec, "ASS"))
+		{
 			type = stASS;
-		else if ( !strcmp(g_codec, "SRT") )
+		}
+		else if (!strcmp(g_codec, "SRT"))
+		{
 			type = stSRT;
-		else if ( !strcmp(g_codec, "UTF-8 plain text") )
+		}
+		else if (!strcmp(g_codec, "UTF-8 plain text"))
+		{
 			type = stPlainText;
+		}
 		else
+		{
 			eDebug("[eServiceMP3] getSubtitleType::unsupported subtitle codec %s", g_codec);
+		}
 	}
 	else
 		eDebug("[eServiceMP3] getSubtitleType::unidentifiable subtitle stream!");
@@ -1775,69 +2486,66 @@
 void eServiceMP3::gstBusCall(GstMessage *msg)
 {
 	if (!msg)
+	{
 		return;
+	}
 	gchar *sourceName;
 	GstObject *source;
 	GstElement *subsink;
 	source = GST_MESSAGE_SRC(msg);
 	if (!GST_IS_OBJECT(source))
+	{
 		return;
+	}
 	sourceName = gst_object_get_name(source);
 #if 0
 	gchar *string;
 	if (gst_message_get_structure(msg))
+	{
 		string = gst_structure_to_string(gst_message_get_structure(msg));
+	}
 	else
+	{
 		string = g_strdup(GST_MESSAGE_TYPE_NAME(msg));
+	}
 	eDebug("[eServiceMP3] eTsRemoteSource::gst_message from %s: %s", sourceName, string);
 	g_free(string);
 #endif
 	switch (GST_MESSAGE_TYPE (msg))
 	{
 		case GST_MESSAGE_EOS:
+		{
 			m_event((iPlayableService*)this, evEOF);
 			break;
+		}
 		case GST_MESSAGE_STATE_CHANGED:
 		{
-			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+			if (GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+			{
 				break;
-
+			}
 			GstState old_state, new_state;
 			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
 
-			if(old_state == new_state)
+			if (old_state == new_state)
+			{
 				break;
-
+			}
 			eDebug("[eServiceMP3] state transition %s -> %s", gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
 
 			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
 
-			switch(transition)
+			switch (transition)
 			{
 				case GST_STATE_CHANGE_READY_TO_PAUSED:
 				{
 					m_state = stRunning;
 					m_event(this, evStart);
-#if GST_VERSION_MAJOR >= 1
 					GValue result = { 0, };
-#endif
 					GstIterator *children;
 					subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
 					if (subsink)
 					{
-#ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
-						/*
-						 * HACK: disable sync mode for now, gstreamer suffers from a bug causing sparse streams to loose sync, after pause/resume / skip
-						 * see: https://bugzilla.gnome.org/show_bug.cgi?id=619434
-						 * Sideeffect of using sync=false is that we receive subtitle buffers (far) ahead of their
-						 * display time.
-						 * Not too far ahead for subtitles contained in the media container.
-						 * But for external srt files, we could receive all subtitles at once.
-						 * And not just once, but after each pause/resume / skip.
-						 * So as soon as gstreamer has been fixed to keep sync in sparse streams, sync needs to be re-enabled.
-						 */
-						g_object_set (G_OBJECT (subsink), "sync", FALSE, NULL);
-#endif
 #if 0
 						/* we should not use ts-offset to sync with the decoder time, we have to do our own decoder timekeeping */
 						g_object_set (G_OBJECT (subsink), "ts-offset", -2LL * GST_SECOND, NULL);
@@ -1860,26 +2568,18 @@
 						videoSink = NULL;
 					}
 					children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
-#if GST_VERSION_MAJOR < 1
-					audioSink = GST_ELEMENT_CAST(gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, (gpointer)"GstDVBAudioSink"));
-#else
 					if (gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &result, (gpointer)"GstDVBAudioSink"))
 					{
 						audioSink = GST_ELEMENT_CAST(g_value_dup_object(&result));
 						g_value_unset(&result);
 					}
-#endif
 					gst_iterator_free(children);
 					children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
-#if GST_VERSION_MAJOR < 1
-					videoSink = GST_ELEMENT_CAST(gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, (gpointer)"GstDVBVideoSink"));
-#else
 					if (gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &result, (gpointer)"GstDVBVideoSink"))
 					{
 						videoSink = GST_ELEMENT_CAST(g_value_dup_object(&result));
 						g_value_unset(&result);
 					}
-#endif
 					gst_iterator_free(children);
 
 					/* if we are in preroll already do not check again the state */
@@ -1887,11 +2587,12 @@
 					{
 						m_is_live = (gst_element_get_state(m_gst_playbin, NULL, NULL, 0LL) == GST_STATE_CHANGE_NO_PREROLL);
 					}
-
 					setAC3Delay(ac3_delay);
 					setPCMDelay(pcm_delay);
-					if(!m_cuesheet_loaded) /* cuesheet CVR */
+					if (!m_cuesheet_loaded) /* cuesheet CVR */
+					{
 						loadCuesheet();
+					}
 					updateEpgCacheNowNext();
 
 					if (!videoSink || m_ref.getData(0) == 2) // show radio pic
@@ -1901,8 +2602,8 @@
 						m_decoder = new eTSMPEGDecoder(NULL, 0);
 						m_decoder->showSinglePic(radio_pic.c_str());
 					}
-
-				}	break;
+					break;
+				}
 				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
 				{
 					m_paused = false;
@@ -1914,16 +2615,24 @@
 						std::vector<std::string> autoaudio_languages;
 						configvalue = eConfigManager::getConfigValue("config.autolanguage.audio_autoselect1");
 						if (configvalue != "" && configvalue != "None")
+						{
 							autoaudio_languages.push_back(configvalue);
+						}
 						configvalue = eConfigManager::getConfigValue("config.autolanguage.audio_autoselect2");
 						if (configvalue != "" && configvalue != "None")
+						{
 							autoaudio_languages.push_back(configvalue);
+						}
 						configvalue = eConfigManager::getConfigValue("config.autolanguage.audio_autoselect3");
 						if (configvalue != "" && configvalue != "None")
+						{
 							autoaudio_languages.push_back(configvalue);
+						}
 						configvalue = eConfigManager::getConfigValue("config.autolanguage.audio_autoselect4");
 						if (configvalue != "" && configvalue != "None")
+						{
 							autoaudio_languages.push_back(configvalue);
+						}
 						for (unsigned int i = 0; i < m_audioStreams.size(); i++)
 						{
 							if (!m_audioStreams[i].language_code.empty())
@@ -1940,16 +2649,19 @@
 								}
 							}
 						}
-
 						if (autoaudio)
+						{
 							selectTrack(autoaudio);
+						}
 					}
 					m_event((iPlayableService*)this, evGstreamerPlayStarted);
-				}	break;
+					break;
+				}
 				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
 				{
 					m_paused = true;
-				}	break;
+					break;
+				}
 				case GST_STATE_CHANGE_PAUSED_TO_READY:
 				{
 					if (audioSink)
@@ -1962,7 +2674,20 @@
 						gst_object_unref(GST_OBJECT(videoSink));
 						videoSink = NULL;
 					}
-				}	break;
+					break;
+				}
+				case GST_STATE_CHANGE_READY_TO_NULL:
+				{
+					break;
+				}
+				case GST_STATE_CHANGE_NULL_TO_READY:
+				case GST_STATE_CHANGE_NULL_TO_NULL:
+				case GST_STATE_CHANGE_READY_TO_READY:
+				case GST_STATE_CHANGE_PAUSED_TO_PAUSED:
+				case GST_STATE_CHANGE_PLAYING_TO_PLAYING:
+				{
+//					break;
+				}
 			}
 			break;
 		}
@@ -1973,19 +2698,24 @@
 			gst_message_parse_error (msg, &err, &debug);
 			g_free (debug);
 			eWarning("[eServiceMP3] Gstreamer error: %s (%i) from %s", err->message, err->code, sourceName );
-			if ( err->domain == GST_STREAM_ERROR )
-			{
-				if ( err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND )
-				{
-					if ( g_strrstr(sourceName, "videosink") )
+			if (err->domain == GST_STREAM_ERROR)
+			{
+				if (err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND)
+				{
+					if (g_strrstr(sourceName, "videosink"))
+					{
 						m_event((iPlayableService*)this, evUser+11);
-					else if ( g_strrstr(sourceName, "audiosink") )
+					}
+					else if (g_strrstr(sourceName, "audiosink"))
+					{
 						m_event((iPlayableService*)this, evUser+10);
-				}
-			}
-			else if ( err->domain == GST_RESOURCE_ERROR )
-			{
-				if ( err->code == GST_RESOURCE_ERROR_OPEN_READ || err->code == GST_RESOURCE_ERROR_READ )
+					}
+				}
+			}
+			else if (err->domain == GST_RESOURCE_ERROR)
+			{
+				if (err->code == GST_RESOURCE_ERROR_OPEN_READ
+				||  err->code == GST_RESOURCE_ERROR_READ)
 				{
 					stop();
 				}
@@ -1993,7 +2723,6 @@
 			g_error_free(err);
 			break;
 		}
-#if GST_VERSION_MAJOR >= 1
 		case GST_MESSAGE_WARNING:
 		{
 			gchar *debug_warn = NULL;
@@ -2002,11 +2731,12 @@
 			/* CVR this Warning occurs from time to time with external srt files
 			When a new seek is done the problem off to long wait times before subtitles appears,
 			after movie was restarted with a resume position is solved. */
-			if(!strncmp(warn->message , "Internal data flow problem", 26) && !strncmp(sourceName, "subtitle_sink", 13))
+			if (!strncmp(warn->message , "Internal data flow problem", 26)
+			&&  !strncmp(sourceName, "subtitle_sink", 13))
 			{
 				eWarning("[eServiceMP3] Gstreamer warning : %s (%i) from %s" , warn->message, warn->code, sourceName);
 				subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
-				if(subsink)
+				if (subsink)
 				{
 					if (!gst_element_seek (subsink, m_currentTrickRatio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT),
 						GST_SEEK_TYPE_SET, m_last_seek_pos,
@@ -2021,7 +2751,6 @@
 			g_error_free(warn);
 			break;
 		}
-#endif
 		case GST_MESSAGE_INFO:
 		{
 			gchar *debug;
@@ -2029,10 +2758,12 @@
 
 			gst_message_parse_info (msg, &inf, &debug);
 			g_free (debug);
-			if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
-			{
-				if ( g_strrstr(sourceName, "videosink") )
+			if (inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE)
+			{
+				if (g_strrstr(sourceName, "videosink"))
+				{
 					m_event((iPlayableService*)this, evUser+14);
+				}
 			}
 			g_error_free(inf);
 			break;
@@ -2052,41 +2783,31 @@
 					break;
 				}
 				if (m_stream_tags)
+				{
 					gst_tag_list_free(m_stream_tags);
+				}
 				m_stream_tags = result;
 			}
-
 			if (!m_coverart)
 			{
 				const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
-				if ( gv_image )
+				if (gv_image)
 				{
 					GstBuffer *buf_image;
-#if GST_VERSION_MAJOR < 1
-					buf_image = gst_value_get_buffer(gv_image);
-#else
 					GstSample *sample;
 					sample = (GstSample *)g_value_get_boxed(gv_image);
 					buf_image = gst_sample_get_buffer(sample);
-#endif
 					int fd = open("/tmp/.id3coverart", O_CREAT|O_WRONLY|O_TRUNC, 0644);
 					if (fd >= 0)
 					{
 						guint8 *data;
 						gsize size;
-#if GST_VERSION_MAJOR < 1
-						data = GST_BUFFER_DATA(buf_image);
-						size = GST_BUFFER_SIZE(buf_image);
-#else
 						GstMapInfo map;
 						gst_buffer_map(buf_image, &map, GST_MAP_READ);
 						data = map.data;
 						size = map.size;
-#endif
 						int ret = write(fd, data, size);
-#if GST_VERSION_MAJOR >= 1
 						gst_buffer_unmap(buf_image, &map);
-#endif
 						close(fd);
 						m_coverart = true;
 						m_event((iPlayableService*)this, evUser+13);
@@ -2099,30 +2820,29 @@
 			break;
 		}
 		/* TOC entry intercept used for chapter support CVR */
-#if GST_VERSION_MAJOR >= 1
 		case GST_MESSAGE_TOC:
 		{
 			HandleTocEntry(msg);
 			break;
 		}
-#endif
 		case GST_MESSAGE_ASYNC_DONE:
 		{
-			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+			if (GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+			{
 				break;
-
+			}
 			gint i, n_video = 0, n_audio = 0, n_text = 0;
 
 			g_object_get (m_gst_playbin, "n-video", &n_video, NULL);
 			g_object_get (m_gst_playbin, "n-audio", &n_audio, NULL);
 			g_object_get (m_gst_playbin, "n-text", &n_text, NULL);
 
-
 			eDebug("[eServiceMP3] async-done - %d video, %d audio, %d subtitle", n_video, n_audio, n_text);
 
-			if ( n_video + n_audio <= 0 )
+			if (n_video + n_audio <= 0)
+			{
 				stop();
-
+			}
 			m_audioStreams.clear();
 			m_subtitleStreams.clear();
 
@@ -2133,14 +2853,12 @@
 				GstTagList *tags = NULL;
 				GstPad* pad = 0;
 				g_signal_emit_by_name (m_gst_playbin, "get-audio-pad", i, &pad);
-#if GST_VERSION_MAJOR < 1
-				GstCaps* caps = gst_pad_get_negotiated_caps(pad);
-#else
 				GstCaps* caps = gst_pad_get_current_caps(pad);
-#endif
 				gst_object_unref(pad);
 				if (!caps)
+				{
 					continue;
+				}
 				GstStructure* str = gst_caps_get_structure(caps, 0);
 				const gchar *g_type = gst_structure_get_name(str);
 				eDebug("[eServiceMP3] AUDIO STRUCT=%s", g_type);
@@ -2150,11 +2868,7 @@
 				g_codec = NULL;
 				g_lang = NULL;
 				g_signal_emit_by_name (m_gst_playbin, "get-audio-tags", i, &tags);
-#if GST_VERSION_MAJOR < 1
-				if (tags && gst_is_tag_list(tags))
-#else
 				if (tags && GST_IS_TAG_LIST(tags))
-#endif
 				{
 					if (gst_tag_list_get_string(tags, GST_TAG_AUDIO_CODEC, &g_codec))
 					{
@@ -2172,7 +2886,6 @@
 				m_audioStreams.push_back(audio);
 				gst_caps_unref(caps);
 			}
-
 			for (i = 0; i < n_text; i++)
 			{
 				gchar *g_codec = NULL, *g_lang = NULL;
@@ -2180,11 +2893,7 @@
 				g_signal_emit_by_name (m_gst_playbin, "get-text-tags", i, &tags);
 				subtitleStream subs;
 				subs.language_code = "und";
-#if GST_VERSION_MAJOR < 1
-				if (tags && gst_is_tag_list(tags))
-#else
 				if (tags && GST_IS_TAG_LIST(tags))
-#endif
 				{
 					if (gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang))
 					{
@@ -2194,31 +2903,31 @@
 					gst_tag_list_get_string(tags, GST_TAG_SUBTITLE_CODEC, &g_codec);
 					gst_tag_list_free(tags);
 				}
-
 				eDebug("[eServiceMP3] subtitle stream=%i language=%s codec=%s", i, subs.language_code.c_str(), g_codec ? g_codec : "(null)");
 
 				GstPad* pad = 0;
 				g_signal_emit_by_name (m_gst_playbin, "get-text-pad", i, &pad);
-				if ( pad )
+				if (pad)
+				{
 					g_signal_connect (G_OBJECT (pad), "notify::caps", G_CALLBACK (gstTextpadHasCAPS), this);
-
+				}
 				subs.type = getSubtitleType(pad, g_codec);
 				gst_object_unref(pad);
 				g_free(g_codec);
 				m_subtitleStreams.push_back(subs);
 			}
-
 			m_event((iPlayableService*)this, evUpdatedInfo);
 			if (m_seek_paused)
 			{
 				m_seek_paused = false;
 				gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
 			}
-
 			if ( m_errorInfo.missing_codec != "" )
 			{
 				if (m_errorInfo.missing_codec.find("video/") == 0 || (m_errorInfo.missing_codec.find("audio/") == 0 && m_audioStreams.empty()))
+				{
 					m_event((iPlayableService*)this, evUser+12);
+				}
 			}
 			break;
 		}
@@ -2227,7 +2936,7 @@
 			const GstStructure *msgstruct = gst_message_get_structure(msg);
 			if (msgstruct)
 			{
-				if ( gst_is_missing_plugin_message(msg) )
+				if (gst_is_missing_plugin_message(msg))
 				{
 					GstCaps *caps = NULL;
 					gst_structure_get (msgstruct, "detail", GST_TYPE_CAPS, &caps, NULL);
@@ -2235,7 +2944,7 @@
 					{
 						std::string codec = (const char*) gst_caps_to_string(caps);
 						gchar *description = gst_missing_plugin_message_get_description(msg);
-						if ( description )
+						if (description)
 						{
 							eDebug("[eServiceMP3] m_errorInfo.missing_codec = %s", codec.c_str());
 							m_errorInfo.error_message = "GStreamer plugin " + (std::string)description + " not available!\n";
@@ -2248,27 +2957,36 @@
 				else
 				{
 					const gchar *eventname = gst_structure_get_name(msgstruct);
-					if ( eventname )
+					if (eventname)
 					{
-						if (!strcmp(eventname, "eventSizeChanged") || !strcmp(eventname, "eventSizeAvail"))
+						if (!strcmp(eventname, "eventSizeChanged")
+						||  !strcmp(eventname, "eventSizeAvail"))
 						{
 							gst_structure_get_int (msgstruct, "aspect_ratio", &m_aspect);
 							gst_structure_get_int (msgstruct, "width", &m_width);
 							gst_structure_get_int (msgstruct, "height", &m_height);
 							if (strstr(eventname, "Changed"))
+							{
 								m_event((iPlayableService*)this, evVideoSizeChanged);
+							}
 						}
-						else if (!strcmp(eventname, "eventFrameRateChanged") || !strcmp(eventname, "eventFrameRateAvail"))
+						else if (!strcmp(eventname, "eventFrameRateChanged")
+						||       !strcmp(eventname, "eventFrameRateAvail"))
 						{
 							gst_structure_get_int (msgstruct, "frame_rate", &m_framerate);
 							if (strstr(eventname, "Changed"))
+							{
 								m_event((iPlayableService*)this, evVideoFramerateChanged);
+							}
 						}
-						else if (!strcmp(eventname, "eventProgressiveChanged") || !strcmp(eventname, "eventProgressiveAvail"))
+						else if (!strcmp(eventname, "eventProgressiveChanged")
+						||       !strcmp(eventname, "eventProgressiveAvail"))
 						{
 							gst_structure_get_int (msgstruct, "progressive", &m_progressive);
 							if (strstr(eventname, "Changed"))
+							{
 								m_event((iPlayableService*)this, evVideoProgressiveChanged);
+							}
 						}
 						else if (!strcmp(eventname, "eventGammaChanged"))
 						{
@@ -2290,6 +3008,7 @@
 			break;
 		}
 		case GST_MESSAGE_BUFFERING:
+		{
 			if (m_sourceinfo.is_streaming)
 			{
 				GstBufferingMode mode;
@@ -2298,7 +3017,7 @@
 				gst_message_parse_buffering_stats(msg, &mode, &(m_bufferInfo.avgInRate), &(m_bufferInfo.avgOutRate), &(m_bufferInfo.bufferingLeft));
 				m_event((iPlayableService*)this, evBuffering);
 				/*
-				 * we don't react to buffer level messages, unless we are configured to use a prefill buffer
+				 * we do not react to buffer level messages, unless we are configured to use a prefill buffer
 				 * (even if we are not configured to, we still use the buffer, but we rely on it to remain at the
 				 * healthy level at all times, without ever having to pause the stream)
 				 *
@@ -2339,8 +3058,11 @@
 				}
 			}
 			break;
+		}
 		default:
-			break;
+		{
+			break;
+		}
 	}
 	g_free (sourceName);
 }
@@ -2362,11 +3084,14 @@
 GstBusSyncReply eServiceMP3::gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data)
 {
 	eServiceMP3 *_this = (eServiceMP3*)user_data;
-	if (_this) _this->handleMessage(message);
+	if (_this)
+	{
+		_this->handleMessage(message);
+	}
 	return GST_BUS_DROP;
 }
-/*Processing TOC CVR */
-#if GST_VERSION_MAJOR >= 1
+
+	/*Processing TOC CVR */
 void eServiceMP3::HandleTocEntry(GstMessage *msg)
 {
 	/* limit TOC to dvbvideosink cue sheet only works for video media */
@@ -2392,9 +3117,13 @@
 						{
 							m_use_chapter_entries = true;
 							if (m_cuesheet_loaded)
+							{
 								m_cue_entries.clear();
+							}
 							else
+							{
 								loadCuesheet();
+							}
 						}
 						/* first chapter is movie start no cut needed */
 						else if (y >= 1)
@@ -2404,8 +3133,10 @@
 							gint type = 0;
 							gst_toc_entry_get_start_stop_times(sub_entry, &start, NULL);
 							type = 2;
-							if(start > 0)
+							if (start > 0)
+							{
 								pts = start / 11111;
+							}
 							if (pts > 0)
 							{
 								m_cue_entries.insert(cueEntry(pts, type));
@@ -2424,14 +3155,14 @@
 				}
 			}
 		}
-		eDebug("[eServiceMP3] TOC entry from source %s processed", GST_MESSAGE_SRC_NAME(msg));
+		//eDebug("[eServiceMP3] TOC entry from source %s processed", GST_MESSAGE_SRC_NAME(msg));
 	}
 	else
 	{
 		eDebug("[eServiceMP3] TOC entry from source %s not used", GST_MESSAGE_SRC_NAME(msg));
 	}
 }
-#endif
+
 void eServiceMP3::playbinNotifySource(GObject *object, GParamSpec *unused, gpointer user_data)
 {
 	GstElement *source = NULL;
@@ -2461,11 +3192,7 @@
 		}
 		if (g_object_class_find_property(G_OBJECT_GET_CLASS(source), "extra-headers") != 0 && !_this->m_extra_headers.empty())
 		{
-#if GST_VERSION_MAJOR < 1
-			GstStructure *extras = gst_structure_empty_new("extras");
-#else
 			GstStructure *extras = gst_structure_new_empty("extras");
-#endif
 			size_t pos = 0;
 			while (pos != std::string::npos)
 			{
@@ -2532,17 +3259,13 @@
 			}
 		}
 		else if (g_str_has_prefix(elementname, "uridecodebin")
-#if GST_VERSION_MAJOR < 1
-			|| g_str_has_prefix(elementname, "decodebin2"))
-#else
-			|| g_str_has_prefix(elementname, "decodebin"))
-#endif
+		||       g_str_has_prefix(elementname, "decodebin"))
 		{
 			/*
 			 * Listen for queue2 element added to uridecodebin/decodebin2 as well.
 			 * Ignore other bins since they may have unrelated queues
 			 */
-				g_signal_connect(element, "element-added", G_CALLBACK(handleElementAdded), user_data);
+			g_signal_connect(element, "element-added", G_CALLBACK(handleElementAdded), user_data);
 		}
 		g_free(elementname);
 	}
@@ -2551,44 +3274,59 @@
 audiotype_t eServiceMP3::gstCheckAudioPad(GstStructure* structure)
 {
 	if (!structure)
+	{
 		return atUnknown;
-
-	if ( gst_structure_has_name (structure, "audio/mpeg"))
+	}
+	if (gst_structure_has_name (structure, "audio/mpeg"))
 	{
 		gint mpegversion, layer = -1;
 		if (!gst_structure_get_int (structure, "mpegversion", &mpegversion))
+		{
 			return atUnknown;
-
-		switch (mpegversion) {
+		}
+		switch (mpegversion)
+		{
 			case 1:
-				{
-					gst_structure_get_int (structure, "layer", &layer);
-					if ( layer == 3 )
-						return atMP3;
-					else
-						return atMPEG;
-					break;
-				}
+			{
+				gst_structure_get_int (structure, "layer", &layer);
+				if (layer == 3)
+				{
+					return atMP3;
+				}
+				else
+				{
+					return atMPEG;
+				}
+				break; // superfluous
+			}
 			case 2:
+			{
 				return atAAC;
+			}
 			case 4:
+			{
 				return atAAC;
+			}
 			default:
+			{
 				return atUnknown;
-		}
-	}
-
-	else if ( gst_structure_has_name (structure, "audio/x-ac3") || gst_structure_has_name (structure, "audio/ac3") )
+			}
+		}
+	}
+	else if (gst_structure_has_name (structure, "audio/x-ac3")
+	||       gst_structure_has_name (structure, "audio/ac3"))
+	{
 		return atAC3;
-	else if ( gst_structure_has_name (structure, "audio/x-dts") || gst_structure_has_name (structure, "audio/dts") )
+	}
+	else if (gst_structure_has_name (structure, "audio/x-dts")
+	||       gst_structure_has_name (structure, "audio/dts"))
+	{
 		return atDTS;
-#if GST_VERSION_MAJOR < 1
-	else if ( gst_structure_has_name (structure, "audio/x-raw-int") )
-#else
-	else if ( gst_structure_has_name (structure, "audio/x-raw") )
-#endif
+	}
+	else if (gst_structure_has_name (structure, "audio/x-raw"))
+	{
 		return atPCM;
-
+	}
 	return atUnknown;
 }
 
@@ -2622,15 +3360,20 @@
 		}
 	}
 }
+#endif //ENABLE_GSTREAMER (line 2630 approx.)
 
 eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 void eServiceMP3::gstCBsubtitleAvail(GstElement *subsink, GstBuffer *buffer, gpointer user_data)
 {
 	eServiceMP3 *_this = (eServiceMP3*)user_data;
 	if (_this->m_currentSubtitleStream < 0)
 	{
-		if (buffer) gst_buffer_unref(buffer);
+		if (buffer)
+		{
+			gst_buffer_unref(buffer);
+		}
 		return;
 	}
 	_this->m_pump.send(new GstMessageContainer(2, NULL, NULL, buffer));
@@ -2658,14 +3401,17 @@
 		eDebug("[eServiceMP3] gstTextpadHasCAPS:: signal::caps = %s", gst_caps_to_string(caps));
 //		eDebug("[eServiceMP3] gstGhostpadHasCAPS_synced %p %d", pad, m_subtitleStreams.size());
 
-		if (m_currentSubtitleStream >= 0 && m_currentSubtitleStream < (int)m_subtitleStreams.size())
+		if (m_currentSubtitleStream >= 0
+		&&  m_currentSubtitleStream < (int)m_subtitleStreams.size())
+		{
 			subs = m_subtitleStreams[m_currentSubtitleStream];
-		else {
+		}
+		else
+		{
 			subs.type = stUnknown;
 			subs.pad = pad;
 		}
-
-		if ( subs.type == stUnknown )
+		if (subs.type == stUnknown)
 		{
 			GstTagList *tags = NULL;
 			gchar *g_lang = NULL;
@@ -2673,11 +3419,7 @@
 
 			subs.language_code = "und";
 			subs.type = getSubtitleType(pad);
-#if GST_VERSION_MAJOR < 1
-			if (tags && gst_is_tag_list(tags))
-#else
 			if (tags && GST_IS_TAG_LIST(tags))
-#endif
 			{
 				if (gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang))
 				{
@@ -2686,13 +3428,15 @@
 				}
 				gst_tag_list_free(tags);
 			}
-
 			if (m_currentSubtitleStream >= 0 && m_currentSubtitleStream < (int)m_subtitleStreams.size())
+			{
 				m_subtitleStreams[m_currentSubtitleStream] = subs;
+			}
 			else
+			{
 				m_subtitleStreams.push_back(subs);
-		}
-
+			}
+		}
 //		eDebug("[eServiceMP3] gstGhostpadHasCAPS:: m_gst_prev_subtitle_caps=%s equal=%i",gst_caps_to_string(m_gst_prev_subtitle_caps),gst_caps_is_equal(m_gst_prev_subtitle_caps, caps));
 
 		gst_caps_unref (caps);
@@ -2703,12 +3447,8 @@
 {
 	if (buffer && m_currentSubtitleStream >= 0 && m_currentSubtitleStream < (int)m_subtitleStreams.size())
 	{
-#if GST_VERSION_MAJOR < 1
-		gint64 buf_pos = GST_BUFFER_TIMESTAMP(buffer);
-		size_t len = GST_BUFFER_SIZE(buffer);
-#else
 		GstMapInfo map;
-		if(!gst_buffer_map(buffer, &map, GST_MAP_READ))
+		if (!gst_buffer_map(buffer, &map, GST_MAP_READ))
 		{
 			eLog(3, "[eServiceMP3] pullSubtitle gst_buffer_map failed");
 			return;
@@ -2716,30 +3456,27 @@
 		gint64 buf_pos = GST_BUFFER_PTS(buffer);
 		size_t len = map.size;
 		eLog(6, "[eServiceMP3] gst_buffer_get_size %zu map.size %zu", gst_buffer_get_size(buffer), len);
-#endif
 		gint64 duration_ns = GST_BUFFER_DURATION(buffer);
 		int subType = m_subtitleStreams[m_currentSubtitleStream].type;
 		eLog(6, "[eServiceMP3] pullSubtitle type=%d size=%zu", subType, len);
-		if ( subType )
-		{
-			if ( subType < stVOB )
+		if (subType)
+		{
+			if (subType < stVOB)
 			{
 				int delay = eConfigManager::getConfigIntValue("config.subtitles.pango_subtitles_delay");
 				int subtitle_fps = eConfigManager::getConfigIntValue("config.subtitles.pango_subtitles_fps");
 
 				double convert_fps = 1.0;
 				if (subtitle_fps > 1 && m_framerate > 0)
+				{
 					convert_fps = subtitle_fps / (double)m_framerate;
-
-#if GST_VERSION_MAJOR < 1
-				std::string line((const char*)GST_BUFFER_DATA(buffer), len);
-#else
+				}
 				std::string line((const char*)map.data, len);
-#endif
 				// some media muxers do add an extra new line at the end off a muxed/reencoded srt to ssa codec
 				if (!line.empty() && line[line.length()-1] == '\n')
+				{
 					line.erase(line.length()-1);
-
+				}
 				eLog(6, "[eServiceMP3] got new text subtitle @ buf_pos = %lld ns (in pts=%lld), dur=%lld: '%s' ", buf_pos, buf_pos/11111, duration_ns, line.c_str());
 
 				uint32_t start_ms = ((buf_pos / 1000000ULL) * convert_fps) + (delay / 90);
@@ -2752,14 +3489,33 @@
 				eLog(3, "[eServiceMP3] unsupported subpicture... ignoring");
 			}
 		}
-#if GST_VERSION_MAJOR >= 1
 		gst_buffer_unmap(buffer, &map);
-#endif
-	}
-}
+	}
+}
+#else //eplayer3 code
+void eServiceMP3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceMP3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceMP3::%s <", __func__);
+}
+#endif //ENABLE_GSTREAMER
 
 void eServiceMP3::pushSubtitles()
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	pts_t running_pts = 0;
 	int32_t next_timer = 0, decoder_ms, start_ms, end_ms, diff_start_ms, diff_end_ms;
 	subtitle_pages_map_t::iterator current;
@@ -2767,15 +3523,17 @@
 	// wait until clock is stable
 
 	if (getPlayPosition(running_pts) < 0)
+	{
 		m_decoder_time_valid_state = 0;
-
+	}
 	if (m_decoder_time_valid_state < 4)
 	{
 		m_decoder_time_valid_state++;
 
 		if (m_prev_decoder_time == running_pts)
+		{
 			m_decoder_time_valid_state = 0;
-
+		}
 		if (m_decoder_time_valid_state < 4)
 		{
 			//eDebug("[eServiceMP3] *** push subtitles, waiting for clock to stabilise");
@@ -2783,46 +3541,39 @@
 			next_timer = 50;
 			goto exit;
 		}
-
 		//eDebug("[eServiceMP3] *** push subtitles, clock stable");
 	}
-
 	decoder_ms = running_pts / 90;
-
 #if 0
-		eDebug("[eServiceMP3] *** all subs: ");
-
-		for (current = m_subtitle_pages.begin(); current != m_subtitle_pages.end(); current++)
-		{
-			start_ms = current->second.start_ms;
-			end_ms = current->second.end_ms;
-			diff_start_ms = start_ms - decoder_ms;
-			diff_end_ms = end_ms - decoder_ms;
-
-			eDebug("[eServiceMP3]    start: %d, end: %d, diff_start: %d, diff_end: %d: %s",
-					start_ms, end_ms, diff_start_ms, diff_end_ms, current->second.text.c_str());
-		}
-
-#endif
-
-	for (current = m_subtitle_pages.lower_bound(decoder_ms); current != m_subtitle_pages.end(); current++)
+	eDebug("[eServiceMP3] *** all subs: ");
+
+	for (current = m_subtitle_pages.begin(); current != m_subtitle_pages.end(); current++)
 	{
 		start_ms = current->second.start_ms;
 		end_ms = current->second.end_ms;
 		diff_start_ms = start_ms - decoder_ms;
 		diff_end_ms = end_ms - decoder_ms;
 
+		eDebug("[eServiceMP3]    start: %d, end: %d, diff_start: %d, diff_end: %d: %s",
+					start_ms, end_ms, diff_start_ms, diff_end_ms, current->second.text.c_str());
+	}
+#endif
+	for (current = m_subtitle_pages.lower_bound(decoder_ms); current != m_subtitle_pages.end(); current++)
+	{
+		start_ms = current->second.start_ms;
+		end_ms = current->second.end_ms;
+		diff_start_ms = start_ms - decoder_ms;
+		diff_end_ms = end_ms - decoder_ms;
+
 #if 0
 		eDebug("[eServiceMP3] *** next subtitle: decoder: %d, start: %d, end: %d, duration_ms: %d, diff_start: %d, diff_end: %d : %s",
 			decoder_ms, start_ms, end_ms, end_ms - start_ms, diff_start_ms, diff_end_ms, current->second.text.c_str());
 #endif
-
 		if (diff_end_ms < 0)
 		{
 			//eDebug("[eServiceMP3] *** current sub has already ended, skip: %d", diff_end_ms);
 			continue;
 		}
-
 		if (diff_start_ms > 20)
 		{
 			//eDebug("[eServiceMP3] *** current sub in the future, start timer, %d", diff_start_ms);
@@ -2831,7 +3582,6 @@
 		}
 
 		// showtime
-
 		if (m_subtitle_widget && !m_paused)
 		{
 			//eDebug("[eServiceMP3] *** current sub actual, show!");
@@ -2848,61 +3598,74 @@
 
 		//eDebug("[eServiceMP3] *** no next sub scheduled, check NEXT subtitle");
 	}
-
 	// no more subs in cache, fall through
-
 exit:
 	if (next_timer == 0)
 	{
 		//eDebug("[eServiceMP3] *** next timer = 0, set default timer!");
 		next_timer = 1000;
 	}
-
 	m_subtitle_sync_timer->start(next_timer, true);
-
+#endif
 }
 
 RESULT eServiceMP3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &track)
 {
 	if (m_currentSubtitleStream != track.pid)
 	{
+#if defined ENABLE_MEDIAFWGSTREAMER
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", -1, NULL);
+#endif
 		m_subtitle_sync_timer->stop();
 		m_subtitle_pages.clear();
 		m_prev_decoder_time = -1;
 		m_decoder_time_valid_state = 0;
+#if defined ENABLE_MEDIAFWGSTREAMER
 		m_currentSubtitleStream = track.pid;
 		m_cachedSubtitleStream = m_currentSubtitleStream;
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
-
+#endif
 		m_subtitle_widget = user;
 
+#if defined ENABLE_MEDIAFWGSTREAMER
 		eDebug ("[eServiceMP3] switched to subtitle stream %i", m_currentSubtitleStream);
-
-#ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
-		/*
-		 * when we're running the subsink in sync=false mode,
-		 * we have to force a seek, before the new subtitle stream will start
-		 */
-		seekRelative(-1, 90000);
 #endif
 	}
-
+#if defined ENABLE_MEDIAFWGSTREAMER
+#else //eplayer3 code
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&track.pid);
+	}
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::disableSubtitles()
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	eDebug("[eServiceMP3] disableSubtitles");
 	m_currentSubtitleStream = -1;
 	m_cachedSubtitleStream = m_currentSubtitleStream;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
 	m_subtitle_sync_timer->stop();
 	m_subtitle_pages.clear();
 	m_prev_decoder_time = -1;
 	m_decoder_time_valid_state = 0;
-	if (m_subtitle_widget) m_subtitle_widget->destroy();
+	if (m_subtitle_widget)
+	{
+		m_subtitle_widget->destroy();
+	}
 	m_subtitle_widget = 0;
+#if defined ENABLE_MEDIAFWGSTREAMER
+#else //eplayer3 code
+	int pid = -1;
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+	}
+#endif
 	return 0;
 }
 
@@ -2912,8 +3675,9 @@
 	bool autoturnon = eConfigManager::getConfigBoolValue("config.subtitles.pango_autoturnon", true);
 	int m_subtitleStreams_size = (int)m_subtitleStreams.size();
 	if (!autoturnon)
+	{
 		return -1;
-
+	}
 	if (m_cachedSubtitleStream == -2 && m_subtitleStreams_size)
 	{
 		m_cachedSubtitleStream = 0;
@@ -2921,17 +3685,29 @@
 		std::string configvalue;
 		std::vector<std::string> autosub_languages;
 		configvalue = eConfigManager::getConfigValue("config.autolanguage.subtitle_autoselect1");
-		if (configvalue != "" && configvalue != "None")
+		if (configvalue != ""
+		&&  configvalue != "None")
+		{
 			autosub_languages.push_back(configvalue);
+		}
 		configvalue = eConfigManager::getConfigValue("config.autolanguage.subtitle_autoselect2");
-		if (configvalue != "" && configvalue != "None")
+		if (configvalue != ""
+		&&  configvalue != "None")
+		{
 			autosub_languages.push_back(configvalue);
+		}
 		configvalue = eConfigManager::getConfigValue("config.autolanguage.subtitle_autoselect3");
-		if (configvalue != "" && configvalue != "None")
+		if (configvalue != ""
+		&&  configvalue != "None")
+		{
 			autosub_languages.push_back(configvalue);
+		}
 		configvalue = eConfigManager::getConfigValue("config.autolanguage.subtitle_autoselect4");
-		if (configvalue != "" && configvalue != "None")
+		if (configvalue != ""
+		&&  configvalue != "None")
+		{
 			autosub_languages.push_back(configvalue);
+		}
 		for (int i = 0; i < m_subtitleStreams_size; i++)
 		{
 			if (!m_subtitleStreams[i].language_code.empty())
@@ -2949,7 +3725,6 @@
 			}
 		}
 	}
-
 	if (m_cachedSubtitleStream >= 0 && m_cachedSubtitleStream < m_subtitleStreams_size)
 	{
 		track.type = 2;
@@ -2969,22 +3744,24 @@
 	for (std::vector<subtitleStream>::iterator IterSubtitleStream(m_subtitleStreams.begin()); IterSubtitleStream != m_subtitleStreams.end(); ++IterSubtitleStream)
 	{
 		subtype_t type = IterSubtitleStream->type;
-		switch(type)
-		{
-		case stUnknown:
-		case stVOB:
-		case stPGS:
-			break;
-		default:
-		{
-			struct SubtitleTrack track;
-			track.type = 2;
-			track.pid = stream_idx;
-			track.page_number = int(type);
-			track.magazine_number = 0;
-			track.language_code = IterSubtitleStream->language_code;
-			subtitlelist.push_back(track);
-		}
+		switch (type)
+		{
+			case stUnknown:
+			case stVOB:
+			case stPGS:
+			{
+				break;
+			}
+			default:
+			{
+				struct SubtitleTrack track;
+				track.type = 2;
+				track.pid = stream_idx;
+				track.page_number = int(type);
+				track.magazine_number = 0;
+				track.language_code = IterSubtitleStream->language_code;
+				subtitlelist.push_back(track);
+			}
 		}
 		stream_idx++;
 	}
@@ -3015,20 +3792,21 @@
 		PyList_Append(list, tuple);
 		Py_DECREF(tuple);
 	}
-
 	return list;
 }
 /* cuesheet CVR */
 void eServiceMP3::setCutList(ePyObject list)
 {
 	if (!PyList_Check(list))
+	{
 		return;
+	}
 	int size = PyList_Size(list);
 	int i;
 
 	m_cue_entries.clear();
 
-	for (i=0; i<size; ++i)
+	for (i = 0; i < size; ++i)
 	{
 		ePyObject tuple = PyList_GET_ITEM(list, i);
 		if (!PyTuple_Check(tuple))
@@ -3064,7 +3842,9 @@
 int eServiceMP3::setBufferSize(int size)
 {
 	m_buffer_size = size;
+#if defined ENABLE_MEDIAFWGSTREAMER
 	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
+#endif
 	return 0;
 }
 
@@ -3080,9 +3860,12 @@
 
 void eServiceMP3::setAC3Delay(int delay)
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	ac3_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
+	{
 		return;
+	}
 	else
 	{
 		int config_delay_int = delay;
@@ -3098,7 +3881,7 @@
 		}
 		else
 		{
-			eDebug("[eServiceMP3] dont apply ac3 delay when no video is running!");
+			eDebug("[eServiceMP3] do not apply ac3 delay when no video is running!");
 			config_delay_int = 0;
 		}
 
@@ -3107,17 +3890,20 @@
 			eTSMPEGDecoder::setHwAC3Delay(config_delay_int);
 		}
 	}
+#endif
 }
 
 void eServiceMP3::setPCMDelay(int delay)
 {
+#if defined ENABLE_MEDIAFWGSTREAMER
 	pcm_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
+	{
 		return;
+	}
 	else
 	{
 		int config_delay_int = delay;
-
 		/*
 		 * NOTE: We only look for dvbmediasinks.
 		 * If either the video or audio sink is of a different type,
@@ -3129,7 +3915,7 @@
 		}
 		else
 		{
-			eDebug("[eServiceMP3] dont apply pcm delay when no video is running!");
+			eDebug("[eServiceMP3] do not apply pcm delay when no video is running!");
 			config_delay_int = 0;
 		}
 
@@ -3138,7 +3924,9 @@
 			eTSMPEGDecoder::setHwPCMDelay(config_delay_int);
 		}
 	}
-}
+#endif
+}
+
 /* cuesheet CVR */
 void eServiceMP3::loadCuesheet()
 {
@@ -3155,11 +3943,10 @@
  
 	m_cue_entries.clear();
 	/* only load manual cuts if no chapter info avbl CVR */
-#if GST_VERSION_MAJOR >= 1
 	if (m_use_chapter_entries)
+	{
 		return;
-#endif
-
+	}
 	std::string filename = m_ref.path + ".cuts";
 
 	m_cue_entries.clear();
@@ -3174,50 +3961,53 @@
 			unsigned int what;
 
 			if (!fread(&where, sizeof(where), 1, f))
+			{
 				break;
+			}
 			if (!fread(&what, sizeof(what), 1, f))
+			{
 				break;
-
+			}
 			where = be64toh(where);
 			what = ntohl(what);
 
 			if (what > 3)
+			{
 				break;
-
+			}
 			m_cue_entries.insert(cueEntry(where, what));
 		}
 		fclose(f);
 		eDebug("[eServiceMP3] cuts file has %zd entries", m_cue_entries.size());
-	} else
+	}
+	else
+	{
 		eDebug("[eServiceMP3] cutfile not found!");
-
+	}
 	m_cuesheet_changed = 0;
 	m_event((iPlayableService*)this, evCuesheetChanged);
 }
-/* cuesheet CVR */
+	/* cuesheet CVR */
 void eServiceMP3::saveCuesheet()
 {
 	std::string filename = m_ref.path;
 
-		/* save cuesheet only when main file is accessible. */
-#if GST_VERSION_MAJOR < 1
-	if (::access(filename.c_str(), R_OK) < 0)
+	/* save cuesheet only when main file is accessible. and no TOC chapters avbl*/
+	if ((::access(filename.c_str(), R_OK) < 0) || m_use_chapter_entries)
+	{
 		return;
-#else
-		/* save cuesheet only when main file is accessible. and no TOC chapters avbl*/
-	if ((::access(filename.c_str(), R_OK) < 0) || m_use_chapter_entries)
-		return;
-#endif
+	}
 	filename.append(".cuts");
 	/* do not save to file if there are no cuts */
 	/* remove the cuts file if cue is empty */
-	if(m_cue_entries.begin() == m_cue_entries.end())
+	if (m_cue_entries.begin() == m_cue_entries.end())
 	{
 		if (::access(filename.c_str(), F_OK) == 0)
+		{
 			remove(filename.c_str());
+		}
 		return;
 	}
-
 	FILE *f = fopen(filename.c_str(), "wb");
 
 	if (f)
@@ -3231,7 +4021,6 @@
 			what = htonl(i->what);
 			fwrite(&where, sizeof(where), 1, f);
 			fwrite(&what, sizeof(what), 1, f);
-
 		}
 		fclose(f);
 	}
@@ -3240,5 +4029,18 @@
 
 __attribute__((constructor)) void libraryinit(int argc, char **argv)
 {
-	gst_init(&argc, &argv);
-}
+//	int i, een;
+//	char **twee;
+
+//	een = 1;
+//	twee[0] = "/usr/local/bin/enigma2";
+//	printf ("[eServiceMP3] Initialize gstreamer: Argument count = %d\n", een);
+
+//	for (i = 0; i < een; i++)
+//	{
+//		printf ("[eServiceMP3]                       Argument %2d   = %s\n", i, twee[i]);
+//	}
+//	gst_init(&een, &twee);
+	gst_init(NULL, NULL);
+}
+// vim:ts=4
--- enigma2-servicemp3/servicemp3/servicemp3.h
+++ enigma2-servicemp3/servicemp3/servicemp3.h
@@ -6,7 +6,18 @@
 #include <lib/dvb/pmt.h>
 #include <lib/dvb/subtitle.h>
 #include <lib/dvb/teletext.h>
+#if defined ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
+#else
+#include <common.h>
+#include <subtitle.h>
+#define gint int
+#define gint64 int64_t
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t	ManagerHandler;
+#endif
 /* for subtitles */
 #include <lib/gui/esubtitle.h>
 
@@ -68,7 +79,9 @@
 	DECLARE_REF(eServiceMP3InfoContainer);
 
 	double doubleValue;
+#if defined ENABLE_MEDIAFWGSTREAMER
 	GstBuffer *bufferValue;
+#endif
 
 	unsigned char *bufferData;
 	unsigned int bufferSize;
@@ -83,9 +96,12 @@
 	double getDouble(unsigned int index) const;
 	unsigned char *getBuffer(unsigned int &size) const;
 	void setDouble(double value);
+#if defined ENABLE_MEDIAFWGSTREAMER
 	void setBuffer(GstBuffer *buffer);
-};
-
+#endif
+};
+
+#if defined ENABLE_MEDIAFWGSTREAMER
 class GstMessageContainer: public iObject
 {
 	DECLARE_REF(GstMessageContainer);
@@ -115,6 +131,7 @@
 };
 
 typedef struct _GstElement GstElement;
+#endif
 
 typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
 typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
@@ -181,7 +198,9 @@
 	RESULT getEvent(ePtr<eServiceEvent> &evt, int nownext);
 	int getInfo(int w);
 	std::string getInfoString(int w);
+#if defined ENABLE_MEDIAFWGSTREAMER
 	ePtr<iServiceInfoContainer> getInfoObject(int w);
+#endif
 
 		// iAudioTrackSelection
 	int getNumberOfTracks();
@@ -214,6 +233,8 @@
 	void AmlSwitchAudio(int index);
 	unsigned int get_pts_pcrscr(void);
 #endif
+
+#if defined ENABLE_MEDIAFWGSTREAMER
 	struct audioStream
 	{
 		GstPad* pad;
@@ -247,6 +268,38 @@
 		{
 		}
 	};
+#else
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+#endif
 	struct bufferInfo
 	{
 		gint bufferPercent;
@@ -299,10 +352,15 @@
 	std::vector<audioStream> m_audioStreams;
 	std::vector<subtitleStream> m_subtitleStreams;
 	iSubtitleUser *m_subtitle_widget;
+#if defined ENABLE_MEDIAFWGSTREAMER
 	gdouble m_currentTrickRatio;
+#else
+	int m_currentTrickRatio;
+#endif
 	friend class eServiceFactoryMP3;
 	eServiceReference m_ref;
 	int m_buffer_size;
+#if defined ENABLE_MEDIAFWGSTREAMER
 	int m_ignore_buffering_messages;
 	bool m_is_live;
 	bool m_use_prefillbuffer;
@@ -326,6 +384,8 @@
 		stIdle, stRunning, stStopped,
 	};
 	int m_state;
+#endif
+#if defined ENABLE_MEDIAFWGSTREAMER
 	GstElement *m_gst_playbin, *audioSink, *videoSink;
 	GstTagList *m_stream_tags;
 	bool m_coverart;
@@ -350,6 +410,22 @@
 	static gint match_sinktype(const GValue *velement, const gchar *type);
 #endif
 	static void handleElementAdded(GstBin *bin, GstElement *element, gpointer user_data);
+#else
+	Context_t * player;
+
+	struct Message
+	{
+		Message()
+			:type(-1)
+		{}
+		Message(int type)
+			:type(type)
+		{}
+		int type;
+	};
+	eFixedMessagePump<Message> m_pump;
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+#endif
 
 	struct subtitle_page_t
 	{
@@ -372,18 +448,24 @@
 	int m_decoder_time_valid_state;
 
 	void pushSubtitles();
+#if defined ENABLE_MEDIAFWGSTREAMER
 	void pullSubtitle(GstBuffer *buffer);
+#endif
 	void sourceTimeout();
 	sourceStream m_sourceinfo;
+#if defined ENABLE_MEDIAFWGSTREAMER
 	gulong m_subs_to_pull_handler_id;
+#endif
 
 	RESULT seekToImpl(pts_t to);
 
 	gint m_aspect, m_width, m_height, m_framerate, m_progressive, m_gamma;
 	std::string m_useragent;
+#if defined ENABLE_MEDIAFWGSTREAMER
 	std::string m_extra_headers;
 	RESULT trickSeek(gdouble ratio);
 	ePtr<iTSMPEGDecoder> m_decoder; // for showSinglePic when radio
-};
-
-#endif
+#endif
+};
+
+#endif
--- enigma2-servicemp3/servicemp3/serviceeplayer3.cpp
+++ enigma2-servicemp3/servicemp3/serviceeplayer3.cpp
@@ -0,0 +1,1473 @@
+	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
+	/* it's currently hardcoded to use a big-endian alsasink as sink. */
+#include <lib/base/ebase.h>
+#include <lib/base/eerror.h>
+#include <lib/base/init_num.h>
+#include <lib/base/init.h>
+#include <lib/base/nconfig.h>
+#include <lib/base/object.h>
+#include <lib/dvb/decoder.h>
+#include <lib/components/file_eraser.h>
+#include <lib/gui/esubtitle.h>
+#include <serviceeplayer3.h>
+#include <lib/service/service.h>
+#include <lib/gdi/gpixmap.h>
+
+#include <string>
+#include <sys/stat.h>
+
+#if not defined ENABLE_MEDIAFWGSTREAMER
+#include <player.h>
+#endif 
+
+#define HTTP_TIMEOUT 60
+
+typedef enum
+{
+	GST_PLAY_FLAG_VIDEO         = 0x00000001,
+	GST_PLAY_FLAG_AUDIO         = 0x00000002,
+	GST_PLAY_FLAG_TEXT          = 0x00000004,
+	GST_PLAY_FLAG_VIS           = 0x00000008,
+	GST_PLAY_FLAG_SOFT_VOLUME   = 0x00000010,
+	GST_PLAY_FLAG_NATIVE_AUDIO  = 0x00000020,
+	GST_PLAY_FLAG_NATIVE_VIDEO  = 0x00000040,
+	GST_PLAY_FLAG_DOWNLOAD      = 0x00000080,
+	GST_PLAY_FLAG_BUFFERING     = 0x00000100
+} GstPlayFlags;
+
+// eServiceFactoryEPlayer3
+
+/*
+ * gstreamer suffers from a bug causing sparse streams to loose sync, after pause/resume / skip
+ * see: https://bugzilla.gnome.org/show_bug.cgi?id=619434
+ * As a workaround, we run the subsink in sync=false mode
+ */
+#define GSTREAMER_SUBTITLE_SYNC_MODE_BUG
+/**/
+
+void ep3Blit()
+{
+	fbClass *fb = fbClass::getInstance();
+	fb->blit();
+}
+
+
+eServiceFactoryEPlayer3::eServiceFactoryEPlayer3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+	{
+		std::list<std::string> extensions;
+		extensions.push_back("dts");
+		extensions.push_back("mp2");
+		extensions.push_back("mp3");
+		//extensions.push_back("ogg");
+		//extensions.push_back("ogm");
+		//extensions.push_back("ogv");
+		extensions.push_back("mpg");
+		extensions.push_back("vob");
+		extensions.push_back("wav");
+		extensions.push_back("wave");
+		extensions.push_back("m4v");
+		extensions.push_back("mkv");
+		extensions.push_back("avi");
+		extensions.push_back("divx");
+		extensions.push_back("dat");
+		//extensions.push_back("flac");
+		//extensions.push_back("flv");
+		extensions.push_back("mp4");
+		extensions.push_back("mov");
+		//extensions.push_back("m4a");
+		//extensions.push_back("3gp");
+		//extensions.push_back("3g2");
+		//extensions.push_back("asf");
+#if defined(__sh__)
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		extensions.push_back("wmv");
+#endif
+		//extensions.push_back("wma");
+		sc->addServiceFactory(eServiceFactoryEPlayer3::id, this, extensions);
+	}
+
+	m_service_info = new eStaticServiceEPlayer3Info();
+}
+
+eServiceFactoryEPlayer3::~eServiceFactoryEPlayer3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+	{
+		sc->removeServiceFactory(eServiceFactoryEPlayer3::id);
+	}
+}
+
+DEFINE_REF(eServiceFactoryEPlayer3)
+
+	// iServiceHandler
+RESULT eServiceFactoryEPlayer3::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
+{
+	// check resources...
+	ptr = new eServiceEPlayer3(ref);
+	return 0;
+}
+
+RESULT eServiceFactoryEPlayer3::record(const eServiceReference &ref, ePtr<iRecordableService> &ptr)
+{
+	ptr = 0;
+	return -1;
+}
+
+RESULT eServiceFactoryEPlayer3::list(const eServiceReference &, ePtr<iListableService> &ptr)
+{
+	ptr = 0;
+	return -1;
+}
+
+RESULT eServiceFactoryEPlayer3::info(const eServiceReference &ref, ePtr<iStaticServiceInformation> &ptr)
+{
+	ptr = m_service_info;
+	return 0;
+}
+
+class eEPlayer3ServiceOfflineOperations: public iServiceOfflineOperations
+{
+	DECLARE_REF(eEPlayer3ServiceOfflineOperations);
+	eServiceReference m_ref;
+public:
+	eEPlayer3ServiceOfflineOperations(const eServiceReference &ref);
+
+	RESULT deleteFromDisk(int simulate);
+	RESULT getListOfFilenames(std::list<std::string> &);
+	RESULT reindex();
+};
+
+DEFINE_REF(eEPlayer3ServiceOfflineOperations);
+
+eEPlayer3ServiceOfflineOperations::eEPlayer3ServiceOfflineOperations(const eServiceReference &ref): m_ref((const eServiceReference&)ref)
+{
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::deleteFromDisk(int simulate)
+{
+	if (!simulate)
+	{
+		std::list<std::string> res;
+		if (getListOfFilenames(res))
+		{
+			return -1;
+		}
+		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
+		if (!eraser)
+		{
+			eDebug("FATAL !! cannoy get background file eraser");
+		}
+		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
+		{
+			eDebug("Removing %s...", i->c_str());
+			if (eraser)
+			{
+				eraser->erase(i->c_str());
+			}
+			else
+			{
+				::unlink(i->c_str());
+			}
+		}
+	}
+	return 0;
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::getListOfFilenames(std::list<std::string> &res)
+{
+	res.clear();
+	res.push_back(m_ref.path);
+	return 0;
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::reindex()
+{
+	return -1;
+}
+
+
+RESULT eServiceFactoryEPlayer3::offlineOperations(const eServiceReference &ref, ePtr<iServiceOfflineOperations> &ptr)
+{
+	ptr = new eEPlayer3ServiceOfflineOperations(ref);
+	return 0;
+}
+
+// eStaticServiceEPlayer3Info
+
+
+// eStaticServiceEPlayer3Info is seperated from eServiceEPlayer3 to give information
+// about unopened files.
+
+// probably eServiceEPlayer3 should use this class as well, and eStaticServiceEPlayer3Info
+// should have a database backend where ID3-files etc. are cached.
+// this would allow listing the mp3 database based on certain filters.
+
+DEFINE_REF(eStaticServiceEPlayer3Info)
+
+eStaticServiceEPlayer3Info::eStaticServiceEPlayer3Info()
+{
+}
+
+RESULT eStaticServiceEPlayer3Info::getName(const eServiceReference &ref, std::string &name)
+{
+	if ( ref.name.length() )
+		name = ref.name;
+	else
+	{
+		size_t last = ref.path.rfind('/');
+		if (last != std::string::npos)
+		{
+			name = ref.path.substr(last+1);
+		}
+		else
+		{
+			name = ref.path;
+		}
+	}
+	return 0;
+}
+
+int eStaticServiceEPlayer3Info::getLength(const eServiceReference &ref)
+{
+	return -1;
+}
+
+int eStaticServiceEPlayer3Info::getInfo(const eServiceReference &ref, int w)
+{
+	switch (w)
+	{
+		case iServiceInformation::sTimeCreate:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_mtime;
+			}
+		}
+		break;
+		case iServiceInformation::sFileSize:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_size;
+			}
+		}
+		break;
+	}
+	return iServiceInformation::resNA;
+}
+
+long long eStaticServiceEPlayer3Info::getFileSize(const eServiceReference &ref)
+{
+	struct stat s;
+	if (stat(ref.path.c_str(), &s) == 0)
+	{
+		return s.st_size;
+	}
+	return 0;
+}
+
+DEFINE_REF(eStreamBufferEPlayer3Info)
+
+eStreamBufferEPlayer3Info::eStreamBufferEPlayer3Info(int percentage, int inputrate, int outputrate, int space, int size)
+: bufferPercentage(percentage),
+	inputRate(inputrate),
+	outputRate(outputrate),
+	bufferSpace(space),
+	bufferSize(size)
+{
+}
+
+int eStreamBufferEPlayer3Info::getBufferPercentage() const
+{
+	return bufferPercentage;
+}
+
+int eStreamBufferEPlayer3Info::getAverageInputRate() const
+{
+	return inputRate;
+}
+
+int eStreamBufferEPlayer3Info::getAverageOutputRate() const
+{
+	return outputRate;
+}
+
+int eStreamBufferEPlayer3Info::getBufferSpace() const
+{
+	return bufferSpace;
+}
+
+int eStreamBufferEPlayer3Info::getBufferSize() const
+{
+	return bufferSize;
+}
+
+// eServiceEPlayer3
+int eServiceEPlayer3::ac3_delay = 0,
+    eServiceEPlayer3::pcm_delay = 0;
+
+eServiceEPlayer3::eServiceEPlayer3(eServiceReference ref)
+	:m_ref(ref), m_pump(eApp, 1)
+{
+	m_subtitle_sync_timer = eTimer::create(eApp);
+	m_streamingsrc_timeout = 0;
+
+	m_currentAudioStream = -1;
+	m_currentSubtitleStream = -1;
+	m_cachedSubtitleStream = 0; /* report the first subtitle stream to be 'cached'. TODO: use an actual cache. */
+	m_subtitle_widget = 0;
+	m_currentTrickRatio = 1.0;
+	m_buffer_size = 8 * 1024 * 1024;
+
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	m_errorInfo.missing_codec = "";
+
+
+	CONNECT(m_subtitle_sync_timer->timeout, eServiceEPlayer3::pushSubtitles);
+
+	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
+
+	m_state = stIdle;
+	eDebug("eServiceEPlayer3::construct!");
+
+	const char *filename = m_ref.path.c_str();
+	const char *ext = strrchr(filename, '.');
+	if (!ext)
+	{
+		ext = filename + strlen(filename);
+	}
+#if defined ENABLE_MEDIAFWGSTREAMER
+	player = (Context_t*) malloc(sizeof(Context_t));
+
+	if (player)
+	{
+		player->playback  = &PlaybackHandler;
+		player->output    = &OutputHandler;
+		player->container = &ContainerHandler;
+		player->manager   = &ManagerHandler;
+		printf("%s\n", player->output->Name);
+	}
+
+	//Registration of output devices
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+		player->output->Command(player,OUTPUT_ADD, (void*)"video");
+		player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+	}
+#else
+	player = new Player();
+#endif
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->output && player->output->subtitle)
+	{
+		fbClass *fb = fbClass::getInstance();
+		SubtitleOutputDef_t out;
+		out.screen_width = fb->getScreenResX();
+		out.screen_height = fb->getScreenResY();
+		out.shareFramebuffer = 1;
+		out.framebufferFD = fb->getFD();
+		out.destination = fb->getLFB_Direct();
+		out.destStride = fb->Stride();
+		out.framebufferBlit = ep3Blit;
+		player->output->subtitle->Command(player, (OutputCmd_t)OUTPUT_SET_SUBTITLE_OUTPUT, (void*) &out);
+	}
+#endif
+
+	//create playback path
+	char file[800] = {""};
+
+	if (!strncmp("http://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else if (!strncmp("rtsp://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else if (!strncmp("rtmp://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else if (!strncmp("rtmpe://", m_ref.path.c_str(), 8))
+	{
+		;
+	}
+	else if (!strncmp("rtmpt://", m_ref.path.c_str(), 8))
+	{
+		;
+	}
+	else if (!strncmp("rtmps://", m_ref.path.c_str(), 8))
+	{
+		;
+	}
+	else if (!strncmp("rtmpte://", m_ref.path.c_str(), 9))
+	{
+		;
+	}
+	else if (!strncmp("rtp://", m_ref.path.c_str(), 6))
+	{
+		;
+	}
+	else if (!strncmp("upnp://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else if (!strncmp("mms://", m_ref.path.c_str(), 6))
+	{
+		;
+	}
+	else if (!strncmp("file://", m_ref.path.c_str(), 7))
+	{
+		;
+	}
+	else
+	{
+		strcat(file, "file://");
+	}
+	strcat(file, m_ref.path.c_str());
+
+	//try to open file
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0)
+#else
+	if (player->Open(file))
+#endif
+	{
+		//VIDEO
+		//We do not have to register video tracks, or do we ?
+		//AUDIO
+#if defined ENABLE_MEDIAFWGSTREAMER
+		if (player && player->manager && player->manager->audio)
+		{
+			char ** TrackList = NULL;
+			player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+
+			if (TrackList != NULL)
+			{
+				printf("AudioTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					audioStream audio;
+					audio.language_code = TrackList[i];
+
+					// atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+					if (    !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+					{
+						audio.type = atMP3;
+					}
+					else if (!strncmp("A_MP3",      TrackList[i+1], 5))
+					{
+						audio.type = atMP3;
+					}
+					else if (!strncmp("A_AC3",      TrackList[i+1], 5))
+					{
+						audio.type = atAC3;
+					}
+					else if (!strncmp("A_DTS",      TrackList[i+1], 5))
+					{
+						audio.type = atDTS;
+					}
+					else if (!strncmp("A_AAC",      TrackList[i+1], 5))
+					{
+						audio.type = atAAC;
+					}
+					else if (!strncmp("A_PCM",      TrackList[i+1], 5))
+					{
+						audio.type = atPCM;
+					}
+					else if (!strncmp("A_VORBIS",   TrackList[i+1], 8))
+					{
+						audio.type = atOGG;
+					}
+					else if (!strncmp("A_FLAC",     TrackList[i+1], 6))
+					{
+						audio.type = atFLAC;
+					}
+					else
+					{
+						audio.type = atUnknown;
+					}
+					m_audioStreams.push_back(audio);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		//SUB
+		if (player && player->manager && player->manager->subtitle)
+		{
+			char ** TrackList = NULL;
+			player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("SubtitleTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					subtitleStream sub;
+					sub.language_code = TrackList[i];
+					//  stPlainText, stSSA, stSRT
+					if (    !strncmp("S_TEXT/SSA",   TrackList[i+1], 10)
+					||      !strncmp("S_SSA", TrackList[i+1], 5))
+					{
+						sub.type = stSSA;
+					}
+					else if (!strncmp("S_TEXT/ASS",   TrackList[i+1], 10)
+					     ||  !strncmp("S_AAS", TrackList[i+1], 5))
+					{
+						sub.type = stSSA;
+					}
+					else if (!strncmp("S_TEXT/SRT",   TrackList[i+1], 10)
+					     ||  !strncmp("S_SRT", TrackList[i+1], 5))
+					{
+						sub.type = stSRT;
+					}
+					else
+					{
+						sub.type = stPlainText;
+					}
+					m_subtitleStreams.push_back(sub);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+#else
+		if (player)
+		{
+			std::vector<Track> tracks = player->manager.getAudioTracks();
+		}
+		m_state = stRunning;
+#endif
+		m_event(this, evStart);
+	}
+	else
+	{
+		//Creation failed, no playback support for insert file, so delete playback context
+		//FIXME: How to tell e2 that we failed?
+#if defined ENABLE_MEDIAFWGSTREAMER
+		if (player && player->output)
+		{
+			player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+			player->output->Command(player,OUTPUT_DEL, (void*)"video");
+			player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+		}
+
+		if (player && player->playback)
+		{
+			player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+		}
+		if (player)
+		{
+			free(player);
+		}
+		player = NULL;
+#else
+		player->Stop();
+		player->output.Close();
+		player->Close();
+#endif
+	}
+	//m_state = stRunning;
+	eDebug("eServiceEPlayer3-<\n");
+}
+
+eServiceEPlayer3::~eServiceEPlayer3()
+{
+	if (m_subtitle_widget)
+	{
+		m_subtitle_widget->destroy();
+	}
+	m_subtitle_widget = 0;
+
+	if (m_state == stRunning)
+	{
+		stop();
+	}
+#if not defined ENABLE_MEDIAFWGSTREAMER
+	delete player;
+#endif
+}
+
+DEFINE_REF(eServiceEPlayer3);
+
+RESULT eServiceEPlayer3::connectEvent(const sigc::slot2<void, iPlayableService*, int> &event, ePtr<eConnection> &connection)
+{
+	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+	m_event(this, evSeekableStatusChanged);
+	return 0;
+}
+
+RESULT eServiceEPlayer3::start()
+{
+	if (m_state != stIdle)
+	{
+		eDebug("eServiceEPlayer3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+	m_state = stRunning;
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->output && player->playback)
+	{
+		player->output->Command(player, OUTPUT_OPEN, NULL);
+		player->playback->Command(player, PLAYBACK_PLAY, NULL);
+	}
+#else
+	if (player)
+	{
+		player->output.Open();
+		player->Play();
+ 	}
+#endif
+	m_event(this, evStart);
+	return 0;
+}
+
+void eServiceEPlayer3::sourceTimeout()
+{
+	eDebug("eServiceEPlayer3::http source timeout! issuing eof...");
+	m_event((iPlayableService*)this, evEOF);
+}
+
+RESULT eServiceEPlayer3::stop()
+{
+	if (m_state == stIdle)
+	{
+		eDebug("eServiceEPlayer3::%s < m_state == stIdle", __func__);
+		return -1;
+	}
+
+	if (m_state == stStopped)
+	{
+		return -1;
+	}
+	eDebug("eServiceEPlayer3::stop %s", m_ref.path.c_str());
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && player->output)
+	{
+		player->playback->Command(player, PLAYBACK_STOP, NULL);
+		player->output->Command(player, OUTPUT_CLOSE, NULL);
+	}
+
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+		player->output->Command(player,OUTPUT_DEL, (void*)"video");
+		player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+	}
+
+	if (player && player->playback)
+	{
+		player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+	}
+	if (player)
+	{
+		free(player);
+	}
+	if (player != NULL)
+	{
+		player = NULL;
+	}
+#else
+	if (player)
+	{
+		player->Stop();
+		player->output.Close();
+		player->Close();
+	}
+#endif
+	m_state = stStopped;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setTarget(int target, bool noaudio)
+{
+	return -1;
+}
+
+RESULT eServiceEPlayer3::pause(ePtr<iPauseableService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+		{
+			return speed_mapping[i+1];
+		}
+		i += 2;
+	}
+	return -1;
+}
+
+RESULT eServiceEPlayer3::setSlowMotion(int ratio)
+{
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && (speed != -1))
+#else
+	if (player && (speed != -1))
+#endif
+	{
+		int result = 0;
+		if (ratio > 1)
+		{
+#if defined ENABLE_MEDIAFWGSTREAMER
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+#else
+			result = player->SlowMotion(speed);
+#endif
+		}
+		if (result != 0)
+		{
+			return -1;
+		}
+	}
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setFastForward(int ratio)
+{
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && (speed != -1))
+#else
+	if (player && (speed != -1))
+#endif
+	{
+		int result = 0;
+		if (ratio > 1)
+		{
+#if defined ENABLE_MEDIAFWGSTREAMER
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+#else
+			result = player->FastForward(speed);
+#endif
+		}
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+#if defined ENABLE_MEDIAFWGSTREAMER
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+#else
+			result = player->FastBackward(speed);
+#endif
+		}
+		else
+		{
+#if defined ENABLE_MEDIAFWGSTREAMER
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#else
+			result = player->Continue();
+#endif
+		}
+		if (result != 0)
+		{
+			return -1;
+		}
+	}
+	return 0;
+}
+
+		// iPausableService
+RESULT eServiceEPlayer3::pause()
+{
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+	}
+#else
+	if (player)
+	{
+		player->Pause();
+	}
+#endif
+	return 0;
+}
+
+RESULT eServiceEPlayer3::unpause()
+{
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+	}
+#else
+	if (player)
+	{
+		player->Continue();
+	}
+#endif
+	return 0;
+}
+
+	/* iSeekableService */
+RESULT eServiceEPlayer3::seek(ePtr<iSeekableService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getLength(pts_t &pts)
+{
+#if defined ENABLE_MEDIAFWGSTREAMER
+	double length = 0;
+
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+	}
+#else
+	int64_t length = 0;
+
+	if (player)
+	{
+		player->GetDuration(length);
+	}
+#endif
+
+	if (length <= 0)
+	{
+		return -1;
+	}
+	pts = length * 90000;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::seekToImpl(pts_t to)
+{
+	return 0;
+}
+
+RESULT eServiceEPlayer3::seekTo(pts_t to)
+{
+	RESULT ret = -1;
+
+	float pos = (to/90000.0)-10;
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+	}
+#else
+	if (player)
+	{
+		player->Seek(pos,true);
+	}
+#endif
+	ret = 0;
+	return ret;
+}
+
+RESULT eServiceEPlayer3::seekRelative(int direction, pts_t to)
+{
+	pts_t ppos;
+
+	if (getPlayPosition(ppos) < 0)
+	{
+		return -1;
+	}
+	ppos += to * direction;
+	if (ppos < 0)
+	{
+		ppos = 0;
+	}
+	float pos = direction*(to/90000.0);
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+	}
+#else
+	if (player)
+	{
+		player->Seek(pos,true);
+	}
+#endif
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getPlayPosition(pts_t &pts)
+{
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback && !player->playback->isPlaying)
+#else
+	if (player && !player->isPlaying)
+#endif
+	{
+		eDebug("eServiceEPlayer3::%s !!!!EOF!!!! < -1", __func__);
+		if (m_state == stRunning)
+		{
+			m_event((iPlayableService*)this, evEOF);
+		}
+		pts = 0;
+		return -1;
+	}
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+	}
+	if (vpts<=0)
+	{
+		return -1;
+	}
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = (vpts > 0 ? vpts : pts);
+#else
+	if (player)
+	{
+		player->GetPts((int64_t &) pts);
+	}
+#endif
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setTrickmode(int trick)
+{
+		/* trickmode is not yet supported by our dvbmediasinks. */
+	return -1;
+}
+
+RESULT eServiceEPlayer3::isCurrentlySeekable()
+{
+	return 3;
+}
+
+RESULT eServiceEPlayer3::info(ePtr<iServiceInformation>&i)
+{
+	i = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getName(std::string &name)
+{
+	std::string title = m_ref.getName();
+	if (title.empty())
+	{
+		name = m_ref.path;
+		size_t n = name.rfind('/');
+		if (n != std::string::npos)
+		{
+			name = name.substr(n + 1);
+		}
+	}
+	else
+	{
+		name = title;
+	}
+	return 0;
+}
+
+int eServiceEPlayer3::getInfo(int w)
+{
+	switch (w)
+	{
+		case sServiceref: return m_ref;
+		case sVideoHeight: return m_height;
+		case sVideoWidth: return m_width;
+		case sFrameRate: return m_framerate;
+		case sProgressive: return m_progressive;
+		case sAspect: return m_aspect;
+		case sTagTitle:
+		case sTagArtist:
+		case sTagAlbum:
+		case sTagTitleSortname:
+		case sTagArtistSortname:
+		case sTagAlbumSortname:
+		case sTagDate:
+		case sTagComposer:
+		case sTagGenre:
+		case sTagComment:
+		case sTagExtendedComment:
+		case sTagLocation:
+		case sTagHomepage:
+		case sTagDescription:
+		case sTagVersion:
+		case sTagISRC:
+		case sTagOrganization:
+		case sTagCopyright:
+		case sTagCopyrightURI:
+		case sTagContact:
+		case sTagLicense:
+		case sTagLicenseURI:
+		case sTagCodec:
+		case sTagAudioCodec:
+		case sTagVideoCodec:
+		case sTagEncoder:
+		case sTagLanguageCode:
+		case sTagKeywords:
+		case sTagChannelMode:
+		case sUser + 12:
+#if not defined(__sh__)
+		{
+			return resIsString;
+		}
+#endif
+		case sTagTrackGain:
+		case sTagTrackPeak:
+		case sTagAlbumGain:
+		case sTagAlbumPeak:
+		case sTagReferenceLevel:
+		case sTagBeatsPerMinute:
+		case sTagImage:
+		case sTagPreviewImage:
+		case sTagAttachment:
+		{
+			return resIsPyObject;
+		}
+		default:
+		{
+			return resNA;
+		}
+	}
+	return 0;
+}
+
+std::string eServiceEPlayer3::getInfoString(int w)
+{
+	char *tag = NULL;
+#if defined ENABLE_MEDIAFWGSTREAMER
+	char *res_str = NULL;
+#else
+	std::vector<std::string> keys, values;
+	std::string res = "";
+#endif
+	switch (w)
+	{
+		case sTagTitle:
+		{
+			tag = strdup("Title");
+			break;
+		}
+		case sTagArtist:
+		{
+			tag = strdup("Artist");
+			break;
+		}
+		case sTagAlbum:
+		{
+			tag = strdup("Album");
+			break;
+		}
+		case sTagComment:
+		{
+			tag = strdup("Comment");
+			break;
+		}
+		case sTagTrackNumber:
+		{
+			tag = strdup("Track");
+			break;
+		}
+		case sTagGenre:
+		{
+			tag = strdup("Genre");
+			break;
+		}
+		case sTagDate:
+		{
+			tag = strdup("Year");
+			break;
+		}
+		case sTagVideoCodec:
+		{
+			tag = strdup("VideoType");
+			break;
+		}
+		case sTagAudioCodec:
+		{
+			tag = strdup("AudioType");
+			break;
+		}
+		default:
+		{
+			return "";
+		}
+	}
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+#else
+	if (player)
+	{
+		player->input.GetMetadata(keys, values);
+	}
+	for (int i = 0; i < keys.size(); i++)
+	{
+		if (tag == keys[i])
+		{
+			res = values[i];
+		}
+	}	
+#endif
+	free(tag);
+#if defined ENABLE_MEDIAFWGSTREAMER
+	return "";
+#else
+	return res;
+#endif
+}
+
+RESULT eServiceEPlayer3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::audioTracks(ePtr<iAudioTrackSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::subtitle(ePtr<iSubtitleOutput> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::audioDelay(ePtr<iAudioDelay> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+int eServiceEPlayer3::getNumberOfTracks()
+{
+ 	return m_audioStreams.size();
+}
+
+int eServiceEPlayer3::getCurrentTrack()
+{
+	return m_currentAudioStream;
+}
+
+RESULT eServiceEPlayer3::selectTrack(unsigned int i)
+{
+	int ret = selectAudioStream(i);
+
+	return ret;
+}
+
+int eServiceEPlayer3::selectAudioStream(int i)
+{
+	if (i != m_currentAudioStream)
+	{
+#if defined ENABLE_MEDIAFWGSTREAMER
+		if (player && player->playback)
+		{
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		}
+#else
+		if (player)
+		{
+			player->SwitchAudio(i);
+		}
+#endif
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+}
+
+int eServiceEPlayer3::getCurrentChannel()
+{
+	return STEREO;
+}
+
+RESULT eServiceEPlayer3::selectChannel(int i)
+{
+	eDebug("eServiceEPlayer3::selectChannel(%i)",i);
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
+{
+ 	if (i >= m_audioStreams.size())
+	{
+		return -2;
+	}
+	if (m_audioStreams[i].type == atMPEG)
+	{
+		info.m_description = "MPEG";
+	}
+	else if (m_audioStreams[i].type == atMP3)
+	{
+		info.m_description = "MP3";
+	}
+	else if (m_audioStreams[i].type == atAC3)
+	{
+		info.m_description = "AC3";
+	}
+	else if (m_audioStreams[i].type == atAAC)
+	{
+		info.m_description = "AAC";
+	}
+	else if (m_audioStreams[i].type == atDTS)
+	{
+		info.m_description = "DTS";
+	}
+	else if (m_audioStreams[i].type == atPCM)
+	{
+		info.m_description = "PCM";
+	}
+	else if (m_audioStreams[i].type == atOGG)
+	{
+		info.m_description = "OGG";
+	}
+	if (info.m_language.empty())
+	{
+		info.m_language = m_audioStreams[i].language_code;
+	}
+	return 0;
+}
+
+eAutoInitPtr<eServiceFactoryEPlayer3> init_eServiceFactoryEPlayer3(eAutoInitNumbers::service+1, "eServiceFactoryEPlayer3");
+
+void eServiceEPlayer3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceEPlayer3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceEPlayer3 *_this = (eServiceEPlayer3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceEPlayer3::%s <", __func__);
+}
+
+void eServiceEPlayer3::pushSubtitles()
+{
+}
+
+RESULT eServiceEPlayer3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &track)
+{
+	if (m_currentSubtitleStream != track.pid)
+	{
+		m_subtitle_sync_timer->stop();
+		m_subtitle_pages.clear();
+		m_prev_decoder_time = -1;
+		m_decoder_time_valid_state = 0;
+
+		m_subtitle_widget = user;
+
+	}
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&track.pid);
+	}
+#else
+	if (player)
+	{
+		player->SwitchSubtitle(track.pid);
+	}
+#endif
+	return 0;
+}
+
+RESULT eServiceEPlayer3::disableSubtitles()
+{
+	eDebug("eServiceEPlayer3::disableSubtitles");
+
+	m_subtitle_sync_timer->stop();
+	m_subtitle_pages.clear();
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	if (m_subtitle_widget)
+	{
+		m_subtitle_widget->destroy();
+	}
+	m_subtitle_widget = 0;
+
+	int pid = -1;
+#if defined ENABLE_MEDIAFWGSTREAMER
+	if (player && player->playback)
+	{
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+	}
+#else
+	if (player)
+	{
+		player->SwitchSubtitle(pid);
+	}
+#endif
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getCachedSubtitle(struct SubtitleTrack &track)
+{
+
+	bool autoturnon = eConfigManager::getConfigBoolValue("config.subtitles.pango_autoturnon", true);
+	if (!autoturnon)
+	{
+		return -1;
+	}
+	if (m_cachedSubtitleStream >= 0 && m_cachedSubtitleStream < (int)m_subtitleStreams.size())
+	{
+		track.type = 2;
+		track.pid = m_cachedSubtitleStream;
+		track.page_number = int(m_subtitleStreams[m_cachedSubtitleStream].type);
+		track.magazine_number = 0;
+		return 0;
+	}
+	return -1;
+}
+
+RESULT eServiceEPlayer3::getSubtitleList(std::vector<struct SubtitleTrack> &subtitlelist)
+{
+// 	eDebug("eServiceEPlayer3::getSubtitleList");
+	int stream_idx = 0;
+
+	for (std::vector<subtitleStream>::iterator IterSubtitleStream(m_subtitleStreams.begin()); IterSubtitleStream != m_subtitleStreams.end(); ++IterSubtitleStream)
+	{
+		subtype_t type = IterSubtitleStream->type;
+		switch(type)
+		{
+			case stUnknown:
+			case stVOB:
+			case stPGS:
+			{
+				break;
+			}
+			default:
+			{
+				struct SubtitleTrack track;
+				track.type = 2;
+				track.pid = stream_idx;
+				track.page_number = int(type);
+				track.magazine_number = 0;
+				track.language_code = IterSubtitleStream->language_code;
+				subtitlelist.push_back(track);
+			}
+		}
+		stream_idx++;
+	}
+	eDebug("eServiceEPlayer3::getSubtitleList finished");
+	return 0;
+}
+
+RESULT eServiceEPlayer3::streamed(ePtr<iStreamedService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+ePtr<iStreamBufferInfo> eServiceEPlayer3::getBufferCharge()
+{
+	return new eStreamBufferEPlayer3Info(m_bufferInfo.bufferPercent, m_bufferInfo.avgInRate, m_bufferInfo.avgOutRate, m_bufferInfo.bufferingLeft, m_buffer_size);
+}
+
+int eServiceEPlayer3::setBufferSize(int size)
+{
+	m_buffer_size = size;
+	return 0;
+}
+
+int eServiceEPlayer3::getAC3Delay()
+{
+	return ac3_delay;
+}
+
+int eServiceEPlayer3::getPCMDelay()
+{
+	return pcm_delay;
+}
+
+void eServiceEPlayer3::setAC3Delay(int delay)
+{
+
+}
+
+void eServiceEPlayer3::setPCMDelay(int delay)
+{
+}
--- enigma2-servicemp3/servicemp3/serviceeplayer3.h
+++ enigma2-servicemp3/servicemp3/serviceeplayer3.h
@@ -0,0 +1,314 @@
+#ifndef __serviceeplayer3_h
+#define __serviceeplayer3_h
+
+#include <lib/base/message.h>
+#include <lib/service/iservice.h>
+#include <lib/dvb/pmt.h>
+#include <lib/dvb/subtitle.h>
+#include <lib/dvb/teletext.h>
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+#include <common.h>
+#include <subtitle.h>
+#endif
+#define gint int
+#define gint64 int64_t
+#if defined ENABLE_MEDIAFWGSTREAMER
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t	ManagerHandler;
+#endif
+
+/* for subtitles */
+#include <lib/gui/esubtitle.h>
+
+#if not defined ENABLE_MEDIAFWGSTREAMER
+class Player;
+#endif
+class eStaticServiceEPlayer3Info;
+
+class eServiceFactoryEPlayer3: public iServiceHandler
+{
+	DECLARE_REF(eServiceFactoryEPlayer3);
+public:
+	eServiceFactoryEPlayer3();
+	virtual ~eServiceFactoryEPlayer3();
+	enum { id = 0x1003 };
+
+		// iServiceHandler
+	RESULT play(const eServiceReference &, ePtr<iPlayableService> &ptr);
+	RESULT record(const eServiceReference &, ePtr<iRecordableService> &ptr);
+	RESULT list(const eServiceReference &, ePtr<iListableService> &ptr);
+	RESULT info(const eServiceReference &, ePtr<iStaticServiceInformation> &ptr);
+	RESULT offlineOperations(const eServiceReference &, ePtr<iServiceOfflineOperations> &ptr);
+private:
+	ePtr<eStaticServiceEPlayer3Info> m_service_info;
+};
+
+class eStaticServiceEPlayer3Info: public iStaticServiceInformation
+{
+	DECLARE_REF(eStaticServiceEPlayer3Info);
+	friend class eServiceFactoryEPlayer3;
+	eStaticServiceEPlayer3Info();
+public:
+	RESULT getName(const eServiceReference &ref, std::string &name);
+	int getLength(const eServiceReference &ref);
+	int getInfo(const eServiceReference &ref, int w);
+	int isPlayable(const eServiceReference &ref, const eServiceReference &ignore, bool simulate) { return 1; }
+	long long getFileSize(const eServiceReference &ref);
+};
+
+class eStreamBufferEPlayer3Info: public iStreamBufferInfo
+{
+	DECLARE_REF(eStreamBufferEPlayer3Info);
+	int bufferPercentage;
+	int inputRate;
+	int outputRate;
+	int bufferSpace;
+	int bufferSize;
+
+public:
+	eStreamBufferEPlayer3Info(int percentage, int inputrate, int outputrate, int space, int size);
+
+	int getBufferPercentage() const;
+	int getAverageInputRate() const;
+	int getAverageOutputRate() const;
+	int getBufferSpace() const;
+	int getBufferSize() const;
+};
+
+class eServiceEPlayer3InfoContainer: public iServiceInfoContainer
+{
+	DECLARE_REF(eServiceEPlayer3InfoContainer);
+
+	double doubleValue;
+
+
+	unsigned char *bufferData;
+	unsigned int bufferSize;
+
+public:
+	eServiceEPlayer3InfoContainer();
+	~eServiceEPlayer3InfoContainer();
+
+	double getDouble(unsigned int index) const;
+	unsigned char *getBuffer(unsigned int &size) const;
+
+	void setDouble(double value);
+};
+
+typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
+typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
+typedef enum { ctNone, ctMPEGTS, ctMPEGPS, ctMKV, ctAVI, ctMP4, ctVCD, ctCDA, ctASF, ctOGG } containertype_t;
+
+class eServiceEPlayer3: public iPlayableService, public iPauseableService,
+	public iServiceInformation, public iSeekableService, public iAudioTrackSelection, public iAudioChannelSelection, 
+	public iSubtitleOutput, public iStreamedService, public iAudioDelay, public sigc::trackable
+{
+	DECLARE_REF(eServiceEPlayer3);
+public:
+	virtual ~eServiceEPlayer3();
+
+		// iPlayableService
+	RESULT connectEvent(const sigc::slot2<void, iPlayableService*, int> &event, ePtr<eConnection> &connection);
+	RESULT start();
+	RESULT stop();
+	RESULT setTarget(int target, bool noaudio);
+	
+	RESULT pause(ePtr<iPauseableService> &ptr);
+	RESULT setSlowMotion(int ratio);
+	RESULT setFastForward(int ratio);
+
+	RESULT seek(ePtr<iSeekableService> &ptr);
+	RESULT audioTracks(ePtr<iAudioTrackSelection> &ptr);
+	RESULT audioChannel(ePtr<iAudioChannelSelection> &ptr);
+	RESULT subtitle(ePtr<iSubtitleOutput> &ptr);
+	RESULT audioDelay(ePtr<iAudioDelay> &ptr);
+	void setQpipMode(bool value, bool audio) { }
+
+		// not implemented (yet)
+	RESULT frontendInfo(ePtr<iFrontendInformation> &ptr) { ptr = 0; return -1; }
+	RESULT subServices(ePtr<iSubserviceList> &ptr) { ptr = 0; return -1; }
+	RESULT timeshift(ePtr<iTimeshiftService> &ptr) { ptr = 0; return -1; }
+	RESULT cueSheet(ePtr<iCueSheet> &ptr) { ptr = 0; return -1; }
+
+	RESULT rdsDecoder(ePtr<iRdsDecoder> &ptr) { ptr = 0; return -1; }
+	RESULT keys(ePtr<iServiceKeys> &ptr) { ptr = 0; return -1; }
+	RESULT stream(ePtr<iStreamableService> &ptr) { ptr = 0; return -1; }
+
+		// iPausableService
+	RESULT pause();
+	RESULT unpause();
+	
+	RESULT info(ePtr<iServiceInformation>&);
+	
+		// iSeekableService
+	RESULT getLength(pts_t &SWIG_OUTPUT);
+	RESULT seekTo(pts_t to);
+	RESULT seekRelative(int direction, pts_t to);
+	RESULT getPlayPosition(pts_t &SWIG_OUTPUT);
+	RESULT setTrickmode(int trick);
+	RESULT isCurrentlySeekable();
+
+		// iServiceInformation
+	RESULT getName(std::string &name);
+	int getInfo(int w);
+	std::string getInfoString(int w);
+
+		// iAudioTrackSelection	
+	int getNumberOfTracks();
+	RESULT selectTrack(unsigned int i);
+	RESULT getTrackInfo(struct iAudioTrackInfo &, unsigned int n);
+	int getCurrentTrack();
+
+		// iAudioChannelSelection	
+	int getCurrentChannel();
+	RESULT selectChannel(int i);
+
+		// iSubtitleOutput
+	RESULT enableSubtitles(iSubtitleUser *user, SubtitleTrack &track);
+	RESULT disableSubtitles();
+	RESULT getSubtitleList(std::vector<SubtitleTrack> &sublist);
+	RESULT getCachedSubtitle(SubtitleTrack &track);
+
+		// iStreamedService
+	RESULT streamed(ePtr<iStreamedService> &ptr);
+	ePtr<iStreamBufferInfo> getBufferCharge();
+	int setBufferSize(int size);
+
+		// iAudioDelay
+	int getAC3Delay();
+	int getPCMDelay();
+	void setAC3Delay(int);
+	void setPCMDelay(int);
+
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+
+	struct bufferInfo
+	{
+		gint bufferPercent;
+		gint avgInRate;
+		gint avgOutRate;
+		gint64 bufferingLeft;
+		bufferInfo()
+			:bufferPercent(0), avgInRate(0), avgOutRate(0), bufferingLeft(-1)
+		{
+		}
+	};
+	struct errorInfo
+	{
+		std::string error_message;
+		std::string missing_codec;
+	};
+
+private:
+#if not defined ENABLE_MEDIAFWGSTREAMER
+	Player *player;
+#endif
+	static int pcm_delay;
+	static int ac3_delay;
+	int m_currentAudioStream;
+	int m_currentSubtitleStream;
+	int m_cachedSubtitleStream;
+	int selectAudioStream(int i);
+	std::vector<audioStream> m_audioStreams;
+	std::vector<subtitleStream> m_subtitleStreams;
+	iSubtitleUser *m_subtitle_widget;
+
+	int m_currentTrickRatio;
+
+	friend class eServiceFactoryEPlayer3;
+	eServiceReference m_ref;
+	int m_buffer_size;
+
+	bufferInfo m_bufferInfo;
+	errorInfo m_errorInfo;
+	std::string m_download_buffer_path;
+	eServiceEPlayer3(eServiceReference ref);
+	sigc::signal2<void, iPlayableService*, int> m_event;
+	enum
+	{
+		stIdle, stRunning, stStopped,
+	};
+	int m_state;
+
+#if defined ENABLE_MEDIAFWGSTREAMER
+	Context_t * player;
+#endif
+
+	struct Message
+	{
+		Message()
+			:type(-1)
+		{}
+		Message(int type)
+			:type(type)
+		{}
+		int type;
+	};
+	eFixedMessagePump<Message> m_pump;
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+
+	struct subtitle_page_t
+	{
+		uint32_t start_ms;
+		uint32_t end_ms;
+		std::string text;
+
+		subtitle_page_t(uint32_t start_ms_in, uint32_t end_ms_in, std::string text_in)
+			: start_ms(start_ms_in), end_ms(end_ms_in), text(text_in)
+		{
+		}
+	};
+
+	typedef std::map<uint32_t, subtitle_page_t> subtitle_pages_map_t;
+	typedef std::pair<uint32_t, subtitle_page_t> subtitle_pages_map_pair_t;
+	subtitle_pages_map_t m_subtitle_pages;
+	ePtr<eTimer> m_subtitle_sync_timer;
+	
+	ePtr<eTimer> m_streamingsrc_timeout;
+	pts_t m_prev_decoder_time;
+	int m_decoder_time_valid_state;
+
+	void pushSubtitles();
+
+	void sourceTimeout();
+	sourceStream m_sourceinfo;
+
+	RESULT seekToImpl(pts_t to);
+
+	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
+	std::string m_useragent;
+};
+
+#endif

