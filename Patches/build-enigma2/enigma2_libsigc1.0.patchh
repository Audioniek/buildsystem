--- enigma2/configure.ac
+++ enigma2/configure.ac
@@ -36,7 +36,7 @@
 	[GST_MAJORMINOR=$withval],[GST_MAJORMINOR=0.10])
 
 PKG_CHECK_MODULES(TUXTXT, tuxbox-tuxtxt)
-PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-2.0 libssl libcrypto])
+PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
 PKG_CHECK_MODULES(LIBDDVD, libdreamdvd, HAVE_LIBDDVD="yes", HAVE_LIBDDVD="no")
 AM_CONDITIONAL(HAVE_LIBDDVD, test "$HAVE_LIBDDVD" = "yes")
 PKG_CHECK_MODULES(AVAHI, avahi-client)
@@ -63,7 +63,7 @@
 	PKG_CHECK_MODULES(GSTREAMER, gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR)
 	PKG_CHECK_MODULES(BASE, [freetype2 fribidi gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR libdvbsi++ libpng libxml-2.0 libsigc-2.0 libssl libcrypto])
 else
-	PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-2.0 libssl libcrypto])
+	PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
 fi
 
 AC_ARG_ENABLE([tf7700],
--- enigma2/enigma2.pc.in
+++ enigma2/enigma2.pc.in
@@ -7,4 +7,4 @@
 Description: Enigma2
 Version: @VERSION@
 Cflags: -I${includedir}/enigma2 @ENIGMA2_CFLAGS@
-Requires.private: sigc++-2.0
+Requires.private: sigc++-1.2
--- enigma2/include/connection.h
+++ enigma2/include/connection.h
@@ -4,12 +4,12 @@
 #include <libsig_comp.h>
 #include <lib/base/object.h>
 
-class eConnection: public iObject, public sigc::connection
+class eConnection: public iObject, public Connection
 {
 	DECLARE_REF(eConnection);
 	ePtr<iObject> m_owner;
 public:
-	eConnection(iObject *owner, const sigc::connection &conn): sigc::connection(conn), m_owner(owner) { };
+	eConnection(iObject *owner, const Connection &conn): Connection(conn), m_owner(owner) { };
 	virtual ~eConnection() { disconnect(); }
 };
 
--- enigma2/include/libsig_comp.h
+++ enigma2/include/libsig_comp.h
@@ -2,8 +2,32 @@
 #define __LIBSIG_COMP_H
 
 #include <sigc++/sigc++.h>
+#include <sigc++/bind.h>
 
-#define CONNECT(_signal, _slot) _signal.connect(sigc::mem_fun(*this, &_slot))
-#define CONNECT_EXTRA(_signal, _slot, extra_args...) _signal.connect(bind(sigc::mem_fun(*this, &_slot), extra_args))
+#ifdef SIGC_CXX_NAMESPACES
+using namespace SigC;
+#endif
+
+#define CONNECT(SENDER, EMPFAENGER) SENDER.connect(slot(*this, &EMPFAENGER))
+// use this Makro to connect with a method
+// void bla::foo(int x);
+// to an
+// Signal<void, int> testSig;
+//
+// CONNECT(testSig, bla::foo);
+// signal and method (slot) must have the same signature
+
+#define CONNECT_1_0(SENDER, EMPFAENGER, PARAM) SENDER.connect( bind( slot(*this, &EMPFAENGER) ,PARAM ) )
+// use this for connect with a method
+// void bla::foo(int);
+// to an
+// Signal0<void> testSig;
+// CONNECT_1_0(testSig, bla:foo, 0);
+// here the signal has no parameter, but the slot have an int
+// the last parameter of the CONNECT_1_0 makro is the value that given to the paramater of the Slot method
+
+#define CONNECT_2_0(SENDER, EMPFAENGER, PARAM1, PARAM2) SENDER.connect( bind( slot(*this, &EMPFAENGER) ,PARAM1, PARAM2 ) )
+
+#define CONNECT_2_1(SENDER, EMPFAENGER, PARAM) SENDER.connect( bind( slot(*this, &EMPFAENGER) ,PARAM ) )
 
 #endif // __LIBSIG_COMP_H

--- enigma2/lib/base/console.h
+++ enigma2/lib/base/console.h
@@ -19,7 +19,7 @@
 	int dataSent;
 };
 
-class eConsoleAppContainer: public sigc::trackable, public iObject
+class eConsoleAppContainer: public Object, public iObject
 {
 	DECLARE_REF(eConsoleAppContainer);
 	int fd[3];
--- enigma2/lib/base/e2avahi.cpp
+++ enigma2/lib/base/e2avahi.cpp
@@ -15,7 +15,7 @@
 /* API to the E2 event loop */
 static AvahiPoll avahi_poll_api;
 
-struct AvahiTimeout: public sigc::trackable
+struct AvahiTimeout: public Object
 {
 	ePtr<eTimer> timer;
 	AvahiTimeoutCallback callback;
@@ -36,7 +36,7 @@
 	}
 };
 
-struct AvahiWatch: public sigc::trackable
+struct AvahiWatch: public Object
 {
 	ePtr<eSocketNotifier> sn;
 	AvahiWatchCallback callback;
--- enigma2/lib/base/httpsstream.h
+++ enigma2/lib/base/httpsstream.h
@@ -10,7 +10,7 @@
 #include <openssl/ssl.h>
 #include <openssl/err.h>
 
-class eHttpsStream: public iTsSource, public sigc::trackable, public eThread
+class eHttpsStream: public iTsSource, public Object, public eThread
 {
 	DECLARE_REF(eHttpsStream);
 
--- enigma2/lib/base/httpstream.h
+++ enigma2/lib/base/httpstream.h
@@ -6,7 +6,7 @@
 #include <lib/base/itssource.h>
 #include <lib/base/thread.h>
 
-class eHttpStream: public iTsSource, public sigc::trackable, public eThread
+class eHttpStream: public iTsSource, public Object, public eThread
 {
 	DECLARE_REF(eHttpStream);
 
--- enigma2/lib/base/message.h
+++ enigma2/lib/base/message.h
@@ -50,7 +50,7 @@
  * Automatically creates a eSocketNotifier and gives you a callback.
  */
 template<class T>
-class eFixedMessagePump: public sigc::trackable, FD
+class eFixedMessagePump: public Object, FD
 {
 	eSingleLock lock;
 	ePtr<eSocketNotifier> sn;
@@ -96,7 +96,7 @@
 			eFatal("[eFixedMessagePump] write error %m");
 	}
 public:
-	sigc::signal1<void,const T&> recv_msg;
+	Signal1<void,const T&> recv_msg;
 	void send(const T &msg)
 	{
 		{
@@ -120,7 +120,7 @@
 };
 #endif
 
-class ePythonMessagePump: public eMessagePumpMT, public sigc::trackable
+class ePythonMessagePump: public eMessagePumpMT, public Object
 {
 	ePtr<eSocketNotifier> sn;
 	void do_recv(int)
--- enigma2/lib/components/file_eraser.h
+++ enigma2/lib/components/file_eraser.h
@@ -5,7 +5,7 @@
 #include <lib/base/message.h>
 #include <lib/base/ebase.h>
 
-class eBackgroundFileEraser: public eMainloop, private eThread, public sigc::trackable
+class eBackgroundFileEraser: public eMainloop, private eThread, public Object
 {
 	struct Message
 	{
--- enigma2/lib/components/scan.cpp
+++ enigma2/lib/components/scan.cpp
@@ -117,7 +117,7 @@
 	}
 
 	m_scan = new eDVBScan(channel);
-	m_scan->connectEvent(sigc::mem_fun(*this, &eComponentScan::scanEvent), m_scan_event_connection);
+	m_scan->connectEvent(slot(*this, &eComponentScan::scanEvent), m_scan_event_connection);
 
 	if (!(flags & scanRemoveServices))
 	{
--- enigma2/lib/components/scan.h
+++ enigma2/lib/components/scan.h
@@ -6,7 +6,7 @@
 
 class eDVBScan;
 
-class eComponentScan: public sigc::trackable, public iObject
+class eComponentScan: public Object, public iObject
 {
 	DECLARE_REF(eComponentScan);
 #ifndef SWIG
--- enigma2/lib/components/tuxtxtapp.h
+++ enigma2/lib/components/tuxtxtapp.h
@@ -8,7 +8,7 @@
 #include <lib/python/python.h>
 #include <lib/python/connections.h>
 
-class eTuxtxtApp: private eThread, public sigc::trackable
+class eTuxtxtApp: private eThread, public Object
 {
 #ifndef SWIG
 	int pid;
--- enigma2/lib/driver/avswitch.h
+++ enigma2/lib/driver/avswitch.h
@@ -6,7 +6,7 @@
 
 class eSocketNotifier;
 
-class eAVSwitch: public sigc::trackable
+class eAVSwitch: public Object
 {
 	static eAVSwitch *instance;
 	int m_video_mode;
--- enigma2/lib/driver/rc.h
+++ enigma2/lib/driver/rc.h
@@ -21,7 +21,7 @@
  *
  * Handles one remote control. Gets codes from a \ref eRCDriver. Produces events in \ref eRCInput.
  */
-class eRCDevice: public sigc::trackable
+class eRCDevice: public Object
 {
 protected:
 	eRCInput *input;
@@ -61,7 +61,7 @@
 /**
  * Receives codes from one or more remote controls.
  */
-class eRCDriver: public sigc::trackable
+class eRCDriver: public Object
 {
 protected:
 	std::list<eRCDevice*> listeners;
@@ -183,7 +183,7 @@
 
 #endif
 
-class eRCInput: public sigc::trackable
+class eRCInput: public Object
 {
 	int locked;
 	static eRCInput *instance;
@@ -204,7 +204,7 @@
 protected:
 	std::map<std::string,eRCDevice*,lstr> devices;
 public:
-	sigc::signal1<void, const eRCKey&> keyEvent;
+	Signal1<void, const eRCKey&> keyEvent;
 	eRCInput();
 	~eRCInput();
 
--- enigma2/lib/dvb/amldecoder.cpp
+++ enigma2/lib/dvb/amldecoder.cpp
@@ -70,7 +70,7 @@
 {
 	eDebug("[eAMLTSMPEGDecoder] SETTING UP DECODER                   ------------ WETEK");
 	if (m_demux)
-		m_demux->connectEvent(sigc::mem_fun(*this, &eAMLTSMPEGDecoder::demux_event), m_demux_event_conn);
+		m_demux->connectEvent(slot(*this, &eAMLTSMPEGDecoder::demux_event), m_demux_event_conn);
 	memset(&m_codec, 0, sizeof(codec_para_t ));
 	memset(&am_sysinfo, 0, sizeof(dec_sysinfo_t));
 	memset(&am_param, 0, sizeof(arm_audio_info));
@@ -697,7 +697,7 @@
 	}
 }
 
-RESULT eAMLTSMPEGDecoder::connectVideoEvent(const sigc::slot1<void, struct videoEvent> &event, ePtr<eConnection> &conn)
+RESULT eAMLTSMPEGDecoder::connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &conn)
 {
 	conn = new eConnection(this, m_video_event.connect(event));
 	return 0;
--- enigma2/lib/dvb/amldecoder.h
+++ enigma2/lib/dvb/amldecoder.h
@@ -35,7 +35,7 @@
 class eSocketNotifier;
 
 
-class eAMLTSMPEGDecoder: public sigc::trackable, public iTSMPEGDecoder
+class eAMLTSMPEGDecoder: public Object, public iTSMPEGDecoder
 {
 	DECLARE_REF(eAMLTSMPEGDecoder);
 private:
@@ -69,7 +69,7 @@
 
 	void demux_event(int event);
 	void video_event(struct videoEvent);
-	sigc::signal1<void, struct videoEvent> m_video_event;
+	Signal1<void, struct videoEvent> m_video_event;
 	int m_video_clip_fd;
 	ePtr<eTimer> m_showSinglePicTimer;
 	void finishShowSinglePic(); // called by timer
@@ -135,7 +135,7 @@
 	RESULT setRadioPic(const std::string &filename);
 		/* what 0=auto, 1=video, 2=audio. */
 	RESULT getPTS(int what, pts_t &pts);
-	RESULT connectVideoEvent(const sigc::slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection);
+	RESULT connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection);
 	int getVideoWidth();
 	int getVideoHeight();
 	int getVideoProgressive();
--- enigma2/lib/dvb/cablescan.h
+++ enigma2/lib/dvb/cablescan.h
@@ -9,7 +9,7 @@
 #include <lib/dvb/idemux.h>
 #include <lib/dvb/esection.h>
 
-class eCableScan: public sigc::trackable, public iObject
+class eCableScan: public Object, public iObject
 {
 	DECLARE_REF(eCableScan);
 
--- enigma2/lib/dvb/decoder.cpp
+++ enigma2/lib/dvb/decoder.cpp
@@ -575,7 +575,7 @@
 	}
 }
 
-RESULT eDVBVideo::connectEvent(const sigc::slot1<void, struct iTSMPEGDecoder::videoEvent> &event, ePtr<eConnection> &conn)
+RESULT eDVBVideo::connectEvent(const Slot1<void, struct iTSMPEGDecoder::videoEvent> &event, ePtr<eConnection> &conn)
 {
 	conn = new eConnection(this, m_event.connect(event));
 	return 0;
@@ -885,7 +885,7 @@
 		if ((m_vpid >= 0) && (m_vpid < 0x1FFF))
 		{
 			m_video = new eDVBVideo(m_demux, m_decoder);
-			m_video->connectEvent(sigc::mem_fun(*this, &eTSMPEGDecoder::video_event), m_video_event_conn);
+			m_video->connectEvent(slot(*this, &eTSMPEGDecoder::video_event), m_video_event_conn);
 			if (m_video->startPid(m_vpid, m_vtype))
 				res = -1;
 		}
@@ -1013,7 +1013,7 @@
 {
 	if (m_demux)
 	{
-		m_demux->connectEvent(sigc::mem_fun(*this, &eTSMPEGDecoder::demux_event), m_demux_event_conn);
+		m_demux->connectEvent(slot(*this, &eTSMPEGDecoder::demux_event), m_demux_event_conn);
 	}
 	CONNECT(m_showSinglePicTimer->timeout, eTSMPEGDecoder::finishShowSinglePic);
 	m_state = stateStop;
@@ -1329,7 +1329,7 @@
 	}
 }
 
-RESULT eTSMPEGDecoder::connectVideoEvent(const sigc::slot1<void, struct videoEvent> &event, ePtr<eConnection> &conn)
+RESULT eTSMPEGDecoder::connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &conn)
 {
 	conn = new eConnection(this, m_video_event.connect(event));
 	return 0;
--- enigma2/lib/dvb/decoder.h
+++ enigma2/lib/dvb/decoder.h
@@ -26,7 +26,7 @@
 	virtual ~eDVBAudio();
 };
 
-class eDVBVideo: public iObject, public sigc::trackable
+class eDVBVideo: public iObject, public Object
 {
 	DECLARE_REF(eDVBVideo);
 private:
@@ -36,7 +36,7 @@
 	int m_is_slow_motion, m_is_fast_forward, m_is_freezed;
 	ePtr<eSocketNotifier> m_sn;
 	void video_event(int what);
-	sigc::signal1<void, struct iTSMPEGDecoder::videoEvent> m_event;
+	Signal1<void, struct iTSMPEGDecoder::videoEvent> m_event;
 	int m_width, m_height, m_framerate, m_aspect, m_progressive;
 	static int readApiSize(int fd, int &xres, int &yres, int &aspect);
 public:
@@ -51,7 +51,7 @@
 	void unfreeze();
 	int getPTS(pts_t &now);
 	virtual ~eDVBVideo();
-	RESULT connectEvent(const sigc::slot1<void, struct iTSMPEGDecoder::videoEvent> &event, ePtr<eConnection> &conn);
+	RESULT connectEvent(const Slot1<void, struct iTSMPEGDecoder::videoEvent> &event, ePtr<eConnection> &conn);
 	int getWidth();
 	int getHeight();
 	int getProgressive();
@@ -85,7 +85,7 @@
 	virtual ~eDVBTText();
 };
 
-class eTSMPEGDecoder: public sigc::trackable, public iTSMPEGDecoder
+class eTSMPEGDecoder: public Object, public iTSMPEGDecoder
 {
 	DECLARE_REF(eTSMPEGDecoder);
 private:
@@ -117,7 +117,7 @@
 
 	void demux_event(int event);
 	void video_event(struct videoEvent);
-	sigc::signal1<void, struct videoEvent> m_video_event;
+	Signal1<void, struct videoEvent> m_video_event;
 	int m_video_clip_fd;
 	ePtr<eTimer> m_showSinglePicTimer;
 	void finishShowSinglePic(); // called by timer
@@ -167,7 +167,7 @@
 	RESULT setRadioPic(const std::string &filename);
 		/* what 0=auto, 1=video, 2=audio. */
 	RESULT getPTS(int what, pts_t &pts);
-	RESULT connectVideoEvent(const sigc::slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection);
+	RESULT connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection);
 	int getVideoWidth();
 	int getVideoHeight();
 	int getVideoProgressive();
--- enigma2/lib/dvb/demux.cpp
+++ enigma2/lib/dvb/demux.cpp
@@ -203,7 +203,7 @@
 	return 0;
 }
 
-RESULT eDVBDemux::connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &conn)
+RESULT eDVBDemux::connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &conn)
 {
 	conn = new eConnection(this, m_event.connect(event));
 	return 0;
@@ -313,7 +313,7 @@
 	return 0;
 }
 
-RESULT eDVBSectionReader::connectRead(const sigc::slot1<void,const uint8_t*> &r, ePtr<eConnection> &conn)
+RESULT eDVBSectionReader::connectRead(const Slot1<void,const uint8_t*> &r, ePtr<eConnection> &conn)
 {
 	conn = new eConnection(this, read.connect(r));
 	return 0;
@@ -417,7 +417,7 @@
 	return 0;
 }
 
-RESULT eDVBPESReader::connectRead(const sigc::slot2<void,const uint8_t*,int> &r, ePtr<eConnection> &conn)
+RESULT eDVBPESReader::connectRead(const Slot2<void,const uint8_t*,int> &r, ePtr<eConnection> &conn)
 {
 	conn = new eConnection(this, m_read.connect(r));
 	return 0;
@@ -906,7 +906,7 @@
 	return m_thread->getFirstPTS(pts);
 }
 
-RESULT eDVBTSRecorder::connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &conn)
+RESULT eDVBTSRecorder::connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &conn)
 {
 	conn = new eConnection(this, m_event.connect(event));
 	return 0;
--- enigma2/lib/dvb/demux.h
+++ enigma2/lib/dvb/demux.h
@@ -30,7 +30,7 @@
 	RESULT getCADemuxID(uint8_t &id) { id = demux; return 0; }
 	RESULT getCAAdapterID(uint8_t &id) { id = adapter; return 0; }
 	RESULT flush();
-	RESULT connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &conn);
+	RESULT connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &conn);
 	int openDVR(int flags);
 
 	int getRefCount() { return ref; }
@@ -53,16 +53,16 @@
 	int m_pvr_fd;
 	friend class eAMLTSMPEGDecoder;
 #endif
-	sigc::signal1<void, int> m_event;
+	Signal1<void, int> m_event;
 
 	int openDemux(void);
 };
 
-class eDVBSectionReader: public iDVBSectionReader, public sigc::trackable
+class eDVBSectionReader: public iDVBSectionReader, public Object
 {
 	DECLARE_REF(eDVBSectionReader);
 	int fd;
-	sigc::signal1<void, const uint8_t*> read;
+	Signal1<void, const uint8_t*> read;
 	ePtr<eDVBDemux> demux;
 	int active;
 	int checkcrc;
@@ -74,14 +74,14 @@
 	RESULT setBufferSize(int size);
 	RESULT start(const eDVBSectionFilterMask &mask);
 	RESULT stop();
-	RESULT connectRead(const sigc::slot1<void,const uint8_t*> &read, ePtr<eConnection> &conn);
+	RESULT connectRead(const Slot1<void,const uint8_t*> &read, ePtr<eConnection> &conn);
 };
 
-class eDVBPESReader: public iDVBPESReader, public sigc::trackable
+class eDVBPESReader: public iDVBPESReader, public Object
 {
 	DECLARE_REF(eDVBPESReader);
 	int m_fd;
-	sigc::signal2<void, const uint8_t*, int> m_read;
+	Signal2<void, const uint8_t*, int> m_read;
 	ePtr<eDVBDemux> m_demux;
 	int m_active;
 	void data(int);
@@ -92,7 +92,7 @@
 	RESULT setBufferSize(int size);
 	RESULT start(int pid);
 	RESULT stop();
-	RESULT connectRead(const sigc::slot2<void,const uint8_t*, int> &read, ePtr<eConnection> &conn);
+	RESULT connectRead(const Slot2<void,const uint8_t*, int> &read, ePtr<eConnection> &conn);
 };
 
 class eDVBRecordFileThread: public eFilePushThreadRecorder
@@ -146,7 +146,7 @@
 	void flush();
 };
 
-class eDVBTSRecorder: public iDVBTSRecorder, public sigc::trackable
+class eDVBTSRecorder: public iDVBTSRecorder, public Object
 {
 	DECLARE_REF(eDVBTSRecorder);
 public:
@@ -170,7 +170,7 @@
 	RESULT getCurrentPCR(pts_t &pcr);
 	RESULT getFirstPTS(pts_t &pts);
 
-	RESULT connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &conn);
+	RESULT connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &conn);
 private:
 	RESULT startPID(int pid);
 	void stopPID(int pid);
@@ -178,7 +178,7 @@
 	void filepushEvent(int event);
 
 	std::map<int,int> m_pids;
-	sigc::signal1<void,int> m_event;
+	Signal1<void,int> m_event;
 
 	ePtr<eDVBDemux> m_demux;
 
--- enigma2/lib/dvb/dvb.cpp
+++ enigma2/lib/dvb/dvb.cpp
@@ -1262,7 +1262,7 @@
 	return -ENOENT;
 }
 
-RESULT eDVBResourceManager::connectChannelAdded(const sigc::slot1<void,eDVBChannel*> &channelAdded, ePtr<eConnection> &connection)
+RESULT eDVBResourceManager::connectChannelAdded(const Slot1<void,eDVBChannel*> &channelAdded, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((eDVBResourceManager*)this, m_channelAdded.connect(channelAdded));
 	return 0;
@@ -1526,7 +1526,7 @@
 	m_skipmode_n = m_skipmode_m = m_skipmode_frames = 0;
 
 	if (m_frontend)
-		m_frontend->get().connectStateChange(sigc::mem_fun(*this, &eDVBChannel::frontendStateChanged), m_conn_frontendStateChanged);
+		m_frontend->get().connectStateChange(slot(*this, &eDVBChannel::frontendStateChanged), m_conn_frontendStateChanged);
 }
 
 eDVBChannel::~eDVBChannel()
@@ -1995,13 +1995,13 @@
 	return 0;
 }
 
-RESULT eDVBChannel::connectStateChange(const sigc::slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection)
+RESULT eDVBChannel::connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iDVBChannel*)this, m_stateChanged.connect(stateChange));
 	return 0;
 }
 
-RESULT eDVBChannel::connectEvent(const sigc::slot2<void,iDVBChannel*,int> &event, ePtr<eConnection> &connection)
+RESULT eDVBChannel::connectEvent(const Slot2<void,iDVBChannel*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iDVBChannel*)this, m_event.connect(event));
 	return 0;
@@ -2215,7 +2215,7 @@
 	m_conn_cueSheetEvent = 0;
 	m_cue = cuesheet;
 	if (m_cue)
-		m_cue->connectEvent(sigc::mem_fun(*this, &eDVBChannel::cueSheetEvent), m_conn_cueSheetEvent);
+		m_cue->connectEvent(slot(*this, &eDVBChannel::cueSheetEvent), m_conn_cueSheetEvent);
 }
 
 void eDVBChannel::setOfflineDecodeMode(int parityswitchdelay)
@@ -2340,7 +2340,7 @@
 	m_decoder = decoder;
 }
 
-RESULT eCueSheet::connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &connection)
+RESULT eCueSheet::connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection(this, m_event.connect(event));
 	return 0;
--- enigma2/lib/dvb/dvb.h
+++ enigma2/lib/dvb/dvb.h
@@ -23,13 +23,13 @@
 	   (and how to deallocate it). */
 class iDVBAdapter;
 
-class eDVBRegisteredFrontend: public iObject, public sigc::trackable
+class eDVBRegisteredFrontend: public iObject, public Object
 {
 	DECLARE_REF(eDVBRegisteredFrontend);
 	ePtr<eTimer> disable;
 	void closeFrontend();
 public:
-	sigc::signal0<void> stateChanged;
+	Signal0<void> stateChanged;
 	eDVBRegisteredFrontend(eDVBFrontend *fe, iDVBAdapter *adap)
 		:disable(eTimer::create(eApp)), m_adapter(adap), m_frontend(fe), m_inuse(0)
 	{
@@ -154,7 +154,7 @@
 #endif // SWIG
 
 SWIG_IGNORE(eDVBResourceManager);
-class eDVBResourceManager: public iObject, public sigc::trackable
+class eDVBResourceManager: public iObject, public Object
 {
 	DECLARE_REF(eDVBResourceManager);
 	int avail, busy;
@@ -184,10 +184,10 @@
 	RESULT addChannel(const eDVBChannelID &chid, eDVBChannel *ch);
 	RESULT removeChannel(eDVBChannel *ch);
 
-	sigc::signal1<void,eDVBChannel*> m_channelAdded;
+	Signal1<void,eDVBChannel*> m_channelAdded;
 
 	eUsePtr<iDVBChannel> m_cached_channel;
-	sigc::connection m_cached_channel_state_changed_conn;
+	Connection m_cached_channel_state_changed_conn;
 	ePtr<eTimer> m_releaseCachedChannelTimer;
 	void DVBChannelStateChanged(iDVBChannel*);
 	void feStateChanged();
@@ -211,7 +211,7 @@
 		errNoSourceFound = -7,
 	};
 
-	RESULT connectChannelAdded(const sigc::slot1<void,eDVBChannel*> &channelAdded, ePtr<eConnection> &connection);
+	RESULT connectChannelAdded(const Slot1<void,eDVBChannel*> &channelAdded, ePtr<eConnection> &connection);
 	int canAllocateChannel(const eDVBChannelID &channelid, const eDVBChannelID &ignore, int &system, bool simulate=false);
 
 		/* allocate channel... */
@@ -258,7 +258,7 @@
 class eDVBChannelFilePush;
 
 	/* iDVBPVRChannel includes iDVBChannel. don't panic. */
-class eDVBChannel: public iDVBPVRChannel, public iFilePushScatterGather, public sigc::trackable
+class eDVBChannel: public iDVBPVRChannel, public iFilePushScatterGather, public Object
 {
 	DECLARE_REF(eDVBChannel);
 	friend class eDVBResourceManager;
@@ -274,8 +274,8 @@
 	int getSkipMode() { return m_skipmode_m; }
 #endif
 
-	RESULT connectStateChange(const sigc::slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
-	RESULT connectEvent(const sigc::slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
+	RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
 
 	RESULT getState(int &state);
 
@@ -306,8 +306,8 @@
 
 	ePtr<iDVBFrontendParameters> m_current_frontend_parameters;
 	eDVBChannelID m_channel_id;
-	sigc::signal1<void,iDVBChannel*> m_stateChanged;
-	sigc::signal2<void,iDVBChannel*,int> m_event;
+	Signal1<void,iDVBChannel*> m_stateChanged;
+	Signal2<void,iDVBChannel*,int> m_event;
 	int m_state;
 	ePtr<iTsSource> m_source;
 
--- enigma2/lib/dvb/dvbtime.cpp
+++ enigma2/lib/dvb/dvbtime.cpp
@@ -213,7 +213,7 @@
 		eDebug("[eDVBLocalTimerHandler] no resource manager !!!!!!!");
 	else
 	{
-		res_mgr->connectChannelAdded(sigc::mem_fun(*this,&eDVBLocalTimeHandler::DVBChannelAdded), m_chanAddedConn);
+		res_mgr->connectChannelAdded(slot(*this,&eDVBLocalTimeHandler::DVBChannelAdded), m_chanAddedConn);
 		time_t now = time(0);
 		if ( now < 1072224000 ) // 01.01.2004
 			eDebug("[eDVBLocalTimeHandler] RTC not ready... wait for transponder time");
@@ -594,7 +594,7 @@
 		tmp.first->second.timetable = NULL;
 		tmp.first->second.channel = chan;
 		tmp.first->second.m_prevChannelState = -1;
-		chan->connectStateChange(sigc::mem_fun(*this, &eDVBLocalTimeHandler::DVBChannelStateChanged), tmp.first->second.m_stateChangedConn);
+		chan->connectStateChange(slot(*this, &eDVBLocalTimeHandler::DVBChannelStateChanged), tmp.first->second.m_stateChangedConn);
 	}
 }
 
--- enigma2/lib/dvb/dvbtime.h
+++ enigma2/lib/dvb/dvbtime.h
@@ -64,7 +64,7 @@
 
 #endif  // SWIG
 
-class eDVBLocalTimeHandler: public sigc::trackable
+class eDVBLocalTimeHandler: public Object
 {
 	DECLARE_REF(eDVBLocalTimeHandler);
 	struct channel_data
--- enigma2/lib/dvb/eit.cpp
+++ enigma2/lib/dvb/eit.cpp
@@ -68,13 +68,13 @@
 							if (!a)
 							{
 								m_demux->createSectionReader(eApp, m_now_ETT);
-								m_now_ETT->connectRead(sigc::mem_fun(*this, &eDVBServiceEITHandler::nowETTsection), m_now_conn);
+								m_now_ETT->connectRead(slot(*this, &eDVBServiceEITHandler::nowETTsection), m_now_conn);
 								m_now_ETT->start(mask);
 							}
 							else
 							{
 								m_demux->createSectionReader(eApp, m_next_ETT);
-								m_next_ETT->connectRead(sigc::mem_fun(*this, &eDVBServiceEITHandler::nextETTsection), m_next_conn);
+								m_next_ETT->connectRead(slot(*this, &eDVBServiceEITHandler::nextETTsection), m_next_conn);
 								m_next_ETT->start(mask);
 							}
 						}
--- enigma2/lib/dvb/eit.h
+++ enigma2/lib/dvb/eit.h
@@ -7,7 +7,7 @@
 #include <dvbsi++/event_information_section.h>
 #include <lib/service/event.h>
 
-class eDVBServiceEITHandler: public sigc::trackable
+class eDVBServiceEITHandler: public Object
 {
 	int sourceId;
 	int ETTpid;
--- enigma2/lib/dvb/epgcache.cpp
+++ enigma2/lib/dvb/epgcache.cpp
@@ -427,7 +427,7 @@
 	if (!res_mgr)
 		eDebug("[eEPGCache] no resource manager !!!!!!!");
 	else
-		res_mgr->connectChannelAdded(sigc::mem_fun(*this,&eEPGCache::DVBChannelAdded), m_chanAddedConn);
+		res_mgr->connectChannelAdded(slot(*this,&eEPGCache::DVBChannelAdded), m_chanAddedConn);
 
 	instance=this;
 }
@@ -487,7 +487,7 @@
 #endif
 		singleLock s(channel_map_lock);
 		m_knownChannels.insert( std::pair<iDVBChannel*, channel_data* >(chan, data) );
-		chan->connectStateChange(sigc::mem_fun(*this, &eEPGCache::DVBChannelStateChanged), data->m_stateChangedConn);
+		chan->connectStateChange(slot(*this, &eEPGCache::DVBChannelStateChanged), data->m_stateChangedConn);
 	}
 }
 
@@ -1597,7 +1597,7 @@
 		mask.pid = 0xD3;
 		mask.data[0] = 0x91;
 		mask.mask[0] = 0xFF;
-		m_MHWReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::readMHWData), m_MHWConn);
+		m_MHWReader->connectRead(slot(*this, &eEPGCache::channel_data::readMHWData), m_MHWConn);
 		m_MHWReader->start(mask);
 		isRunning |= MHW;
 		memcpy(&m_MHWFilterMask, &mask, sizeof(eDVBSectionFilterMask));
@@ -1607,7 +1607,7 @@
 		mask.mask[0] = 0xFF;
 		mask.data[1] = 0;
 		mask.mask[1] = 0xFF;
-		m_MHWReader2->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::readMHWData2), m_MHWConn2);
+		m_MHWReader2->connectRead(slot(*this, &eEPGCache::channel_data::readMHWData2), m_MHWConn2);
 		m_MHWReader2->start(mask);
 		isRunning |= MHW;
 		memcpy(&m_MHWFilterMask2, &mask, sizeof(eDVBSectionFilterMask));
@@ -1623,7 +1623,7 @@
 		mask.flags = eDVBSectionFilterMask::rfCRC;
 		mask.data[0] = 0x60;
 		mask.mask[0] = 0xFE;
-		m_FreeSatScheduleOtherReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::readFreeSatScheduleOtherData), m_FreeSatScheduleOtherConn);
+		m_FreeSatScheduleOtherReader->connectRead(slot(*this, &eEPGCache::channel_data::readFreeSatScheduleOtherData), m_FreeSatScheduleOtherConn);
 		m_FreeSatScheduleOtherReader->start(mask);
 
 		/*
@@ -1633,7 +1633,7 @@
 		 * and status maps)
 		 */
 		mask.pid = 3003;
-		m_FreeSatScheduleOtherReader2->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::readFreeSatScheduleOtherData), m_FreeSatScheduleOtherConn2);
+		m_FreeSatScheduleOtherReader2->connectRead(slot(*this, &eEPGCache::channel_data::readFreeSatScheduleOtherData), m_FreeSatScheduleOtherConn2);
 		m_FreeSatScheduleOtherReader2->start(mask);
 		isRunning |= FREESAT_SCHEDULE_OTHER;
 	}
@@ -1659,7 +1659,7 @@
 	{
 		mask.data[0] = 0x4E;
 		mask.mask[0] = 0xFE;
-		m_NowNextReader->connectRead(bind(sigc::mem_fun(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::NOWNEXT), m_NowNextConn);
+		m_NowNextReader->connectRead(bind(slot(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::NOWNEXT), m_NowNextConn);
 		m_NowNextReader->start(mask);
 		isRunning |= NOWNEXT;
 	}
@@ -1668,7 +1668,7 @@
 	{
 		mask.data[0] = 0x50;
 		mask.mask[0] = 0xF0;
-		m_ScheduleReader->connectRead(bind(sigc::mem_fun(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::SCHEDULE), m_ScheduleConn);
+		m_ScheduleReader->connectRead(bind(slot(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::SCHEDULE), m_ScheduleConn);
 		m_ScheduleReader->start(mask);
 		isRunning |= SCHEDULE;
 	}
@@ -1677,7 +1677,7 @@
 	{
 		mask.data[0] = 0x60;
 		mask.mask[0] = 0xF0;
-		m_ScheduleOtherReader->connectRead(bind(sigc::mem_fun(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::SCHEDULE_OTHER), m_ScheduleOtherConn);
+		m_ScheduleOtherReader->connectRead(bind(slot(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::SCHEDULE_OTHER), m_ScheduleOtherConn);
 		m_ScheduleOtherReader->start(mask);
 		isRunning |= SCHEDULE_OTHER;
 	}
@@ -1688,7 +1688,7 @@
 		mask.pid = 0x2bc;
 		mask.data[0] = 0x4E;
 		mask.mask[0] = 0xFE;
-		m_VirginNowNextReader->connectRead(bind(sigc::mem_fun(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::VIRGIN_NOWNEXT), m_VirginNowNextConn);
+		m_VirginNowNextReader->connectRead(bind(slot(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::VIRGIN_NOWNEXT), m_VirginNowNextConn);
 		m_VirginNowNextReader->start(mask);
 		isRunning |= VIRGIN_NOWNEXT;
 	}
@@ -1698,7 +1698,7 @@
 		mask.pid = 0x2bc;
 		mask.data[0] = 0x50;
 		mask.mask[0] = 0xFE;
-		m_VirginScheduleReader->connectRead(bind(sigc::mem_fun(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::VIRGIN_SCHEDULE), m_VirginScheduleConn);
+		m_VirginScheduleReader->connectRead(bind(slot(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::VIRGIN_SCHEDULE), m_VirginScheduleConn);
 		m_VirginScheduleReader->start(mask);
 		isRunning |= VIRGIN_SCHEDULE;
 	}
@@ -1709,7 +1709,7 @@
 		mask.pid = 0x1388;
 		mask.data[0] = 0x50;
 		mask.mask[0] = 0xF0;
-		m_NetmedScheduleReader->connectRead(bind(sigc::mem_fun(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::NETMED_SCHEDULE), m_NetmedScheduleConn);
+		m_NetmedScheduleReader->connectRead(bind(slot(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::NETMED_SCHEDULE), m_NetmedScheduleConn);
 		m_NetmedScheduleReader->start(mask);
 		isRunning |= NETMED_SCHEDULE;
 	}
@@ -1719,7 +1719,7 @@
 		mask.pid = 0x1388;
 		mask.data[0] = 0x60;
 		mask.mask[0] = 0xF0;
-		m_NetmedScheduleOtherReader->connectRead(bind(sigc::mem_fun(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::NETMED_SCHEDULE_OTHER), m_NetmedScheduleOtherConn);
+		m_NetmedScheduleOtherReader->connectRead(bind(slot(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::NETMED_SCHEDULE_OTHER), m_NetmedScheduleOtherConn);
 		m_NetmedScheduleOtherReader->start(mask);
 		isRunning |= NETMED_SCHEDULE_OTHER;
 	}
@@ -1728,10 +1728,10 @@
 	if (eEPGCache::getInstance()->getEpgSources() & eEPGCache::ATSC_EIT && m_ATSC_MGTReader)
 	{
 		m_atsc_eit_index = 0;
-		m_ATSC_MGTReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::ATSC_MGTsection), m_ATSC_MGTConn);
-		m_ATSC_VCTReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::ATSC_VCTsection), m_ATSC_VCTConn);
-		m_ATSC_EITReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::ATSC_EITsection), m_ATSC_EITConn);
-		m_ATSC_ETTReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::ATSC_ETTsection), m_ATSC_ETTConn);
+		m_ATSC_MGTReader->connectRead(slot(*this, &eEPGCache::channel_data::ATSC_MGTsection), m_ATSC_MGTConn);
+		m_ATSC_VCTReader->connectRead(slot(*this, &eEPGCache::channel_data::ATSC_VCTsection), m_ATSC_VCTConn);
+		m_ATSC_EITReader->connectRead(slot(*this, &eEPGCache::channel_data::ATSC_EITsection), m_ATSC_EITConn);
+		m_ATSC_ETTReader->connectRead(slot(*this, &eEPGCache::channel_data::ATSC_ETTsection), m_ATSC_ETTConn);
 		mask.pid = 0x1ffb;
 		mask.data[0] = 0xc7;
 		mask.mask[0] = 0xff;
@@ -1749,7 +1749,7 @@
 
 		mask.data[0] = 0x40;
 		mask.mask[0] = 0x40;
-		m_ViasatReader->connectRead(bind(sigc::mem_fun(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::VIASAT), m_ViasatConn);
+		m_ViasatReader->connectRead(bind(slot(*this, &eEPGCache::channel_data::readData), (int)eEPGCache::VIASAT), m_ViasatConn);
 		m_ViasatReader->start(mask);
 		isRunning |= VIASAT;
 	}
@@ -1778,7 +1778,7 @@
 		{
 			eDVBSectionFilterMask mask = {};
 			m_atsc_eit_index++;
-			m_ATSC_MGTReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::ATSC_MGTsection), m_ATSC_MGTConn);
+			m_ATSC_MGTReader->connectRead(slot(*this, &eEPGCache::channel_data::ATSC_MGTsection), m_ATSC_MGTConn);
 			mask.pid = 0x1ffb;
 			mask.data[0] = 0xc7;
 			mask.mask[0] = 0xff;
@@ -1828,7 +1828,7 @@
 			mask.pid = (*table)->getPID();
 			mask.data[0] = 0xcb;
 			mask.mask[0] = 0xff;
-			m_ATSC_EITReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::ATSC_EITsection), m_ATSC_EITConn);
+			m_ATSC_EITReader->connectRead(slot(*this, &eEPGCache::channel_data::ATSC_EITsection), m_ATSC_EITConn);
 			m_ATSC_EITReader->start(mask);
 		}
 		else if ((*table)->getTableType() == 0x0200 + m_atsc_eit_index)
@@ -1837,7 +1837,7 @@
 			mask.pid = (*table)->getPID();
 			mask.data[0] = 0xcc;
 			mask.mask[0] = 0xff;
-			m_ATSC_ETTReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::ATSC_ETTsection), m_ATSC_ETTConn);
+			m_ATSC_ETTReader->connectRead(slot(*this, &eEPGCache::channel_data::ATSC_ETTsection), m_ATSC_ETTConn);
 			m_ATSC_ETTReader->start(mask);
 		}
 	}
@@ -4070,7 +4070,7 @@
 	}
 	seenPrivateSections.clear();
 	if (!m_PrivateConn)
-		m_PrivateReader->connectRead(sigc::mem_fun(*this, &eEPGCache::channel_data::readPrivateData), m_PrivateConn);
+		m_PrivateReader->connectRead(slot(*this, &eEPGCache::channel_data::readPrivateData), m_PrivateConn);
 	m_PrivateReader->start(mask);
 }
 
--- enigma2/lib/dvb/epgcache.h
+++ enigma2/lib/dvb/epgcache.h
@@ -129,11 +129,11 @@
 };
 #endif
 
-class eEPGCache: public eMainloop, private eThread, public sigc::trackable
+class eEPGCache: public eMainloop, private eThread, public Object
 {
 #ifndef SWIG
 	DECLARE_REF(eEPGCache)
-	struct channel_data: public sigc::trackable
+	struct channel_data: public Object
 	{
 		pthread_mutex_t channel_active;
 		channel_data(eEPGCache*);
--- enigma2/lib/dvb/esection.cpp
+++ enigma2/lib/dvb/esection.cpp
@@ -62,7 +62,7 @@
 	m_table = table;
 
 	m_reader = reader;
-	m_reader->connectRead(sigc::mem_fun(*this, &eGTable::sectionRead), m_sectionRead_conn);
+	m_reader->connectRead(slot(*this, &eGTable::sectionRead), m_sectionRead_conn);
 
 	m_tries = 0;
 
--- enigma2/lib/dvb/esection.h
+++ enigma2/lib/dvb/esection.h
@@ -8,7 +8,7 @@
 #define TABLE_eDebugNoNewLineStart(x...) do { if (m_debug) eDebugNoNewLineStart(x); } while(0)
 #define TABLE_eDebugNoNewLine(x...) do { if (m_debug) eDebugNoNewLine(x); } while(0)
 
-class eGTable: public iObject, public sigc::trackable
+class eGTable: public iObject, public Object
 {
 	DECLARE_REF(eGTable);
 	ePtr<iDVBSectionReader> m_reader;
@@ -26,7 +26,7 @@
 	virtual int createTable(unsigned int nr, const uint8_t *data, unsigned int max)=0;
 	virtual unsigned int totalSections(unsigned int max) { return max + 1; }
 public:
-	sigc::signal1<void, int> tableReady;
+	Signal1<void, int> tableReady;
 	eGTable();
 	RESULT start(iDVBSectionReader *reader, const eDVBTableSpec &table);
 	RESULT start(iDVBDemux *reader, const eDVBTableSpec &table);
@@ -84,13 +84,13 @@
 	}
 };
 
-class eAUGTable: public sigc::trackable
+class eAUGTable: public Object
 {
 protected:
 	void slotTableReady(int);
 public:
 	virtual ~eAUGTable(){};
-	sigc::signal1<void, int> tableReady;
+	Signal1<void, int> tableReady;
 	virtual void getNext(int err)=0;
 };
 
--- enigma2/lib/dvb/fastscan.h
+++ enigma2/lib/dvb/fastscan.h
@@ -197,7 +197,7 @@
 		tableProgress(seen.size(), max);
 		return eTable<Section>::createTable(nr, data, max);
 	}
-	sigc::signal2<void, int, int> tableProgress;
+	Signal2<void, int, int> tableProgress;
 };
 
 template <class Section>
@@ -220,7 +220,7 @@
 
 #endif /* no SWIG */
 
-class eFastScan: public sigc::trackable, public iObject
+class eFastScan: public Object, public iObject
 {
 	DECLARE_REF(eFastScan);
 
--- enigma2/lib/dvb/fbc.h
+++ enigma2/lib/dvb/fbc.h
@@ -13,7 +13,7 @@
 class eDVBFrontend;
 class eDVBRegisteredFrontend;
 
-class eFBCTunerManager: public iObject, public sigc::trackable
+class eFBCTunerManager: public iObject, public Object
 {
 private:
 	typedef std::bitset<8> connect_choices_t;
--- enigma2/lib/dvb/filepush.h
+++ enigma2/lib/dvb/filepush.h
@@ -19,7 +19,7 @@
 #endif
 };
 
-class eFilePushThread: public eThread, public sigc::trackable, public iObject
+class eFilePushThread: public eThread, public Object, public iObject
 {
 	DECLARE_REF(eFilePushThread);
 public:
@@ -38,7 +38,7 @@
 	void setScatterGather(iFilePushScatterGather *);
 
 	enum { evtEOF, evtReadError, evtWriteError, evtUser, evtStopped };
-	sigc::signal1<void,int> m_event;
+	Signal1<void,int> m_event;
 
 		/* you can send private events if you want */
 	void sendEvent(int evt);
@@ -65,7 +65,7 @@
 	void recvEvent(const int &evt);
 };
 
-class eFilePushThreadRecorder: public eThread, public sigc::trackable
+class eFilePushThreadRecorder: public eThread, public Object
 {
 public:
 	eFilePushThreadRecorder(unsigned char* buffer, size_t buffersize);
@@ -74,7 +74,7 @@
 	void start(int sourcefd);
 
 	enum { evtEOF, evtReadError, evtWriteError, evtUser, evtStopped };
-	sigc::signal1<void,int> m_event;
+	Signal1<void,int> m_event;
 
 	void sendEvent(int evt);
 protected:
--- enigma2/lib/dvb/frontend.cpp
+++ enigma2/lib/dvb/frontend.cpp
@@ -2528,7 +2528,7 @@
 	return res;
 }
 
-RESULT eDVBFrontend::connectStateChange(const sigc::slot1<void,iDVBFrontend*> &stateChange, ePtr<eConnection> &connection)
+RESULT eDVBFrontend::connectStateChange(const Slot1<void,iDVBFrontend*> &stateChange, ePtr<eConnection> &connection)
 {
 	connection = new eConnection(this, m_stateChanged.connect(stateChange));
 	return 0;
--- enigma2/lib/dvb/frontend.h
+++ enigma2/lib/dvb/frontend.h
@@ -48,7 +48,7 @@
 #include <lib/dvb/sec.h>
 class eSecCommandList;
 
-class eDVBFrontend: public iDVBFrontend, public sigc::trackable
+class eDVBFrontend: public iDVBFrontend, public Object
 {
 public:
 	enum {
@@ -72,7 +72,7 @@
 		DICTION,              // current "diction" (0 = normal, 1 = Unicable, 2 = JESS)
 		NUM_DATA_ENTRIES
 	};
-	sigc::signal1<void,iDVBFrontend*> m_stateChanged;
+	Signal1<void,iDVBFrontend*> m_stateChanged;
 private:
 	DECLARE_REF(eDVBFrontend);
 	bool m_simulate;
@@ -134,7 +134,7 @@
 	RESULT prepare_cable(const eDVBFrontendParametersCable &);
 	RESULT prepare_terrestrial(const eDVBFrontendParametersTerrestrial &);
 	RESULT prepare_atsc(const eDVBFrontendParametersATSC &);
-	RESULT connectStateChange(const sigc::slot1<void,iDVBFrontend*> &stateChange, ePtr<eConnection> &connection);
+	RESULT connectStateChange(const Slot1<void,iDVBFrontend*> &stateChange, ePtr<eConnection> &connection);
 	RESULT getState(int &state);
 	RESULT setTone(int tone);
 	RESULT setVoltage(int voltage);
--- enigma2/lib/dvb/idemux.h
+++ enigma2/lib/dvb/idemux.h
@@ -9,7 +9,7 @@
 	virtual RESULT setBufferSize(int size)=0;
 	virtual RESULT start(const eDVBSectionFilterMask &mask)=0;
 	virtual RESULT stop()=0;
-	virtual RESULT connectRead(const sigc::slot1<void,const uint8_t*> &read, ePtr<eConnection> &conn)=0;
+	virtual RESULT connectRead(const Slot1<void,const uint8_t*> &read, ePtr<eConnection> &conn)=0;
 	virtual ~iDVBSectionReader() { };
 };
 
@@ -19,7 +19,7 @@
 	virtual RESULT setBufferSize(int size)=0;
 	virtual RESULT start(int pid)=0;
 	virtual RESULT stop()=0;
-	virtual RESULT connectRead(const sigc::slot2<void,const uint8_t*, int> &read, ePtr<eConnection> &conn)=0;
+	virtual RESULT connectRead(const Slot2<void,const uint8_t*, int> &read, ePtr<eConnection> &conn)=0;
 	virtual ~iDVBPESReader() { };
 };
 
@@ -56,7 +56,7 @@
 				/* the programmed boundary was reached. you might set a new target fd. you can close the */
 				/* old one. */
 	};
-	virtual RESULT connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &conn)=0;
+	virtual RESULT connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &conn)=0;
 };
 
 #endif
--- enigma2/lib/dvb/idvb.h
+++ enigma2/lib/dvb/idvb.h
@@ -520,7 +520,7 @@
 	virtual int closeFrontend(bool force = false, bool no_delayed = false)=0;
 	virtual void reopenFrontend()=0;
 #ifndef SWIG
-	virtual RESULT connectStateChange(const sigc::slot1<void,iDVBFrontend*> &stateChange, ePtr<eConnection> &connection)=0;
+	virtual RESULT connectStateChange(const Slot1<void,iDVBFrontend*> &stateChange, ePtr<eConnection> &connection)=0;
 #endif
 	virtual RESULT getState(int &SWIG_OUTPUT)=0;
 	virtual RESULT setTone(int tone)=0;
@@ -589,8 +589,8 @@
 	{
 		evtPreStart, evtEOF, evtSOF, evtFailed, evtStopped
 	};
-	virtual RESULT connectStateChange(const sigc::slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection)=0;
-	virtual RESULT connectEvent(const sigc::slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection)=0;
+	virtual RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection)=0;
+	virtual RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection)=0;
 
 		/* demux capabilities */
 	enum
@@ -620,7 +620,7 @@
 	   everything is specified in pts and not file positions */
 
 	/* implemented in dvb.cpp */
-class eCueSheet: public iObject, public sigc::trackable
+class eCueSheet: public iObject, public Object
 {
 	DECLARE_REF(eCueSheet);
 public:
@@ -641,12 +641,12 @@
 
 			/* backend */
 	enum { evtSeek, evtSkipmode, evtSpanChanged };
-	RESULT connectEvent(const sigc::slot1<void, int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot1<void, int> &event, ePtr<eConnection> &connection);
 
 	std::list<std::pair<pts_t,pts_t> > m_spans;	/* begin, end */
 	std::list<std::pair<int, pts_t> > m_seek_requests; /* relative, delta */
 	pts_t m_skipmode_ratio;
-	sigc::signal1<void,int> m_event;
+	Signal1<void,int> m_event;
 	ePtr<iDVBDemux> m_decoding_demux;
 	ePtr<iTSMPEGDecoder> m_decoder;
 };
@@ -762,7 +762,7 @@
 		unsigned short framerate;
 	};
 
-	virtual RESULT connectVideoEvent(const sigc::slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection) = 0;
+	virtual RESULT connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection) = 0;
 
 	virtual int getVideoWidth() = 0;
 	virtual int getVideoHeight() = 0;
--- enigma2/lib/dvb/isection.h
+++ enigma2/lib/dvb/isection.h
@@ -8,7 +8,7 @@
 public:
 	virtual RESULT start(const eDVBSectionFilterMask &mask)=0;
 	virtual RESULT stop()=0;
-	virtual RESULT connectRead(const sigc::slot1<void,const uint8_t*> &read, ePtr<eConnection> &conn)=0;
+	virtual RESULT connectRead(const Slot1<void,const uint8_t*> &read, ePtr<eConnection> &conn)=0;
 	virtual ~iDVBSectionReader() { };
 };
 
--- enigma2/lib/dvb/pmt.cpp
+++ enigma2/lib/dvb/pmt.cpp
@@ -894,13 +894,13 @@
 		if (m_channel)
 		{
 			m_channel->connectStateChange(
-				sigc::mem_fun(*this, &eDVBServicePMTHandler::channelStateChanged),
+				slot(*this, &eDVBServicePMTHandler::channelStateChanged),
 				m_channelStateChanged_connection);
 			m_last_channel_state = -1;
 			channelStateChanged(m_channel);
 
 			m_channel->connectEvent(
-				sigc::mem_fun(*this, &eDVBServicePMTHandler::channelEvent),
+				slot(*this, &eDVBServicePMTHandler::channelEvent),
 				m_channelEvent_connection);
 
 			if (ref.path.empty())
@@ -913,7 +913,7 @@
 					 * refcount bug (channel?/demux?), so we always start a scan,
 					 * but ignore the results when background scanning is disabled
 					 */
-					m_dvb_scan->connectEvent(sigc::mem_fun(*this, &eDVBServicePMTHandler::SDTScanEvent), m_scan_event_connection);
+					m_dvb_scan->connectEvent(slot(*this, &eDVBServicePMTHandler::SDTScanEvent), m_scan_event_connection);
 				}
 			}
 		} else
--- enigma2/lib/dvb/pmt.h
+++ enigma2/lib/dvb/pmt.h
@@ -114,7 +114,7 @@
 		eventStopped,
 	};
 #ifndef SWIG
-	sigc::signal1<void,int> serviceEvent;
+	Signal1<void,int> serviceEvent;
 
 	int getProgramInfo(program &program);
 	int getDataDemux(ePtr<iDVBDemux> &demux);
--- enigma2/lib/dvb/pmtparse.h
+++ enigma2/lib/dvb/pmtparse.h
@@ -10,7 +10,7 @@
 #include <dvbsi++/application_information_section.h>
 #include <dvbsi++/ca_descriptor.h>
 
-class eDVBPMTParser: public sigc::trackable
+class eDVBPMTParser: public Object
 {
 protected:
 	eAUTable<eTable<ProgramMapSection> > m_PMT;
--- enigma2/lib/dvb/radiotext.cpp
+++ enigma2/lib/dvb/radiotext.cpp
@@ -18,9 +18,9 @@
 	if (demux->createPESReader(eApp, m_pes_reader))
 		eDebug("failed to create PES reader!");
 	else if (type == 0)
-		m_pes_reader->connectRead(sigc::mem_fun(*this, &eDVBRdsDecoder::processData), m_read_connection);
+		m_pes_reader->connectRead(slot(*this, &eDVBRdsDecoder::processData), m_read_connection);
 	else
-		m_pes_reader->connectRead(sigc::mem_fun(*this, &eDVBRdsDecoder::gotAncillaryData), m_read_connection);
+		m_pes_reader->connectRead(slot(*this, &eDVBRdsDecoder::gotAncillaryData), m_read_connection);
 	CONNECT(m_abortTimer->timeout, eDVBRdsDecoder::abortNonAvail);
 }
 
@@ -95,7 +95,7 @@
 	{ 11025,12000,8000,0 }
 };
 
-void eDVBRdsDecoder::connectEvent(const sigc::slot1<void, int> &slot, ePtr<eConnection> &connection)
+void eDVBRdsDecoder::connectEvent(const Slot1<void, int> &slot, ePtr<eConnection> &connection)
 {
 	connection = new eConnection(this, m_event.connect(slot));
 }
--- enigma2/lib/dvb/radiotext.h
+++ enigma2/lib/dvb/radiotext.h
@@ -6,7 +6,7 @@
 #include <lib/dvb/pesparse.h>
 #include <lib/gdi/gpixmap.h>
 
-class eDVBRdsDecoder: public iObject, public ePESParser, public sigc::trackable
+class eDVBRdsDecoder: public iObject, public ePESParser, public Object
 {
 	DECLARE_REF(eDVBRdsDecoder);
 	int msgPtr, bsflag, qdar_pos, t_ptr, qdarmvi_show;
@@ -25,7 +25,7 @@
 	eDVBRdsDecoder(iDVBDemux *demux, int type);
 	~eDVBRdsDecoder();
 	int start(int pid);
-	void connectEvent(const sigc::slot1<void, int> &slot, ePtr<eConnection> &connection);
+	void connectEvent(const Slot1<void, int> &slot, ePtr<eConnection> &connection);
 	const char *getRadioText() { return (const char*)message; }
 	const char *getRtpText() { return (const char*)rtplus_osd; }
 	ePyObject getRassPictureMask();
@@ -39,7 +39,7 @@
 	void process_qdar(unsigned char*);
 	ePtr<iDVBPESReader> m_pes_reader;
 	ePtr<eConnection> m_read_connection;
-	sigc::signal1<void, int> m_event;
+	Signal1<void, int> m_event;
 	ePtr<eTimer> m_abortTimer;
 };
 
--- enigma2/lib/dvb/scan.cpp
+++ enigma2/lib/dvb/scan.cpp
@@ -45,7 +45,7 @@
 {
 	if (m_channel->getDemux(m_demux))
 		SCAN_eDebug("[eDVBScan] failed to allocate demux!");
-	m_channel->connectStateChange(sigc::mem_fun(*this, &eDVBScan::stateChange), m_stateChanged_connection);
+	m_channel->connectStateChange(slot(*this, &eDVBScan::stateChange), m_stateChanged_connection);
 }
 
 eDVBScan::~eDVBScan()
@@ -1693,7 +1693,7 @@
 	return 0;
 }
 
-RESULT eDVBScan::connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &connection)
+RESULT eDVBScan::connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection(this, m_event.connect(event));
 	return 0;
--- enigma2/lib/dvb/scan.h
+++ enigma2/lib/dvb/scan.h
@@ -23,7 +23,7 @@
 	bool scrambled;
 };
 
-class eDVBScan: public sigc::trackable, public iObject
+class eDVBScan: public Object, public iObject
 {
 	DECLARE_REF(eDVBScan);
 		/* chid helper functions: */
@@ -89,7 +89,7 @@
 
 	void channelDone();
 
-	sigc::signal1<void,int> m_event;
+	Signal1<void,int> m_event;
 	RESULT processSDT(eDVBNamespace dvbnamespace, const ServiceDescriptionSection &sdt);
 	RESULT processVCT(eDVBNamespace dvbnamespace, const VirtualChannelTableSection &vct, int onid);
 
@@ -111,7 +111,7 @@
 	void start(const eSmartPtrList<iDVBFrontendParameters> &known_transponders, int flags, int networkid = 0);
 
 	enum { evtUpdate, evtNewService, evtFinish, evtFail };
-	RESULT connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &connection);
 	void insertInto(iDVBChannelList *db, bool backgroundscanresult=false);
 
 	void getStats(int &transponders_done, int &transponders_total, int &services);
--- enigma2/lib/dvb/subtitle.cpp
+++ enigma2/lib/dvb/subtitle.cpp
@@ -1084,7 +1084,7 @@
 	if (demux->createPESReader(eApp, m_pes_reader))
 		eDebug("[eDVBSubtitleParser] failed to create PES reader!");
 	else
-		m_pes_reader->connectRead(sigc::mem_fun(*this, &eDVBSubtitleParser::processData), m_read_connection);
+		m_pes_reader->connectRead(slot(*this, &eDVBSubtitleParser::processData), m_read_connection);
 }
 
 eDVBSubtitleParser::~eDVBSubtitleParser()
@@ -1115,7 +1115,7 @@
 	return -1;
 }
 
-void eDVBSubtitleParser::connectNewPage(const sigc::slot1<void, const eDVBSubtitlePage&> &slot, ePtr<eConnection> &connection)
+void eDVBSubtitleParser::connectNewPage(const Slot1<void, const eDVBSubtitlePage&> &slot, ePtr<eConnection> &connection)
 {
 	connection = new eConnection(this, m_new_subtitle_page.connect(slot));
 }
--- enigma2/lib/dvb/subtitle.h
+++ enigma2/lib/dvb/subtitle.h
@@ -109,14 +109,14 @@
 };
 
 class eDVBSubtitleParser
-	:public iObject, public ePESParser, public sigc::trackable
+	:public iObject, public ePESParser, public Object
 {
 	DECLARE_REF(eDVBSubtitleParser);
 	subtitle_page *m_pages;
 	ePtr<iDVBPESReader> m_pes_reader;
 	ePtr<eConnection> m_read_connection;
 	pts_t m_show_time;
-	sigc::signal1<void,const eDVBSubtitlePage&> m_new_subtitle_page;
+	Signal1<void,const eDVBSubtitlePage&> m_new_subtitle_page;
 	int m_composition_page_id, m_ancillary_page_id;
 	bool m_seen_eod;
 	eSize m_display_size;
@@ -125,7 +125,7 @@
 	virtual ~eDVBSubtitleParser();
 	int start(int pid, int composition_page_id, int ancillary_page_id);
 	int stop();
-	void connectNewPage(const sigc::slot1<void, const eDVBSubtitlePage&> &slot, ePtr<eConnection> &connection);
+	void connectNewPage(const Slot1<void, const eDVBSubtitlePage&> &slot, ePtr<eConnection> &connection);
 private:
 	void subtitle_process_line(subtitle_region *region, subtitle_region_object *object, int line, uint8_t *data, int len);
 	int subtitle_process_pixel_data(subtitle_region *region, subtitle_region_object *object, int *linenr, int *linep, uint8_t *data);
--- enigma2/lib/dvb/teletext.cpp
+++ enigma2/lib/dvb/teletext.cpp
@@ -228,7 +228,7 @@
 		eDebug("[eDVBTeletextParser] failed to create teletext subtitle PES reader!");
 	else {
 		eDebug("[eDVBTeletextParser] created teletext subtitle PES reader!");
-		m_pes_reader->connectRead(sigc::mem_fun(*this, &eDVBTeletextParser::processData), m_read_connection);
+		m_pes_reader->connectRead(slot(*this, &eDVBTeletextParser::processData), m_read_connection);
 	}
 }
 
@@ -646,12 +646,12 @@
 		m_page_X &= 0xFF;
 }
 
-void eDVBTeletextParser::connectNewStream(const sigc::slot0<void> &slot, ePtr<eConnection> &connection)
+void eDVBTeletextParser::connectNewStream(const Slot0<void> &slot, ePtr<eConnection> &connection)
 {
 	connection = new eConnection(this, m_new_subtitle_stream.connect(slot));
 }
 
-void eDVBTeletextParser::connectNewPage(const sigc::slot1<void, const eDVBTeletextSubtitlePage&> &slot, ePtr<eConnection> &connection)
+void eDVBTeletextParser::connectNewPage(const Slot1<void, const eDVBTeletextSubtitlePage&> &slot, ePtr<eConnection> &connection)
 {
 	connection = new eConnection(this, m_new_subtitle_page.connect(slot));
 }
--- enigma2/lib/dvb/teletext.h
+++ enigma2/lib/dvb/teletext.h
@@ -33,7 +33,7 @@
 	void clear() { m_elements.clear(); }
 };
 
-class eDVBTeletextParser: public iObject, public ePESParser, public sigc::trackable
+class eDVBTeletextParser: public iObject, public ePESParser, public Object
 {
 	DECLARE_REF(eDVBTeletextParser);
 public:
@@ -44,8 +44,8 @@
 	int start(int pid);
 	void setPageAndMagazine(int page, int magazine, const char * lang);
 	void setMagazine(int magazine);
-	void connectNewStream(const sigc::slot0<void> &slot, ePtr<eConnection> &connection);
-	void connectNewPage(const sigc::slot1<void,const eDVBTeletextSubtitlePage &> &slot, ePtr<eConnection> &connection);
+	void connectNewStream(const Slot0<void> &slot, ePtr<eConnection> &connection);
+	void connectNewPage(const Slot1<void,const eDVBTeletextSubtitlePage &> &slot, ePtr<eConnection> &connection);
 	std::set<eDVBServicePMTHandler::subtitleStream> m_found_subtitle_pages;
 private:
 	std::map<int, unsigned int> m_modifications;
@@ -66,8 +66,8 @@
 
 	void addSubtitleString(int color, std::string string, int source_line);
 
-	sigc::signal0<void> m_new_subtitle_stream;
-	sigc::signal1<void,const eDVBTeletextSubtitlePage&> m_new_subtitle_page;
+	Signal0<void> m_new_subtitle_stream;
+	Signal1<void,const eDVBTeletextSubtitlePage&> m_new_subtitle_page;
 };
 
 #endif
--- enigma2/lib/dvb/tstools.cpp
+++ enigma2/lib/dvb/tstools.cpp
@@ -46,7 +46,7 @@
 	return 0;
 }
 
-RESULT eTSFileSectionReader::connectRead(const sigc::slot1<void,const uint8_t*> &r, ePtr<eConnection> &conn)
+RESULT eTSFileSectionReader::connectRead(const Slot1<void,const uint8_t*> &r, ePtr<eConnection> &conn)
 {
 	conn = new eConnection(this, read.connect(r));
 	return 0;
--- enigma2/lib/dvb/tstools.h
+++ enigma2/lib/dvb/tstools.h
@@ -15,12 +15,12 @@
 
 typedef long long pts_t;
 
-class eTSFileSectionReader: public iDVBSectionReader, public sigc::trackable
+class eTSFileSectionReader: public iDVBSectionReader, public Object
 {
 	DECLARE_REF(eTSFileSectionReader);
 	unsigned char sectionData[4096];
 	unsigned int sectionSize;
-	sigc::signal1<void, const uint8_t*> read;
+	Signal1<void, const uint8_t*> read;
 
 public:
 	eTSFileSectionReader(eMainloop *context);
@@ -29,7 +29,7 @@
 	RESULT setBufferSize(int size) { return 0; }
 	RESULT start(const eDVBSectionFilterMask &mask);
 	RESULT stop();
-	RESULT connectRead(const sigc::slot1<void,const uint8_t*> &read, ePtr<eConnection> &conn);
+	RESULT connectRead(const Slot1<void,const uint8_t*> &read, ePtr<eConnection> &conn);
 };
 
 class eDVBTSTools : public eDVBPMTParser
--- enigma2/lib/dvb_ci/dvbci.h
+++ enigma2/lib/dvb_ci/dvbci.h
@@ -79,7 +79,7 @@
 }
 #endif
 
-class eDVBCISlot: public iObject, public sigc::trackable
+class eDVBCISlot: public iObject, public Object
 {
 	friend class eDVBCIInterfaces;
 	DECLARE_REF(eDVBCISlot);
--- enigma2/lib/dvb_ci/dvbci_datetimemgr.cpp
+++ enigma2/lib/dvb_ci/dvbci_datetimemgr.cpp
@@ -7,7 +7,7 @@
 	m_timer(eTimer::create(eApp)), m_interval(0)
 {
 	//CONNECT(m_timer->timeout, eDVBCIDateTimeSession::sendDateTime);
-	m_timer->timeout.connect(sigc::mem_fun(*this, &eDVBCIDateTimeSession::sendDateTime));
+	m_timer->timeout.connect(SigC::slot(*this, &eDVBCIDateTimeSession::sendDateTime));
 }
 
 int eDVBCIDateTimeSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
--- enigma2/lib/dvb_ci/dvbci_datetimemgr.h
+++ enigma2/lib/dvb_ci/dvbci_datetimemgr.h
@@ -3,7 +3,7 @@
 
 #include <lib/dvb_ci/dvbci_session.h>
 
-class eDVBCIDateTimeSession: public eDVBCISession, public sigc::trackable
+class eDVBCIDateTimeSession: public eDVBCISession, public Object
 {
 	enum {
 		stateFinal=statePrivate, stateSendDateTime
--- enigma2/lib/gdi/compositing.h
+++ enigma2/lib/gdi/compositing.h
@@ -21,7 +21,7 @@
 	gContext m_context;
 };
 
-class gCompositingData: public sigc::trackable
+class gCompositingData: public Object
 {
 DECLARE_REF(gCompositingData);
 public:
--- enigma2/lib/gdi/grc.h
+++ enigma2/lib/gdi/grc.h
@@ -150,7 +150,7 @@
 #define MAXSIZE 2048
 
 		/* gRC is the singleton which controls the fifo and dispatches commands */
-class gRC: public iObject, public sigc::trackable
+class gRC: public iObject, public Object
 {
 	DECLARE_REF(gRC);
 	friend class gPainter;
@@ -187,7 +187,7 @@
 
 	void submit(const gOpcode &o);
 
-	sigc::signal0<void> notify;
+	Signal0<void> notify;
 
 	void setSpinnerDC(gDC *dc) { m_spinner_dc = dc; }
 	void setSpinnerOnOff(int onoff) { m_spinneronoff = onoff; }
--- enigma2/lib/gdi/picload.h
+++ enigma2/lib/gdi/picload.h
@@ -48,7 +48,7 @@
 };
 #endif
 
-class ePicLoad: public eMainloop, public eThread, public sigc::trackable, public iObject
+class ePicLoad: public eMainloop, public eThread, public Object, public iObject
 {
 	DECLARE_REF(ePicLoad);
 
--- enigma2/lib/gdi/sdl.h
+++ enigma2/lib/gdi/sdl.h
@@ -6,7 +6,7 @@
 
 #include <SDL.h>
 
-class gSDLDC: public gMainDC, public eThread, public sigc::trackable
+class gSDLDC: public gMainDC, public eThread, public Object
 {
 private:
 	SDL_Surface *m_screen;
--- enigma2/lib/gui/elistboxcontent.h
+++ enigma2/lib/gui/elistboxcontent.h
@@ -31,7 +31,7 @@
 	void cursorRestore();
 	int size();
 
-	RESULT connectItemChanged(const sigc::slot0<void> &itemChanged, ePtr<eConnection> &connection);
+	RESULT connectItemChanged(const Slot0<void> &itemChanged, ePtr<eConnection> &connection);
 
 	// void setOutputDevice ? (for allocating colors, ...) .. requires some work, though
 	void setSize(const eSize &size);
--- enigma2/lib/gui/esubtitle.h
+++ nigma2/lib/gui/esubtitle.h
@@ -40,7 +40,7 @@
 struct eDVBTeletextSubtitlePage;
 struct eDVBSubtitlePage;
 
-class eSubtitleWidget: public eWidget, public iSubtitleUser, public sigc::trackable
+class eSubtitleWidget: public eWidget, public iSubtitleUser, public Object
 {
 public:
 	eSubtitleWidget(eWidget *parent);
--- enigma2/lib/gui/evideo.cpp
+++ enigma2/lib/gui/evideo.cpp
@@ -15,7 +15,7 @@
 	if (!fullsizeTimer)
 	{
 		fullsizeTimer = eTimer::create(eApp);
-		fullsizeTimer->timeout.connect(sigc::bind(sigc::ptr_fun(&eVideoWidget::setFullsize), false));
+		fullsizeTimer->timeout.connect(bind(slot(&eVideoWidget::setFullsize), false));
 	}
 	parent->setPositionNotifyChild(1);
 }
--- enigma2/lib/gui/ewidgetdesktop.h
+++ enigma2/lib/gui/ewidgetdesktop.h
@@ -28,7 +28,7 @@
 	gRGB m_background_color;
 };
 
-class eWidgetDesktop: public sigc::trackable
+class eWidgetDesktop: public Object
 {
 public:
 	eWidgetDesktop(eSize screen);
--- enigma2/lib/mmi/mmi_ui.h
+++ enigma2/lib/mmi/mmi_ui.h
@@ -18,7 +18,7 @@
 };
 #endif
 
-class eMMI_UI: public sigc::trackable
+class eMMI_UI: public Object
 {
 	int m_max_slots;
 	virtual void stateChanged(int)=0;
--- enigma2/lib/nav/core.cpp
+++ enigma2/lib/nav/core.cpp
@@ -33,19 +33,19 @@
 	if (m_runningService)
 	{
 		m_runningService->setTarget(m_decoder);
-		m_runningService->connectEvent(sigc::mem_fun(*this, &eNavigation::serviceEvent), m_service_event_conn);
+		m_runningService->connectEvent(slot(*this, &eNavigation::serviceEvent), m_service_event_conn);
 		res = m_runningService->start();
 	}
 	return res;
 }
 
-RESULT eNavigation::connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &connection)
+RESULT eNavigation::connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection(this, m_event.connect(event));
 	return 0;
 }
 
-RESULT eNavigation::connectRecordEvent(const sigc::slot2<void,ePtr<iRecordableService>,int> &event, ePtr<eConnection> &connection)
+RESULT eNavigation::connectRecordEvent(const Slot2<void,ePtr<iRecordableService>,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection(this, m_record_event.connect(event));
 	return 0;
@@ -91,7 +91,7 @@
 		else
 		{
 			ePtr<eConnection> conn;
-			service->connectEvent(sigc::mem_fun(*this, &eNavigation::recordEvent), conn);
+			service->connectEvent(slot(*this, &eNavigation::recordEvent), conn);
 			m_recordings[service]=conn;
 			m_recordings_services[service]=ref;
 		}
--- enigma2/lib/nav/core.h
+++ enigma2/lib/nav/core.h
@@ -7,7 +7,7 @@
 #include <map>
 #include <set>
 
-class eNavigation: public iObject, public sigc::trackable
+class eNavigation: public iObject, public Object
 {
 	static eNavigation *instance;
 	DECLARE_REF(eNavigation);
@@ -15,7 +15,7 @@
 	ePtr<iServiceHandler> m_servicehandler;
 
 	ePtr<iPlayableService> m_runningService;
-	sigc::signal1<void,int> m_event;
+	Signal1<void,int> m_event;
 	ePtr<eConnection> m_service_event_conn;
 	void serviceEvent(iPlayableService* service, int event);
 
@@ -23,14 +23,14 @@
 	std::map<ePtr<iRecordableService>, eServiceReference, std::less<iRecordableService*> > m_recordings_services;
 	std::set<ePtr<iRecordableService>, std::less<iRecordableService*> > m_simulate_recordings;
 
-	sigc::signal2<void,ePtr<iRecordableService>,int> m_record_event;
+	Signal2<void,ePtr<iRecordableService>,int> m_record_event;
 	void recordEvent(iRecordableService* service, int event);
 public:
 
 	RESULT playService(const eServiceReference &service);
-	RESULT connectEvent(const sigc::slot1<void,int> &event, ePtr<eConnection> &connection);
-	RESULT connectRecordEvent(const sigc::slot2<void,ePtr<iRecordableService>,int> &event, ePtr<eConnection> &connection);
-/*	int connectServiceEvent(const sigc::slot1<void,iPlayableService*,int> &event, ePtr<eConnection> &connection); */
+	RESULT connectEvent(const Slot1<void,int> &event, ePtr<eConnection> &connection);
+	RESULT connectRecordEvent(const Slot2<void,ePtr<iRecordableService>,int> &event, ePtr<eConnection> &connection);
+/*	int connectServiceEvent(const Slot1<void,iPlayableService*,int> &event, ePtr<eConnection> &connection); */
 	RESULT getCurrentService(ePtr<iPlayableService> &service);
 	RESULT stopService(void);
 
--- enigma2/lib/nav/pcore.cpp
+++ enigma2/lib/nav/pcore.cpp
@@ -13,8 +13,8 @@
 	ASSERT(service_center);
 	m_core = new eNavigation(service_center, decoder);
 
-	m_core->connectEvent(sigc::mem_fun(*this, &pNavigation::navEvent), m_nav_event_connection);
-	m_core->connectRecordEvent(sigc::mem_fun(*this, &pNavigation::navRecordEvent), m_nav_record_event_connection);
+	m_core->connectEvent(slot(*this, &pNavigation::navEvent), m_nav_event_connection);
+	m_core->connectRecordEvent(slot(*this, &pNavigation::navRecordEvent), m_nav_record_event_connection);
 }
 
 RESULT pNavigation::playService(const eServiceReference &service)
--- enigma2/lib/nav/pcore.h
+++ enigma2/lib/nav/pcore.h
@@ -6,7 +6,7 @@
 
 /* a subset of eNavigation */
 
-class pNavigation: public iObject, public sigc::trackable
+class pNavigation: public iObject, public Object
 {
 	DECLARE_REF(pNavigation);
 public:
--- enigma2/lib/network/socket.h
+++ enigma2/lib/network/socket.h
@@ -15,7 +15,7 @@
 #include <libsig_comp.h>
 #include <lib/base/buffer.h>
 
-class eSocket: public sigc::trackable
+class eSocket: public Object
 {
 private:
 	int issocket;
@@ -54,12 +54,12 @@
 			Listening, Connection, Closing };
 	int state();
 
-	sigc::signal0<void> connectionClosed_;
-	sigc::signal0<void> connected_;
-	sigc::signal0<void> readyRead_;
-	sigc::signal0<void> hangup;
-	sigc::signal1<void,int> bytesWritten_;
-	sigc::signal1<void,int> error_;
+	Signal0<void> connectionClosed_;
+	Signal0<void> connected_;
+	Signal0<void> readyRead_;
+	Signal0<void> hangup;
+	Signal1<void,int> bytesWritten_;
+	Signal1<void,int> error_;
 };
 
 class eUnixDomainSocket: public eSocket
--- enigma2/lib/python/Plugins/Extensions/SocketMMI/src/socket_mmi.h
+++ nigma2/lib/python/Plugins/Extensions/SocketMMI/src/socket_mmi.h
@@ -11,7 +11,7 @@
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <sys/un.h>
-class eSocketMMIHandler: public sigc::trackable
+class eSocketMMIHandler: public Object
 {
 	eIOBuffer buffer;
 	int listenfd, connfd, clilen;
@@ -24,7 +24,7 @@
 	char *name;
 public:
 	const char *getName() const { return name; }
-	sigc::signal4<int, int, const unsigned char*, const void *, int> mmi_progress;
+	Signal4<int, int, const unsigned char*, const void *, int> mmi_progress;
 	int send_to_mmisock( void *, size_t );
 	bool connected() { return !!connsn; }
 	eSocketMMIHandler();
--- enigma2/lib/python/connections.h
+++ enigma2/lib/python/connections.h
@@ -36,7 +36,7 @@
 }
 
 template <class R>
-class PSignal0: public PSignal, public sigc::signal0<R>
+class PSignal0: public PSignal, public Signal0<R>
 {
 public:
 	R operator()()
@@ -47,12 +47,12 @@
 			callPython(pArgs);
 			Org_Py_DECREF(pArgs);
 		}
-		return sigc::signal0<R>::operator()();
+		return Signal0<R>::operator()();
 	}
 };
 
 template <class R, class V0>
-class PSignal1: public PSignal, public sigc::signal1<R,V0>
+class PSignal1: public PSignal, public Signal1<R,V0>
 {
 public:
 	R operator()(V0 a0)
@@ -64,12 +64,12 @@
 			callPython(pArgs);
 			Org_Py_DECREF(pArgs);
 		}
-		return sigc::signal1<R,V0>::operator()(a0);
+		return Signal1<R,V0>::operator()(a0);
 	}
 };
 
 template <class R, class V0, class V1>
-class PSignal2: public PSignal, public sigc::signal2<R,V0,V1>
+class PSignal2: public PSignal, public Signal2<R,V0,V1>
 {
 public:
 	R operator()(V0 a0, V1 a1)
@@ -82,12 +82,12 @@
 			callPython(pArgs);
 			Org_Py_DECREF(pArgs);
 		}
-		return sigc::signal2<R,V0,V1>::operator()(a0, a1);
+		return Signal2<R,V0,V1>::operator()(a0, a1);
 	}
 };
 
 template <class R, class V0, class V1, class V2>
-class PSignal3: public PSignal, public sigc::signal3<R,V0,V1,V2>
+class PSignal3: public PSignal, public Signal3<R,V0,V1,V2>
 {
 public:
 	R operator()(V0 a0, V1 a1, V2 a2)
@@ -101,7 +101,7 @@
 			callPython(pArgs);
 			Org_Py_DECREF(pArgs);
 		}
-		return sigc::signal3<R,V0,V1,V2>::operator()(a0, a1, a2);
+		return Signal3<R,V0,V1,V2>::operator()(a0, a1, a2);
 	}
 };
 
--- enigma2/lib/service/iservice.h
+++ enigma2/lib/service/iservice.h
@@ -945,7 +945,7 @@
 	friend class iServiceHandler;
 public:
 #ifndef SWIG
-	virtual RESULT connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)=0;
+	virtual RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)=0;
 #endif
 	virtual RESULT start()=0;
 	virtual RESULT stop()=0;
@@ -1012,7 +1012,7 @@
 #endif
 public:
 #ifndef SWIG
-	virtual RESULT connectEvent(const sigc::slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection)=0;
+	virtual RESULT connectEvent(const Slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection)=0;
 #endif
 	virtual SWIG_VOID(RESULT) getError(int &SWIG_OUTPUT)=0;
 	virtual RESULT prepare(const char *filename, time_t begTime=-1, time_t endTime=-1, int eit_event_id=-1, const char *name=0, const char *descr=0, const char *tags=0, bool descramble = true, bool recordecm = false, int packetsize = 188)=0;
--- enigma2/lib/service/servicedvb.cpp
+++ enigma2/lib/service/servicedvb.cpp
@@ -1447,7 +1447,7 @@
 	return 0;
 }
 
-RESULT eDVBServicePlay::connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eDVBServicePlay::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
 	return 0;
@@ -2198,7 +2198,7 @@
 			if (!h.getDataDemux(data_demux))
 			{
 				m_rds_decoder = new eDVBRdsDecoder(data_demux, different_pid);
-				m_rds_decoder->connectEvent(sigc::mem_fun(*this, &eDVBServicePlay::rdsDecoderEvent), m_rds_decoder_event_connection);
+				m_rds_decoder->connectEvent(slot(*this, &eDVBServicePlay::rdsDecoderEvent), m_rds_decoder_event_connection);
 				m_rds_decoder->start(rdsPid);
 			}
 		}
@@ -2875,7 +2875,7 @@
 		{
 			m_decode_demux->getMPEGDecoder(m_decoder, m_decoder_index);
 			if (m_decoder)
-				m_decoder->connectVideoEvent(sigc::mem_fun(*this, &eDVBServicePlay::video_event), m_video_event_connection);
+				m_decoder->connectVideoEvent(slot(*this, &eDVBServicePlay::video_event), m_video_event_connection);
 		}
 		if (m_cue)
 			m_cue->setDecodingDemux(m_decode_demux, m_decoder);
@@ -2964,10 +2964,10 @@
 		if (mustPlay && m_decode_demux && m_decoder_index == 0)
 		{
 			m_teletext_parser = new eDVBTeletextParser(m_decode_demux);
-			m_teletext_parser->connectNewStream(sigc::mem_fun(*this, &eDVBServicePlay::newSubtitleStream), m_new_subtitle_stream_connection);
-			m_teletext_parser->connectNewPage(sigc::mem_fun(*this, &eDVBServicePlay::newSubtitlePage), m_new_subtitle_page_connection);
+			m_teletext_parser->connectNewStream(slot(*this, &eDVBServicePlay::newSubtitleStream), m_new_subtitle_stream_connection);
+			m_teletext_parser->connectNewPage(slot(*this, &eDVBServicePlay::newSubtitlePage), m_new_subtitle_page_connection);
 			m_subtitle_parser = new eDVBSubtitleParser(m_decode_demux);
-			m_subtitle_parser->connectNewPage(sigc::mem_fun(*this, &eDVBServicePlay::newDVBSubtitlePage), m_new_dvb_subtitle_page_connection);
+			m_subtitle_parser->connectNewPage(slot(*this, &eDVBServicePlay::newDVBSubtitlePage), m_new_dvb_subtitle_page_connection);
 			if (m_timeshift_changed)
 			{
 				struct SubtitleTrack track;
--- enigma2/lib/service/servicedvb.h
+++ enigma2/lib/service/servicedvb.h
@@ -84,7 +84,7 @@
 
 class eDVBServicePlay: public eDVBServiceBase,
 		public iPlayableService, public iPauseableService,
-		public iSeekableService, public sigc::trackable, public iServiceInformation,
+		public iSeekableService, public Object, public iServiceInformation,
 		public iAudioTrackSelection, public iAudioChannelSelection,
 		public iSubserviceList, public iTimeshiftService,
 		public iCueSheet, public iSubtitleOutput, public iAudioDelay,
@@ -96,7 +96,7 @@
 	virtual ~eDVBServicePlay();
 
 		// iPlayableService
-	RESULT connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
 	RESULT start();
 	RESULT stop();
 	RESULT setTarget(int target, bool noaudio);
@@ -221,7 +221,7 @@
 
 	void serviceEvent(int event);
 	void serviceEventTimeshift(int event);
-	sigc::signal2<void,iPlayableService*,int> m_event;
+	Signal2<void,iPlayableService*,int> m_event;
 
 	bool m_is_stream;
 
--- enigma2/lib/service/servicedvbrecord.cpp
+++ enigma2/lib/service/servicedvbrecord.cpp
@@ -355,7 +355,7 @@
 		}
 		m_record->setTargetFD(fd);
 		m_record->setTargetFilename(m_filename);
-		m_record->connectEvent(sigc::mem_fun(*this, &eDVBServiceRecord::recordEvent), m_con_record_event);
+		m_record->connectEvent(slot(*this, &eDVBServiceRecord::recordEvent), m_con_record_event);
 
 		m_target_fd = fd;
 	}
@@ -539,7 +539,7 @@
 	return 0;
 }
 
-RESULT eDVBServiceRecord::connectEvent(const sigc::slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eDVBServiceRecord::connectEvent(const Slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iRecordableService*)this, m_event.connect(event));
 	return 0;
--- enigma2/lib/service/servicedvbrecord.h
+++ enigma2/lib/service/servicedvbrecord.h
@@ -14,11 +14,11 @@
 	public iRecordableService,
 	public iStreamableService,
 	public iSubserviceList,
-	public sigc::trackable
+	public Object
 {
 	DECLARE_REF(eDVBServiceRecord);
 public:
-	RESULT connectEvent(const sigc::slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection);
 	RESULT prepare(const char *filename, time_t begTime, time_t endTime, int eit_event_id, const char *name, const char *descr, const char *tags, bool descramble, bool recordecm, int packetsize = 188);
 	RESULT prepareStreaming(bool descramble, bool includeecm);
 	RESULT start(bool simulate=false);
@@ -68,7 +68,7 @@
 
 			/* events */
 	void serviceEvent(int event);
-	sigc::signal2<void,iRecordableService*,int> m_event;
+	Signal2<void,iRecordableService*,int> m_event;
 
 			/* recorder events */
 	void recordEvent(int event);
--- enigma2/lib/service/servicedvbstream.cpp
+++ enigma2/lib/service/servicedvbstream.cpp
@@ -143,7 +143,7 @@
 			return -1;
 		}
 		m_record->setTargetFD(m_target_fd);
-		m_record->connectEvent(sigc::mem_fun(*this, &eDVBServiceStream::recordEvent), m_con_record_event);
+		m_record->connectEvent(slot(*this, &eDVBServiceStream::recordEvent), m_con_record_event);
 	}
 
 	eDebug("[eDVBServiceStream] start streaming...");
--- enigma2/lib/service/servicedvbstream.h
+++ enigma2/lib/service/servicedvbstream.h
@@ -9,7 +9,7 @@
 
 #include <lib/service/servicedvb.h>
 
-class eDVBServiceStream: public eDVBServiceBase, public sigc::trackable
+class eDVBServiceStream: public eDVBServiceBase, public Object
 {
 	DECLARE_REF(eDVBServiceStream);
 public:
--- enigma2/lib/service/servicedvd.cpp
+++ enigma2/lib/service/servicedvd.cpp
@@ -438,7 +438,7 @@
 	disableSubtitles();
 }
 
-RESULT eServiceDVD::connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eServiceDVD::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
 	return 0;
--- enigma2/lib/service/servicedvd.h
+++ enigma2/lib/service/servicedvd.h
@@ -58,7 +58,7 @@
 };
 
 class eServiceDVD: public iPlayableService, public iPauseableService, public iSeekableService, public iAudioTrackSelection,
-	public iServiceInformation, public iSubtitleOutput, public iServiceKeys, public iCueSheet, public eThread, public sigc::trackable
+	public iServiceInformation, public iSubtitleOutput, public iServiceKeys, public iCueSheet, public eThread, public Object
 {
 	friend class eServiceFactoryDVD;
 	DECLARE_REF(eServiceDVD);
@@ -79,7 +79,7 @@
 	void setQpipMode(bool value, bool audio) { }
 
 		// iPlayableService
-	RESULT connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
 	RESULT start();
 	RESULT stop();
 	RESULT info(ePtr<iServiceInformation> &ptr);
@@ -142,7 +142,7 @@
 
 	eServiceReference m_ref;
 
-	sigc::signal2<void,iPlayableService*,int> m_event;
+	Signal2<void,iPlayableService*,int> m_event;
 
 	struct ddvd *m_ddvdconfig;
 	ePtr<gPixmap> m_pixmap;
--- enigma2/lib/service/servicehdmi.cpp
+++ enigma2/lib/service/servicehdmi.cpp
@@ -114,7 +114,7 @@
 
 DEFINE_REF(eServiceHDMI);
 
-RESULT eServiceHDMI::connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eServiceHDMI::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
 	return 0;
@@ -320,7 +320,7 @@
 	return 0;
 }
 
-RESULT eServiceHDMIRecord::connectEvent(const sigc::slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eServiceHDMIRecord::connectEvent(const Slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iRecordableService*)this, m_event.connect(event));
 	return 0;
--- enigma2/lib/service/servicehdmi.h
+++ enigma2/lib/service/servicehdmi.h
@@ -37,13 +37,13 @@
 	long long getFileSize(const eServiceReference &ref);
 };
 
-class eServiceHDMI: public iPlayableService, public iServiceInformation, public sigc::trackable
+class eServiceHDMI: public iPlayableService, public iServiceInformation, public Object
 {
 	DECLARE_REF(eServiceHDMI);
 public:
 	virtual ~eServiceHDMI();
 
-	RESULT connectEvent(const sigc::slot2<void, iPlayableService*, int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void, iPlayableService*, int> &event, ePtr<eConnection> &connection);
 	RESULT start();
 	RESULT stop();
 	RESULT setTarget(int target, bool noaudio);
@@ -76,19 +76,19 @@
 private:
 	friend class eServiceFactoryHDMI;
 	eServiceHDMI(eServiceReference ref);
-	sigc::signal2<void,iPlayableService*, int> m_event;
+	Signal2<void,iPlayableService*, int> m_event;
 	eServiceReference m_ref;
 	int m_decoder_index;
 	bool m_noaudio;
 	ePtr<iTSMPEGDecoder> m_decoder;
 };
 
-class eServiceHDMIRecord: public eDVBServiceBase, public iRecordableService, public sigc::trackable
+class eServiceHDMIRecord: public eDVBServiceBase, public iRecordableService, public Object
 {
 	DECLARE_REF(eServiceHDMIRecord);
 public:
 	eServiceHDMIRecord(const eServiceReference &ref);
-	RESULT connectEvent(const sigc::slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection);
 	RESULT prepare(const char *filename, time_t begTime, time_t endTime, int eit_event_id, const char *name, const char *descr, const char *tags, bool descramble, bool recordecm, int packetsize);
 	RESULT prepareStreaming(bool descramble = true, bool includeecm = false);
 	RESULT start(bool simulate=false);
@@ -116,7 +116,7 @@
 	int doRecord();
 
 	/* events */
-	sigc::signal2<void,iRecordableService*,int> m_event;
+	Signal2<void,iRecordableService*,int> m_event;
 
 	/* recorder events */
 	void recordEvent(int event);
--- enigma2/lib/service/servicemp3.cpp
+++ enigma2/lib/service/servicemp3.cpp
@@ -1037,7 +1037,7 @@
 #ifdef ENABLE_MEDIAFWGSTREAMER
 DEFINE_REF(GstMessageContainer);
 #endif
-RESULT eServiceMP3::connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eServiceMP3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
 #ifdef ENABLE_MEDIAFWGSTREAMER
--- enigma2/lib/service/servicemp3.h
+++ enigma2/lib/service/servicemp3.h
@@ -139,14 +139,14 @@
 
 class eServiceMP3: public iPlayableService, public iPauseableService,
 	public iServiceInformation, public iSeekableService, public iAudioTrackSelection, public iAudioChannelSelection,
-	public iSubtitleOutput, public iStreamedService, public iAudioDelay, public sigc::trackable, public iCueSheet
+	public iSubtitleOutput, public iStreamedService, public iAudioDelay, public Object, public iCueSheet
 {
 	DECLARE_REF(eServiceMP3);
 public:
 	virtual ~eServiceMP3();
 
 		// iPlayableService
-	RESULT connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
 	RESULT start();
 	RESULT stop();
 
@@ -378,7 +378,7 @@
 	errorInfo m_errorInfo;
 	std::string m_download_buffer_path;
 	eServiceMP3(eServiceReference ref);
-	sigc::signal2<void,iPlayableService*,int> m_event;
+	Signal2<void,iPlayableService*,int> m_event;
 	enum
 	{
 		stIdle, stRunning, stStopped,
--- enigma2/lib/service/servicemp3record.cpp
+++ enigma2/lib/service/servicemp3record.cpp
@@ -491,7 +491,7 @@
 	return -1;
 }
 
-RESULT eServiceMP3Record::connectEvent(const sigc::slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eServiceMP3Record::connectEvent(const Slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iRecordableService*)this, m_event.connect(event));
 	return 0;
--- enigma2/lib/service/servicemp3record.h
+++ enigma2/lib/service/servicemp3record.h
@@ -8,11 +8,11 @@
 
 class eServiceMP3Record:
 	public iRecordableService,
-	public sigc::trackable
+	public Object
 {
 	DECLARE_REF(eServiceMP3Record);
 public:
-	RESULT connectEvent(const sigc::slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iRecordableService*,int> &event, ePtr<eConnection> &connection);
 	RESULT prepare(const char *filename, time_t begTime, time_t endTime, int eit_event_id, const char *name, const char *descr, const char *tags, bool descramble, bool recordecm, int packetsize);
 	RESULT prepareStreaming(bool descramble, bool includeecm);
 	RESULT start(bool simulate=false);
@@ -54,7 +54,7 @@
 	static gboolean handleAutoPlugCont(GstElement *bin, GstPad *pad, GstCaps *caps, gpointer user_data);
 
 			/* events */
-	sigc::signal2<void,iRecordableService*,int> m_event;
+	Signal2<void,iRecordableService*,int> m_event;
 };
 
 #endif
--- enigma2/lib/service/servicets.cpp
+++ enigma2/lib/service/servicets.cpp
@@ -219,7 +219,7 @@
 	return fd;
 }
 
-RESULT eServiceTS::connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eServiceTS::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
 	return 0;
--- enigma2/lib/service/servicets.h
+++ enigma2/lib/service/servicets.h
@@ -41,14 +41,14 @@
 class eStreamThread;
 class eServiceTS: public iPlayableService, public iPauseableService,
 	public iServiceInformation, public iSeekableService,
-	public iAudioTrackSelection, public iAudioChannelSelection, public sigc::trackable
+	public iAudioTrackSelection, public iAudioChannelSelection, public Object
 {
 DECLARE_REF(eServiceTS);
 public:
 	virtual ~eServiceTS();
 
 	// iPlayableService
-	RESULT connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
 	RESULT start();
 	RESULT stop();
 	RESULT pause(ePtr<iPauseableService> &ptr);
@@ -113,13 +113,13 @@
 	eServiceTS(const eServiceReference &url);
 	int openHttpConnection(std::string url);
 
-	sigc::signal2<void,iPlayableService*,int> m_event;
+	Signal2<void,iPlayableService*,int> m_event;
 	eFixedMessagePump<int> m_pump;
 	void recv_event(int evt);
 	void setAudioPid(int pid, int type);
 };
 
-class eStreamThread: public eThread, public sigc::trackable {
+class eStreamThread: public eThread, public Object {
 DECLARE_REF(eStreamThread);
 public:
 	eStreamThread();
@@ -134,7 +134,7 @@
 	RESULT getAudioInfo(ePtr<TSAudioInfo> &ptr);
 
 	enum { evtEOS, evtSOS, evtReadError, evtWriteError, evtUser, evtStreamInfo };
-	sigc::signal1<void,int> m_event;
+	Signal1<void,int> m_event;
 private:
 	bool m_stop;
 	bool m_running;
--- enigma2/lib/service/servicewebts.cpp
+++ enigma2/lib/service/servicewebts.cpp
@@ -292,7 +292,7 @@
 	return fd;
 }
 
-RESULT eServiceWebTS::connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eServiceWebTS::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
 	return 0;
--- enigma2/lib/service/servicewebts.h
+++ enigma2/lib/service/servicewebts.h
@@ -72,14 +72,14 @@
 class eStreamThreadWeb;
 class eServiceWebTS: public iPlayableService, public iPauseableService,
 	public iServiceInformation, public iSeekableService,
-	public iAudioTrackSelection, public iAudioChannelSelection, public sigc::trackable
+	public iAudioTrackSelection, public iAudioChannelSelection, public Object
 {
 DECLARE_REF(eServiceWebTS);
 public:
 	virtual ~eServiceWebTS();
 
 	// iPlayableService
-	RESULT connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
 	RESULT start();
 	RESULT stop();
 	RESULT pause(ePtr<iPauseableService> &ptr);
@@ -146,13 +146,13 @@
 	eServiceWebTS(const eServiceReference &url);
 	int openHttpConnection(std::string url);
 
-	sigc::signal2<void,iPlayableService*,int> m_event;
+	Signal2<void,iPlayableService*,int> m_event;
 	eFixedMessagePump<int> m_pump;
 	void recv_event(int evt);
 	void setAudioPid(int pid, int type);
 };
 
-class eStreamThreadWeb: public eThread, public sigc::trackable {
+class eStreamThreadWeb: public eThread, public Object {
 DECLARE_REF(eStreamThreadWeb);
 public:
 	eStreamThreadWeb();
@@ -167,7 +167,7 @@
 	RESULT getAudioInfo(ePtr<TSAudioInfoWeb> &ptr);
 
 	enum { evtEOS, evtSOS, evtReadError, evtWriteError, evtUser, evtStreamInfo };
-	sigc::signal1<void,int> m_event;
+	Signal1<void,int> m_event;
 private:
 	bool m_stop;
 	bool m_running;
--- enigma2/lib/service/servicexine.cpp
+++ enigma2/lib/service/servicexine.cpp
@@ -164,7 +164,7 @@
 	}
 }
 
-RESULT eServiceXine::connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+RESULT eServiceXine::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
 	return 0;
--- enigma2/lib/service/servicexine.h
+++ enigma2/lib/service/servicexine.h
@@ -42,14 +42,14 @@
 typedef struct _GstElement GstElement;
 
 class eServiceXine: public iPlayableService, public iPauseableService,
-	public iServiceInformation, public iSeekableService, public sigc::trackable
+	public iServiceInformation, public iSeekableService, public Object
 {
 	DECLARE_REF(eServiceXine);
 public:
 	virtual ~eServiceXine();
 
 		// iPlayableService
-	RESULT connectEvent(const sigc::slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
 	RESULT start();
 	RESULT stop();
 
@@ -94,7 +94,7 @@
 	friend class eServiceFactoryXine;
 	std::string m_filename;
 	eServiceXine(const char *filename);
-	sigc::signal2<void,iPlayableService*,int> m_event;
+	Signal2<void,iPlayableService*,int> m_event;
 
 	xine_stream_t *stream;
 	xine_video_port_t *vo_port;
--- enigma2/main/enigma.cpp
+++ enigma2/main/enigma.cpp
@@ -110,7 +110,7 @@
 /* Defined in eerror.cpp */
 void setDebugTime(bool enable);
 
-class eMain: public eApplication, public sigc::trackable
+class eMain: public eApplication, public Object
 {
 	eInit init;
 	ePythonConfigQuery config;
@@ -296,7 +296,7 @@
 
 	gRC::getInstance()->setSpinnerDC(my_dc);
 
-	eRCInput::getInstance()->keyEvent.connect(sigc::ptr_fun(&keyEvent));
+	eRCInput::getInstance()->keyEvent.connect(slot(&keyEvent));
 
 #if defined(__sh__) // initialise the vfd class
 	evfd * vfd = new evfd;

