--- a/configure.ac.org
+++ b/configure.ac
@@ -185,42 +185,42 @@
 LIBEVENT_MBEDTLS
 
 dnl Checks for header files.
-AC_CHECK_HEADERS([
-  arpa/inet.h
-  fcntl.h
-  ifaddrs.h
-  mach/mach_time.h
-  mach/mach.h
-  netdb.h
-  netinet/in.h
-  netinet/in6.h
-  netinet/tcp.h
-  sys/un.h
-  poll.h
-  port.h
-  stdarg.h
-  stddef.h
-  sys/devpoll.h
-  sys/epoll.h
-  sys/event.h
-  sys/eventfd.h
-  sys/ioctl.h
-  sys/mman.h
-  sys/param.h
-  sys/queue.h
-  sys/resource.h
-  sys/select.h
-  sys/sendfile.h
-  sys/socket.h
-  sys/stat.h
-  sys/time.h
-  sys/timerfd.h
-  sys/uio.h
-  sys/wait.h
-  sys/random.h
-  errno.h
-  afunix.h
-])
+AC_CHECK_HEADERS([ \
+  arpa/inet.h \
+  fcntl.h \
+  ifaddrs.h \
+  mach/mach_time.h \ 
+  mach/mach.h \
+  netdb.h \
+  netinet/in.h \ 
+  netinet/in6.h \
+  netinet/tcp.h \
+  sys/un.h \
+  poll.h \
+  port.h \ 
+  stdarg.h \ 
+  stddef.h \ 
+  sys/devpoll.h \ 
+  sys/epoll.h \ 
+  sys/event.h \ 
+  sys/eventfd.h \ 
+  sys/ioctl.h \ 
+  sys/mman.h \ 
+  sys/param.h \ 
+  sys/queue.h \ 
+  sys/resource.h \ 
+  sys/select.h \ 
+  sys/sendfile.h \ 
+  sys/socket.h \ 
+  sys/stat.h \ 
+  sys/time.h \ 
+  sys/timerfd.h \ 
+  sys/uio.h \ 
+  sys/wait.h \ 
+  sys/random.h \ 
+  errno.h \ 
+  afunix.h \ 
+]) 
 
 case "${host_os}" in
     linux*) ;;
@@ -325,41 +325,41 @@
 AC_HEADER_TIME

 dnl Checks for library functions.
-AC_CHECK_FUNCS([
-  accept4
-  arc4random
-  arc4random_buf
-  arc4random_addrandom
-  eventfd
-  epoll_create1
-  fcntl
-  getegid
-  geteuid
-  getifaddrs
-  gettimeofday
-  issetugid
-  mach_absolute_time
-  mmap
-  nanosleep
-  pipe
-  pipe2
-  putenv
-  sendfile
-  setenv
-  setrlimit
-  sigaction
-  signal
-  strsignal
-  strlcpy
-  strsep
-  strtok_r
-  strtoll
-  sysctl
-  timerfd_create
-  umask
-  unsetenv
-  usleep
-  getrandom
+AC_CHECK_FUNCS([ \
+  accept4 \ 
+  arc4random \ 
+  arc4random_buf \ 
+  arc4random_addrandom \ 
+  eventfd \ 
+  epoll_create1 \ 
+  fcntl \ 
+  getegid \ 
+  geteuid \ 
+  getifaddrs \ 
+  gettimeofday \ 
+  issetugid \ 
+  mach_absolute_time \ 
+  mmap \ 
+  nanosleep \ 
+  pipe \ 
+  pipe2 \ 
+  putenv \ 
+  sendfile \ 
+  setenv \ 
+  setrlimit \ 
+  sigaction \ 
+  signal \ 
+  strsignal \ 
+  strlcpy \ 
+  strsep \ 
+  strtok_r \ 
+  strtoll \ 
+  sysctl \ 
+  timerfd_create \ 
+  umask \ 
+  unsetenv \ 
+  usleep \ 
+  getrandom \ 
 ])
 
 AS_IF([test x$bwin32 = xtrue],
--- a/event.c.org
+++ b/event.c
@@ -926,7 +926,7 @@
 
 	if (n_deleted)
 		event_debug(("%s: "EV_SIZE_FMT" events were still set in base",
-			__func__, n_deleted));
+			__func__, (long unsigned int)n_deleted));
 
 	while (LIST_FIRST(&base->once_events)) {
 		struct event_once *eonce = LIST_FIRST(&base->once_events);
--- a/test/regress_http.c.org
+++ b/test/regress_http.c
@@ -5473,7 +5453,7 @@
 	    "POST /postit HTTP/1.1\r\n"
 	    "Host: somehost\r\n"
 	    "Content-Length: " EV_SIZE_FMT "\r\n"
-	    "\r\n", strlen(POST_DATA));
+	    "\r\n", (long unsigned int)strlen(POST_DATA));
 
 	tv.tv_usec = 200000;
 	event_base_once(data->base, -1, EV_TIMEOUT, http_add_output_buffer, out, &tv);
--- a/test/bench.c.org
+++ b/test/bench.c
@@ -131,7 +131,7 @@
 
 		if (xcount != count)
 			fprintf(stderr, "Xcount: %d, Rcount: " EV_SSIZE_FMT "\n",
-				xcount, count);
+				xcount, (long int)count);
 	}
 
 	evutil_timersub(&te, &ts, &te);
--- a/test/regress_ssl.c.org
+++ b/test/regress_ssl.c
@@ -580,9 +580,9 @@
 		"out: " EV_SIZE_FMT ", "
 		"got: " EV_SIZE_FMT "",
 		ctx->server ? "server" : "client", bev,
-		evbuffer_get_length(in),
-		evbuffer_get_length(out),
-		ctx->get));
+		(long unsigned int)evbuffer_get_length(in),
+		(long unsigned int)evbuffer_get_length(out),
+		(long unsigned int)ctx->get));
 
 	evbuffer_add_buffer_reference(out, ctx->data);
 }
@@ -673,10 +673,10 @@
 		"wm_high = " EV_SIZE_FMT ", "
 		"limit = " EV_SIZE_FMT ", "
 		"to_read: " EV_SIZE_FMT "",
-		payload_len,
-		wm_high,
-		server.limit,
-		server.to_read));
+		(long unsigned int)payload_len,
+		(long unsigned int)wm_high,
+		(long unsigned int)server.limit,
+		(long unsigned int)server.to_read));
 
 	listener = evconnlistener_new_bind(base, wm_acceptcb, &server,
 	    LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE,

