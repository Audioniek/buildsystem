--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -389,6 +389,43 @@
 #endif
 #endif
 
+	{
+		char sda1_org_command_line[] = "console=ttyAS0,115200 root=/dev/sda1/root.img";
+		char sda1_new_command_line[] = "console=ttyAS0,115200 root=/dev/sda1/root.img rootfstype=ext3 rw init=/bin/devinit coprocessor_mem=4m@0x40000000,4m@0x40400000 printk=1 console_loglevel=7 rootdelay=3 nwhwconf=device:eth0,hwaddr:";
+		char sdb1_org_command_line[] = "console=ttyAS0,115200 root=/dev/sdb1/root.img";
+		char sdb1_new_command_line[] = "console=ttyAS0,115200 root=/dev/sdb1/root.img rootfstype=ext3 rw init=/bin/devinit coprocessor_mem=4m@0x40000000,4m@0x40400000 printk=1 console_loglevel=7 rootdelay=3 nwhwconf=device:eth0,hwaddr:";
+		char mac[] = "00:25:ff:12:34:56";
+		int command_line_len = strlen(command_line);
+		int sda1_org_command_line_len = strlen(sda1_org_command_line);
+		int sdb1_org_command_line_len = strlen(sdb1_org_command_line);
+		int i;
+
+		for (i = 0; i < (command_line_len - 7); i++)
+		{
+			if (!strncmp(command_line + i, "ethaddr", 7))
+			{
+				strlcpy(mac, command_line + i + 8, sizeof(mac));
+				break;
+			}
+			if (!strncmp(command_line + i, "hwaddr", 6))
+			{
+				strlcpy(mac, command_line + i + 7, sizeof(mac));
+				break;
+			}
+		}
+		// boot from /dev/sda1
+		if (command_line_len >= sda1_org_command_line_len && !strncmp(command_line, sda1_org_command_line, sda1_org_command_line_len))
+		{
+			strlcpy(command_line, sda1_new_command_line, sizeof(sda1_new_command_line));
+		}
+		// boot from /dev/sda1
+		if (command_line_len >= sdb1_org_command_line_len && !strncmp(command_line, sdb1_org_command_line, sdb1_org_command_line_len))
+		{
+			strlcpy(command_line, sdb1_new_command_line, sizeof(sdb1_new_command_line));
+		}
+		strlcat(command_line, mac, sizeof(command_line));
+	}
+
 	/* Save unparsed command line copy for /proc/cmdline */
 	memcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = command_line;
--- a/arch/sh/boards/mach-hdk7105/setup.c.org
+++ b/arch/sh/boards/mach-hdk7105/setup.c
@@ -1,327 +1,432 @@
 /*
  * arch/sh/boards/mach-hdk7105/setup.c
  *
+ * Modified for use on Opticum HD (TS) 9600 PRIMA by Audioniek.
+ *
+ * Original code by:
  * Copyright (C) 2008 STMicroelectronics Limited
  * Author: Stuart Menefy (stuart.menefy@st.com)
  *
  * May be copied or modified under the terms of the GNU General Public
  * License.  See linux/COPYING for more information.
  *
- * STMicroelectronics HDK7105-SDK support.
+ * Opticum HD (TS) 9600 PRIMA (HDK7105) support.
  */
 
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/io.h>
-#include <linux/leds.h>
-#include <linux/lirc.h>
 #include <linux/gpio.h>
 #include <linux/phy.h>
-#include <linux/tm1668.h>
 #include <linux/stm/platform.h>
 #include <linux/stm/stx7105.h>
 #include <linux/stm/pci-glue.h>
-#include <linux/stm/emi.h>
-#include <linux/stm/nand.h>
-#include <linux/stm/nand_devices.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/physmap.h>
-#include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/flash.h>
 #include <asm/irq-ilc.h>
+#include <linux/stm/pio.h>
+#include <linux/bpa2.h>
+
+#define OPT9600PRIMA_PIO_PHY_RESET stm_gpio(15, 5)
+#define OPT9600PRIMA_PIO_FLASH_WP  stm_gpio(6, 4)
+
+#if 0  // PIO setup (empirically determined)
+ I = input (PU)
+ b = bidir
+ o = output
+ i = input
+ O = alt.output
+ B = alt.bidir
+
+PIO0.0 (B) = SCI0.TXD (=SCI0.IOUC)
+PIO0.1 (I) = SCI0.RXD (=SCI0.IOUC)
+PIO0.2 (I) = SCI0.EXTCLKIN
+PIO0.3 (o) = SCI0.CLKOUT (=SCI0.XTA1)
+PIO0.4 (o) = SCI0.RESET (=SCI0.RSTIN)
+PIO0.5 (o) = SCI0.CONDVCC (=SCI0.CMDVCC#)
+PIO0.6 (o) = SCI0.VSEL (=SCI0.5V/3V3#)
+PIO0.7 (i) = SCI0.DETECT (=SCI0.OFF#)
+
+PIO1.0 (B) = SCI1.TXD (=SCI1.IOUC)
+PIO1.1 (I) = SCI1.RXD (=SCI1.IOUC)
+PIO1.2 (I) = SCI1.EXTCLKIN
+PIO1.3 (o) = SCI1.CLKOUT (=SCI1.XTA1)
+PIO1.4 (o) = SCI1.RESET (=SCI1.RSTIN)
+PIO1.5 (o) = SCI1.CONDVCC (=SCI1.CMDVCC#)
+PIO1.6 (o) = SCI1.VSEL (=SCI1.5V/3V3#)
+PIO1.7 (i) = SCI1.DETECT (=SCI1.OFF#)
+
+PIO2.0 (?) = 
+PIO2.1 (?) = 
+PIO2.2 (o) = I2C0_SCL (HDMI)
+PIO2.3 (b) = I2C0_SDA
+PIO2.4 (i) = 
+PIO2.5 (?) = I2C1_SCL (regs)
+PIO2.6 (?) = I2C1_SDA
+PIO2.7 (?) = 
+
+PIO3.0 (?) = 
+PIO3.1 (?) = 
+PIO3.2 (o) = frontend reset
+PIO3.3 (?) = 
+PIO3.4 (o) = I2C2_SCL (StarCI)
+PIO3.5 (b) = I2C2_SDA
+PIO3.6 (o) = I2C3_SCL (Frontend(s))
+PIO3.7 (b) = I2C3_SDA
+
+PIO4.0 (o) = power control?
+PIO4.1 (?) = 
+PIO4.2 (I) = ASC2_RXD  // console
+PIO4.3 (O) = ASC2_TXD  // console
+PIO4.4 (i) = USB rear ovrcur
+PIO4.5 (o) = USB rear power
+PIO4.6 (i) = USB front ovrcur
+PIO4.7 (o) = USB front power
+
+PIO5.0 (O) = ASC3_TxD  // front uC
+PIO5.1 (I) = ASC3_RxD  // front uC
+PIO5.2 (O) = ASC3_RTS
+PIO5.3 (I) = ASC3_CTS
+PIO5.4 (?) = 
+PIO5.5 (?) = 
+PIO5.6 (?) = 
+PIO5.7 (O) = CiMAX reset
+
+PIO6.0 (?) = 
+PIO6.1 (?) = 
+PIO6.2 (?) = 
+PIO6.3 (?) = 
+PIO6.4 (O) =  NOR Flash #WP
+PIO6.5 (?) = 
+PIO6.6 (?) = 
+PIO6.7 (?) = 
+
+PIO7.0 (o) = CI lower slot power control 
+PIO7.1 (o) = CI upper slot power control
+PIO7.2 (?) =
+PIO7.3 (?) = 
+PIO7.4 (I) = MII receive data valid
+PIO7.5 (?) = MII receiver error
+PIO7.6 (O) = MII transmit dataa
+PIO7.7 (O) = MII transmit data
+
+PIO8.0 (O) = MII transmit data
+PIO8.1 (O) = MII transmit data
+PIO8.2 (O) = MII TX enable
+PIO8.3 (?) = MII mgmt data
+PIO8.4 (I) = MII mgmg Clock I/O
+PIO8.5 (I) = MII receive clock
+PIO8.6 (I) = MII receive data
+PIO8.7 (I) = MII receive data
+
+PIO9.0 (I) = MII receive data
+PIO9.1 (I) = MII receive data
+PIO9.2 (I) = MII transmit clock for TxD
+PIO9.3 (I) = MII collision detect
+PIO9.4 (I) = MII carrier sense detect
+PIO9.5 (O) = Clock to PHY
+PIO9.6 (I) = mgmt data interrupt
+PIO9.7 (I) = HDMI plugin?
+
+PIO10.0 (o) = DVB-T PWR_EN#
+PIO10.1 (o) = DVB-S2 PWR_EN#
+PIO10.2 (o) = LNB enable (LNB12 pin 5, tuner pin 17)
+PIO10.3 (o) = LNB LLC (LNB12 pin 9, tuner pin 20)
+PIO10.4 (o) = LNB 13/18 (LNB12 pin 4, tuner pin 19)
+PIO10.5 (o) = LNB Tone enable (LNB12 pin 7, tuner 18 nc)
+PIO10.6 (?) =
+PIO10.7 (?) = 
+
+PIO11.0 (?) = 
+PIO11.1 (?) = 
+PIO11.2 (?) = 
+PIO11.3 (?) = 
+PIO11.4 (?) = 
+PIO11.5 (?) = 
+PIO11.6 (?) = 
+PIO11.7 (?) = 
+
+PIO12.0 (O) =
+PIO12.1 (I) =
+PIO12.2 (o) =
+PIO12.3 (o) =
+PIO12.4 (o) =
+PIO12.5 (o) =
+PIO12.6 (i) =
+PIO12.7 (o) =
+
+PIO13.0 (?) = 
+PIO13.1 (?) = 
+PIO13.2 (?) =
+PIO13.3 (?) = 
+PIO13.4 (?) =
+PIO13.5 (?) = 
+PIO13.6 (?) = 
+PIO13.7 (?) = 
+
+PIO14.0 (?) = 
+PIO14.1 (?) = 
+PIO14.2 (?) = 
+PIO14.3 (?) = 
+PIO14.4 (?) = 
+PIO14.5 (?) = 
+PIO14.6 (?) = 
+PIO14.7 (o) = 
+
+PIO15.0 (i) = SPI Boot CLK
+PIO15.1 (i) = SPI Boot DOUT
+PIO15.2 (i) = SPI Boot NOTCS
+PIO15.3 (o) = DVBS2OE# (contention?)
+PIO15.4 (?) =
+PIO15.5 (o) = PHY Reset
+PIO15.6 (?) =
+PIO15.7 (?) =
+
+PIO16.0 (?) = 
+PIO16.1 (?) = 
+PIO16.2 (?) =
+PIO16.3 (?) = 
+PIO16.4 (?) =
+PIO16.5 (?) = 
+PIO16.6 (?) = 
+PIO16.7 (?) = 
+#endif
+
+
+const char *LMI_IO_partalias[]  = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers", "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+const char *bigphys_partalias[] = { "LMI_SYS", NULL };
 
 /*
- * Flash setup depends on boot-device:
- *
- * boot-from-       | NOR                NAND	            SPI
- * ----------------------------------------------------------------------------
- * JE2 (CS routing) | 0 (EMIA->NOR_CS)   1 (EMIA->NAND_CS)  0
- *                  |   (EMIB->NOR_CS)     (EMIB->NOR_CS)     (EMIB->NOR_CS)
- *                  |   (EMIC->NAND_CS)    (EMIC->NOR_CS)     (EMIC->NAND_CS)
- * JE3 (data width) | 0 (16bit)          1 (8bit)           N/A
- * JE5 (mode 15)    | 0 (boot NOR)       1 (boot NAND)	    0 (boot SPI)
- * JE6 (mode 16)    | 0                  0                  1
- * -----------------------------------------------------------------------------
- *
- * [Jumper settings based on board v1.2-011]
- */
-
-#define HDK7105_PIO_PCI_SERR  stm_gpio(15, 4)
-#define HDK7105_PIO_PHY_RESET stm_gpio(15, 5)
-#define HDK7105_PIO_PCI_RESET stm_gpio(15, 7)
-#define HDK7105_GPIO_FLASH_WP stm_gpio(6, 4)
-
-
-
-static void __init hdk7105_setup(char **cmdline_p)
-{
-	printk(KERN_INFO "STMicroelectronics HDK7105 "
-			"board initialisation\n");
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x46FFFFFF - linux   (120mb) 
+0x4A000000 - 0x4BFFFFFF - bigphys ( 32mb)
+0x4C000000 - 0x4FFFFFFF - lmi_io  ( 64mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] =
+{
+	{
+		.name  = "bigphysarea",
+		.start = 0x4A000000,
+		.size  = 0x02000000, /* 32 Mb */
+		.flags = 0,
+		.aka   = bigphys_partalias
+	},
+	{
+		.name  = "LMI_IO",
+		.start = 0x4C000000,
+		.size  = 0x04000000, /* 64 Mb */
+		.flags = 0,
+		.aka   = LMI_IO_partalias
+	}
+};
+
+static void __init opt9600prima_setup(char **cmdline_p)
+{
+	printk(KERN_INFO "Opticum HD (TS) 9600 Prima (HDK7105) board initialisation\n");
 
 	stx7105_early_device_init();
 
-	stx7105_configure_asc(2, &(struct stx7105_asc_config) {
-			.routing.asc2 = stx7105_asc2_pio4,
-			.hw_flow_control = 1,
-			.is_console = 1, });
-	stx7105_configure_asc(3, &(struct stx7105_asc_config) {
-			.hw_flow_control = 1,
-			.is_console = 0, });
+	// console asc
+	stx7105_configure_asc(2, &(struct stx7105_asc_config)
+	{
+		.routing.asc2 = stx7105_asc2_pio4,
+		.hw_flow_control = 0,
+		.is_console = 1,
+	});
+	// front processor asc
+	stx7105_configure_asc(3, &(struct stx7105_asc_config)
+	{
+		.hw_flow_control = 0,
+		.is_console = 0,
+	});
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
 }
 
-/* PCI configuration */
-static struct stm_plat_pci_config hdk7105_pci_config = {
-	.pci_irq = {
-		[0] = PCI_PIN_DEFAULT,
-		[1] = PCI_PIN_DEFAULT,
-		[2] = PCI_PIN_UNUSED,
-		[3] = PCI_PIN_UNUSED
-	},
-	.serr_irq = PCI_PIN_UNUSED, /* Modified in hdk7105_device_init() */
-	.idsel_lo = 30,
-	.idsel_hi = 30,
-	.req_gnt = {
-		[0] = PCI_PIN_DEFAULT,
-		[1] = PCI_PIN_UNUSED,
-		[2] = PCI_PIN_UNUSED,
-		[3] = PCI_PIN_UNUSED
-	},
-	.pci_clk = 33333333,
-	.pci_reset_gpio = HDK7105_PIO_PCI_RESET,
-};
-
-int pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-        /* We can use the standard function on this board */
-	return stx7105_pcibios_map_platform_irq(&hdk7105_pci_config, pin);
-}
-
-static struct platform_device hdk7105_leds = {
-	.name = "leds-gpio",
-	.id = 0,
-	.dev.platform_data = &(struct gpio_led_platform_data) {
-		.num_leds = 2,
-		.leds = (struct gpio_led[]) {
-			/* The schematics actually describes these PIOs
-			 * the other way round, but all tested boards
-			 * had the bi-colour LED fitted like below... */
-			{
-				.name = "RED", /* This is also frontpanel LED */
-				.gpio = stm_gpio(7, 0),
-				.active_low = 1,
-			}, {
-				.name = "GREEN",
-				.default_trigger = "heartbeat",
-				.gpio = stm_gpio(7, 1),
-				.active_low = 1,
-			},
-		},
-	},
-};
-
-static struct tm1668_key hdk7105_front_panel_keys[] = {
-	{ 0x00001000, KEY_UP, "Up (SWF2)" },
-	{ 0x00800000, KEY_DOWN, "Down (SWF7)" },
-	{ 0x00008000, KEY_LEFT, "Left (SWF6)" },
-	{ 0x00000010, KEY_RIGHT, "Right (SWF5)" },
-	{ 0x00000080, KEY_ENTER, "Enter (SWF1)" },
-	{ 0x00100000, KEY_ESC, "Escape (SWF4)" },
-};
-
-static struct tm1668_character hdk7105_front_panel_characters[] = {
-	TM1668_7_SEG_HEX_DIGITS,
-	TM1668_7_SEG_HEX_DIGITS_WITH_DOT,
-	TM1668_7_SEG_SEGMENTS,
-};
-
-static struct platform_device hdk7105_front_panel = {
-	.name = "tm1668",
-	.id = -1,
-	.dev.platform_data = &(struct tm1668_platform_data) {
-		.gpio_dio = stm_gpio(11, 2),
-		.gpio_sclk = stm_gpio(11, 3),
-		.gpio_stb = stm_gpio(11, 4),
-		.config = tm1668_config_6_digits_12_segments,
-
-		.keys_num = ARRAY_SIZE(hdk7105_front_panel_keys),
-		.keys = hdk7105_front_panel_keys,
-		.keys_poll_period = DIV_ROUND_UP(HZ, 5),
-
-		.brightness = 8,
-		.characters_num = ARRAY_SIZE(hdk7105_front_panel_characters),
-		.characters = hdk7105_front_panel_characters,
-		.text = "7105",
-	},
-};
-
-
-
-static int hdk7105_phy_reset(void *bus)
-{
-	gpio_set_value(HDK7105_PIO_PHY_RESET, 0);
+static int opt9600prima_phy_reset(void *bus)
+{
+	gpio_set_value(OPT9600PRIMA_PIO_PHY_RESET, 0);
 	udelay(100);
-	gpio_set_value(HDK7105_PIO_PHY_RESET, 1);
-
+	gpio_set_value(OPT9600PRIMA_PIO_PHY_RESET, 1);
 	return 1;
 }
 
-static struct stmmac_mdio_bus_data stmmac_mdio_bus = {
+static struct stmmac_mdio_bus_data stmmac_mdio_bus =
+{
 	.bus_id = 0,
-	.phy_reset = hdk7105_phy_reset,
+	.phy_reset = opt9600prima_phy_reset,
 	.phy_mask = 0,
 };
 
 /* NOR Flash */
-static struct platform_device hdk7105_nor_flash = {
-	.name		= "physmap-flash",
-	.id		= -1,
-	.num_resources	= 1,
-	.resource	= (struct resource[]) {
+static struct mtd_partition opt9600prima_physmap_flash_partitions[] =
+{
+	{
+		.name   = "U-Boot",              // mtd0
+		.size   = 0x00040000,            // 256k
+		.offset = 0x00000000,
+	},
+	{
+		.name   = "U-Boot environment",  // mtd1
+		.size   = 0x00020000,            // 128k
+		.offset = 0x00040000,
+	},
+	{
+		.name   = "kernel",              // mtd2
+		.size   = 0x00300000,            // 3,0M
+		.offset = 0x00060000,            // 384k (0.375M)
+	},
+	{
+		.name   = "ROOT_FS",             // mtd3
+		.size   = 0x004A0000,            // 4,625M
+		.offset = 0x00360000,            // 3.375M
+	},
+	{
+		.name   = "Full, w/o u-Boot",    // mtd4
+		.size   = 0x007A0000,            //  7,625M
+		.offset = 0x00060000,
+	},
+	{
+		.name   = "Full",                // mtd5
+		.size   = 0x00800000,            // 8M
+		.offset = 0x00000000,
+	}
+};
+
+static struct platform_device opt9600prima_nor_flash =
+{
+	.name          = "physmap-flash",
+	.id            = -1,
+	.num_resources = 1,
+	.resource      = (struct resource[])
+	{
 		{
-			.start		= 0x00000000,
-			.end		= 128*1024*1024 - 1,
-			.flags		= IORESOURCE_MEM,
+			.start = 0x00000000,
+			.end   = 8 * 1024 * 1024 - 1,
+			.flags = IORESOURCE_MEM,
 		}
 	},
-	.dev.platform_data	= &(struct physmap_flash_data) {
-		.width		= 2,
-		.set_vpp	= NULL,
-		.nr_parts	= 3,
-		.parts		=  (struct mtd_partition []) {
+	.dev.platform_data = &(struct physmap_flash_data)
+	{
+		.width      = 2,
+		.set_vpp    = NULL,
+		.nr_parts	= ARRAY_SIZE(opt9600prima_physmap_flash_partitions),
+		.parts		= opt9600prima_physmap_flash_partitions
+	}
+};
+
+static struct platform_device *opt9600prima_devices[] __initdata =
+{
+	&opt9600prima_nor_flash,
+};
+
+#if 0
+void hdk7105_unconfigure_ssc_i2c(void)
+{
+    stx7105_unconfigure_ssc_i2c(1, &(struct stx7105_ssc_config)
+	{
+		.routing.ssc2.sclk = stx7105_ssc1_sclk_pio2_5,
+		.routing.ssc2.mtsr = stx7105_ssc1_mtsr_pio2_6,
+	});
+}
+EXPORT_SYMBOL(hdk7105_unconfigure_ssc_i2c);
+#endif
+
+static int __init opt9600prima_device_init(void)
+{
+#if 0
+	/* Temporary: try and find the PIO's */
+	int i;
+	int j;
+#define SLEEP 300
+
+	for (i = 0; i < 17; i++)
+	{
+		for (j = 0; j < 8; j++)
+		{
+			if ((i == 4 && j == 2)   // console asc TxD OK
+			||  (i == 4 && j == 3)   // console asc RxD OK
+			||  (i == 4 && j == 4)   // console asc CTS OK
+			||  (i == 4 && j == 5)   // console asc RTS OK
+			||  (i == 5 && j == 0)   // FP asc OK
+			||  (i == 5 && j == 1)   // FP asc OK
+			||  (i == 2 && j == 2)   // i2c0 OK
+			||  (i == 2 && j == 5)   // i2c0 OK
+			||  (i == 2 && j == 6)   // i2c1 OK
+			||  (i == 2 && j == 3)   // i2c1 OK
+			||  (i == 3 && j == 4)   // i2c2 OK
+			||  (i == 3 && j == 5)   // i2c2 OK
+			||  (i == 3 && j == 6)   // i2c3 OK
+			||  (i == 3 && j == 7)   // i2c3 OK
+			||  (i == 4 && j == 0)   // power control?
+			||  (i == 4 && j == 4)   // rear USB overcurrent
+			||  (i == 4 && j == 5)   // rear USB power control
+			||  (i == 4 && j == 6)   // front USB overcurrent
+			||  (i == 4 && j == 7)   // front USB power control
+			||  (i == 5 && j == 7)   // CiMAX reset
+			||  (i == 15 && j == 4)  // CiMAX INT pin
+			||  (i == 7 && j == 1)   // CI power control, top slot
+			||  (i == 7 && j == 0)   // CI power control, top slot
+			||  (i == 17 && j == 4) 
+			||  (i == 17 && j == 4) 
+			||  (i == 17 && j == 4) 
+			||  (i == 17 && j == 4) 
+			||  (i == 0)             // skip card reader 0 interface
+			||  (i == 1)             // skip card reader 1 interface
+			||  (i == 7 && j == 4)   // MII interface 
+			||  (i == 7 && j == 5)   // MII interface 
+			||  (i == 7 && j == 6)   // MII interface 
+			||  (i == 7 && j == 7)   // MII interface
+			||  (i == 8)             // MII interface
+			||  (i == 9))            // MII interface
 			{
-				.name = "NOR Flash 1",
-				.size = 0x00080000,
-				.offset = 0x00000000,
-			}, {
-				.name = "NOR Flash 2",
-				.size = 0x00200000,
-				.offset = MTDPART_OFS_NXTBLK,
-			}, {
-				.name = "NOR Flash 3",
-				.size = MTDPART_SIZ_FULL,
-				.offset = MTDPART_OFS_NXTBLK,
+				printk("Skip GPIO(%1d.%1d)\n", i, j);
 			}
-		},
-	},
-};
-
-/* NAND Flash */
-struct stm_nand_bank_data hdk7105_nand_flash = {
-	.csn		= 1,
-	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
-	.nr_partitions	= 2,
-	.partitions	= (struct mtd_partition []) {
-		{
-			.name	= "NAND Flash 1",
-			.offset	= 0,
-			.size 	= 0x00800000
-		}, {
-			.name	= "NAND Flash 2",
-			.offset = MTDPART_OFS_NXTBLK,
-			.size	= MTDPART_SIZ_FULL
-		},
-	},
-	.timing_spec	= &NAND_TSPEC_HYNIX_HY27UH08AG5B,
-};
-
-/* Serial Flash */
-static struct spi_board_info hdk7105_serial_flash = {
-	.modalias       = "m25p80",
-	.bus_num        = 0,
-	.chip_select    = stm_gpio(2, 4),
-	.max_speed_hz   = 3000000,
-	.mode           = SPI_MODE_3,
-	.platform_data  = &(struct flash_platform_data) {
-		.name = "m25p80",
-		.type = "m25p32",
-		.nr_parts	= 2,
-		.parts = (struct mtd_partition []) {
+			else
 			{
-				.name = "Serial Flash 1",
-				.size = 0x00080000,
-				.offset = 0,
-			}, {
-				.name = "Serial Flash 2",
-				.size = MTDPART_SIZ_FULL,
-				.offset = MTDPART_OFS_NXTBLK,
-			},
-		},
-	},
-};
-
-static struct platform_device *hdk7105_devices[] __initdata = {
-	&hdk7105_leds,
-	&hdk7105_front_panel,
-	&hdk7105_nor_flash,
-};
-
-static int __init hdk7105_device_init(void)
-{
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_OUT);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("GPIO(%1d.%1d): ", i, j);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 0);
+				printk("off ");
+				mdelay(SLEEP);
+				gpio_set_value(stm_gpio(i, j), 1);
+				printk("on ");
+				mdelay(SLEEP);
+				stm_gpio_direction(stm_gpio(i, j), STM_GPIO_DIRECTION_IN);
+				printk("set to input\n");
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+				mdelay(SLEEP);
+			}
+		}
+	}
+#endif
+
 	struct sysconf_field *sc;
-	unsigned long nor_bank_base = 0;
-	unsigned long nor_bank_size = 0;
-
-	/* Configure Flash according to boot-device */
-	sc = sysconf_claim(SYS_STA, 1, 15, 16, "boot_device");
-	switch (sysconf_read(sc)) {
-	case 0x0:
-		/* Boot-from-NOR: */
-		pr_info("Configuring FLASH for boot-from-NOR\n");
-		/* NOR mapped to EMIA + EMIB (FMI_A26 = EMI_CSA#) */
-		nor_bank_base = emi_bank_base(0);
-		nor_bank_size = emi_bank_base(2) - nor_bank_base;
-		hdk7105_nand_flash.csn = 2;
-		break;
-	case 0x1:
-		/* Boot-from-NAND */
-		pr_info("Configuring FLASH for boot-from-NAND\n");
-		nor_bank_base = emi_bank_base(1);
-		nor_bank_size = emi_bank_base(2) - nor_bank_base;
-		hdk7105_nand_flash.csn = 0;
-		break;
-	case 0x2:
-		/* Boot-from-SPI */
-		pr_info("Configuring FLASH for boot-from-SPI\n");
-		/* NOR mapped to EMIB, with physical offset of 0x06000000! */
-		nor_bank_base = emi_bank_base(1);
-		nor_bank_size = emi_bank_base(2) - nor_bank_base;
-		hdk7105_nand_flash.csn = 2;
-		break;
-	default:
-		BUG();
-		break;
-	}
-	sysconf_release(sc);
-
-	/* Update NOR Flash base address and size: */
-	/*     - reduce visibility of NOR flash to EMI bank size */
-	if (hdk7105_nor_flash.resource[0].end > nor_bank_size - 1)
-		hdk7105_nor_flash.resource[0].end = nor_bank_size - 1;
-	/*     - update resource parameters */
-	hdk7105_nor_flash.resource[0].start += nor_bank_base;
-	hdk7105_nor_flash.resource[0].end += nor_bank_base;
-
-	/* Setup the PCI_SERR# PIO */
-	if (gpio_request(HDK7105_PIO_PCI_SERR, "PCI_SERR#") == 0) {
-		gpio_direction_input(HDK7105_PIO_PCI_SERR);
-		hdk7105_pci_config.serr_irq =
-				gpio_to_irq(HDK7105_PIO_PCI_SERR);
-		set_irq_type(hdk7105_pci_config.serr_irq, IRQ_TYPE_LEVEL_LOW);
-	} else {
-		printk(KERN_WARNING "hdk7105: Failed to claim PCI SERR PIO!\n");
-	}
-	stx7105_configure_pci(&hdk7105_pci_config);
-
+#if defined(CONFIG_SATA_STM)
 	stx7105_configure_sata(0);
-
-	stx7105_configure_pwm(&(struct stx7105_pwm_config) {
-			.out0 = stx7105_pwm_out0_pio13_0,
-			.out1 = stx7105_pwm_out1_disabled, });
+#endif
+#if 0
+	stx7105_configure_pwm(&(struct stx7105_pwm_config)
+	{
+		.out0 = stx7105_pwm_out0_pio13_0,
+		.out1 = stx7105_pwm_out1_disabled,
+	});
+#endif
 
 	/* Set SPI Boot pads as inputs to avoid contention with SSC1 */
+#if 0
 	gpio_request(stm_gpio(15, 0), "SPI Boot CLK");
 	gpio_direction_input(stm_gpio(15, 0));
 	gpio_request(stm_gpio(15, 1), "SPI Boot DOUT");
@@ -330,6 +434,7 @@
 	gpio_direction_input(stm_gpio(15, 2));
 	gpio_request(stm_gpio(15, 3), "SPI Boot DIN");
 	gpio_direction_input(stm_gpio(15, 3));
+#endif
 
 	/*
 	 * Fix the reset chain so it correct to start with in case the
@@ -340,80 +446,125 @@
 	/* Release the sysconf bits so the coprocessor driver can claim them */
 	sysconf_release(sc);
 
-	/* I2C_xxxA - HDMI */
-	stx7105_configure_ssc_i2c(0, &(struct stx7105_ssc_config) {
-			.routing.ssc0.sclk = stx7105_ssc0_sclk_pio2_2,
-			.routing.ssc0.mtsr = stx7105_ssc0_mtsr_pio2_3, });
-	/* SPI - SerialFLASH */
-	stx7105_configure_ssc_spi(1, &(struct stx7105_ssc_config) {
-			.routing.ssc1.sclk = stx7105_ssc1_sclk_pio2_5,
-			.routing.ssc1.mtsr = stx7105_ssc1_mtsr_pio2_6,
-			.routing.ssc1.mrst = stx7105_ssc1_mrst_pio2_7});
-	/* I2C_xxxC - JN1 (NIM), JN3, UT1 (CI chip), US2 (EEPROM) */
-	stx7105_configure_ssc_i2c(2, &(struct stx7105_ssc_config) {
-			.routing.ssc2.sclk = stx7105_ssc2_sclk_pio3_4,
-			.routing.ssc2.mtsr = stx7105_ssc2_mtsr_pio3_5, });
-	/* I2C_xxxD - JN2 (NIM), JN4 */
-	stx7105_configure_ssc_i2c(3, &(struct stx7105_ssc_config) {
-			.routing.ssc3.sclk = stx7105_ssc3_sclk_pio3_6,
-			.routing.ssc3.mtsr = stx7105_ssc3_mtsr_pio3_7, });
-
-	stx7105_configure_usb(0, &(struct stx7105_usb_config) {
-			.ovrcur_mode = stx7105_usb_ovrcur_active_low,
-			.pwr_enabled = 1,
-			.routing.usb0.ovrcur = stx7105_usb0_ovrcur_pio4_4,
-			.routing.usb0.pwr = stx7105_usb0_pwr_pio4_5, });
-	stx7105_configure_usb(1, &(struct stx7105_usb_config) {
-			.ovrcur_mode = stx7105_usb_ovrcur_active_low,
-			.pwr_enabled = 1,
-			.routing.usb1.ovrcur = stx7105_usb1_ovrcur_pio4_6,
-			.routing.usb1.pwr = stx7105_usb1_pwr_pio4_7, });
-
-	gpio_request(HDK7105_PIO_PHY_RESET, "eth_phy_reset");
-	gpio_direction_output(HDK7105_PIO_PHY_RESET, 1);
-
-	stx7105_configure_ethernet(0, &(struct stx7105_ethernet_config) {
-			.mode = stx7105_ethernet_mode_mii,
-			.ext_clk = 0,
-			.phy_bus = 0,
-			.phy_addr = 0,
-			.mdio_bus_data = &stmmac_mdio_bus,
-		});
-
-	stx7105_configure_lirc(&(struct stx7105_lirc_config) {
-#ifdef CONFIG_LIRC_STM_UHF
-			.rx_mode = stx7105_lirc_rx_mode_uhf,
-#else
-			.rx_mode = stx7105_lirc_rx_mode_ir,
-#endif
-			.tx_enabled = 0,
-			.tx_od_enabled = 0, });
-
-	stx7105_configure_audio(&(struct stx7105_audio_config) {
-			.spdif_player_output_enabled = 1, });
-
+	/* I2C bus 0: HDMI */
 	/*
-	 * FLASH_WP is shared between between NOR and NAND FLASH.  However,
-	 * since NAND MTD has no concept of write-protect, we permanently
-	 * disable WP.
-	 */
-	gpio_request(HDK7105_GPIO_FLASH_WP, "FLASH_WP");
-	gpio_direction_output(HDK7105_GPIO_FLASH_WP, 1);
-
-	stx7105_configure_nand(&(struct stm_nand_config) {
-			.driver = stm_nand_flex,
-			.nr_banks = 1,
-			.banks = &hdk7105_nand_flash,
-			.rbn.flex_connected = 1,});
-
-	spi_register_board_info(&hdk7105_serial_flash, 1);
-
-	return platform_add_devices(hdk7105_devices,
-			ARRAY_SIZE(hdk7105_devices));
+	       0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
+	  00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  30: UU -- -- -- -- -- -- -- -- -- 3a -- -- -- -- -- 
+	  40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  50: UU 51 52 53 54 55 56 57 -- -- -- -- -- -- -- -- 
+	  60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  70: -- -- -- -- -- -- -- --                         
+	 3a:
+	 50-57: HDMI I2C
+	*/
+	stx7105_configure_ssc_i2c(0, &(struct stx7105_ssc_config)
+	{
+		.routing.ssc0.sclk = stx7105_ssc0_sclk_pio2_2,
+		.routing.ssc0.mtsr = stx7105_ssc0_mtsr_pio2_3,
+	});
+#if 1
+	/* I2C bus 1: on board register file */
+	/*
+	       0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
+	  00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  30: -- -- -- -- -- -- -- -- -- -- -- -- -- 3d -- -- 
+	  50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  70: -- -- -- -- -- -- -- --                         
+	 3d: on board register file
+	*/
+	stx7105_configure_ssc_i2c(1, &(struct stx7105_ssc_config)
+	{
+		.routing.ssc1.sclk = stx7105_ssc1_sclk_pio2_5,
+		.routing.ssc1.mtsr = stx7105_ssc1_mtsr_pio2_6,
+	});
+#endif
+	/* I2C bus 2: StarCI */
+	/*
+	       0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
+	  00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  40: 40 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  70: -- -- -- -- -- -- -- --                         
+	 40: StarCI
+*/
+	stx7105_configure_ssc_i2c(2, &(struct stx7105_ssc_config)
+	{
+		.routing.ssc2.sclk = stx7105_ssc2_sclk_pio3_4,
+		.routing.ssc2.mtsr = stx7105_ssc2_mtsr_pio3_5,
+	});
+	/* I2C bus 3: frontend(s) */
+	/*
+	       0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
+	  00:          -- -- -- -- -- -- -- -- -- 0c -- -- -- 
+	  10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  40: 40 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
+	  70: -- -- -- -- -- -- -- --                         
+	 0c: AVL2108 DVB-S(2) frontend
+	 40: DVB-T frontend (TS models only)
+*/
+	stx7105_configure_ssc_i2c(3, &(struct stx7105_ssc_config)
+	{
+		.routing.ssc3.sclk = stx7105_ssc3_sclk_pio3_6,
+		.routing.ssc3.mtsr = stx7105_ssc3_mtsr_pio3_7,
+	});
+
+	// Rear USB
+	stx7105_configure_usb(0, &(struct stx7105_usb_config)
+	{
+		.ovrcur_mode = stx7105_usb_ovrcur_active_low,
+		.pwr_enabled = 1,
+		.routing.usb0.ovrcur = stx7105_usb0_ovrcur_pio4_4,
+		.routing.usb0.pwr = stx7105_usb0_pwr_pio4_5,
+	});
+	// Front USB
+	stx7105_configure_usb(1, &(struct stx7105_usb_config)
+	{
+		.ovrcur_mode = stx7105_usb_ovrcur_active_low,
+		.pwr_enabled = 1,
+		.routing.usb1.ovrcur = stx7105_usb1_ovrcur_pio4_6,
+		.routing.usb1.pwr = stx7105_usb1_pwr_pio4_7,
+	});
+
+	gpio_request(OPT9600PRIMA_PIO_PHY_RESET, "ResetMII");
+	gpio_direction_output(OPT9600PRIMA_PIO_PHY_RESET, 1);
+
+	stx7105_configure_ethernet(0, &(struct stx7105_ethernet_config)
+	{
+		.mode          = stx7105_ethernet_mode_mii,
+		.ext_clk       = 0,  // MB680 has 1
+		.phy_bus       = 0,
+		.phy_addr      = 0,  // MB680 has -1
+		.mdio_bus_data = &stmmac_mdio_bus,
+	});
+
+	stx7105_configure_audio(&(struct stx7105_audio_config)
+	{
+		.spdif_player_output_enabled = 1,
+	});
+
+	/* Flash write protect */
+	gpio_request(OPT9600PRIMA_PIO_FLASH_WP, "FLASH_WP");
+	gpio_direction_output(OPT9600PRIMA_PIO_FLASH_WP, 1);
+
+	return platform_add_devices(opt9600prima_devices, ARRAY_SIZE(opt9600prima_devices));
 }
-arch_initcall(hdk7105_device_init);
-
-static void __iomem *hdk7105_ioport_map(unsigned long port, unsigned int size)
+arch_initcall(opt9600prima_device_init);
+
+static void __iomem *opt9600prima_ioport_map(unsigned long port, unsigned int size)
 {
 	/*
 	 * If we have PCI then this should never be called because we
@@ -425,10 +576,12 @@
 	return (void __iomem *)CCN_PVR;
 }
 
-struct sh_machine_vector mv_hdk7105 __initmv = {
-	.mv_name		= "hdk7105",
-	.mv_setup		= hdk7105_setup,
-	.mv_nr_irqs		= NR_IRQS,
-	.mv_ioport_map		= hdk7105_ioport_map,
+struct sh_machine_vector mv_hdk7105 __initmv =
+{
+	.mv_name       = "Opticum HD 9600 PRIMA board (HDK7105)",
+	.mv_setup      = opt9600prima_setup,
+	.mv_nr_irqs    = NR_IRQS,
+	.mv_ioport_map = opt9600prima_ioport_map,
 	STM_PCI_IO_MACHINE_VEC
 };
+// vim:ts=4
--- a/drivers/stm/gpio.c.orig
+++ b/drivers/stm/gpio.c
@@ -27,13 +27,17 @@
 #include <linux/stm/platform.h>
 #include <linux/stm/pad.h>
 #include <linux/stm/pio.h>
-#include <linux/stm/pm_sys.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/kallsyms.h>
+#endif
 #include "reg_pio.h"
 
 
 
 struct stpio_pin {
 #ifdef CONFIG_STPIO
+	const char *pin_name;
 	void (*func)(struct stpio_pin *pin, void *dev);
 	void* dev;
 	unsigned short port_no, pin_no;
@@ -49,50 +53,10 @@
 #define PIN_IGNORE_FALLING_EDGE	(PIN_IGNORE_EDGE_FLAG | 1)
 #define PIN_IGNORE_EDGE_MASK	(PIN_IGNORE_EDGE_FLAG | PIN_IGNORE_EDGE_VAL)
 
-#ifdef CONFIG_HIBERNATION
-	unsigned char pm_saved_data;
-#endif
+	unsigned char direction;
 	struct stpio_pin stpio;
 };
 
-#ifdef CONFIG_HIBERNATION
-#define GPIO_DIR_MASK  0x7f
-#define GPIO_VAL_MASK  0x80
-static inline void gpio_pm_set_direction(struct stm_gpio_pin *pin,
-	unsigned int dir)
-{
-	pin->pm_saved_data &= ~GPIO_DIR_MASK;
-	pin->pm_saved_data |= dir & GPIO_DIR_MASK;
-}
-
-static inline unsigned char gpio_pm_get_direction(struct stm_gpio_pin *pin)
-{
-	return pin->pm_saved_data & GPIO_DIR_MASK;
-}
-
-static inline void gpio_pm_set_value(struct stm_gpio_pin *pin, int val)
-{
-	pin->pm_saved_data &= ~GPIO_VAL_MASK;
-	pin->pm_saved_data |= (val ? GPIO_VAL_MASK : 0);
-}
-
-static inline int gpio_pm_get_value(struct stm_gpio_pin *pin)
-{
-	return (pin->pm_saved_data & GPIO_VAL_MASK) ? 1 : 0;
-}
-#else
-static inline void gpio_pm_set_direction(struct stm_gpio_pin *pin,
-	unsigned int dir)
-{
-	return;
-}
-
-static inline void gpio_pm_set_value(struct stm_gpio_pin *pin, int val)
-{
-	return;
-}
-
-#endif
 
 #define to_stm_gpio_port(chip) \
 		container_of(chip, struct stm_gpio_port, gpio_chip)
@@ -105,6 +69,8 @@
 	void *base;
 	unsigned long irq_level_mask;
 	struct stm_gpio_pin pins[STM_GPIO_PINS_PER_PORT];
+	struct sys_device sysdev;
+	pm_message_t pm_state;
 };
 
 struct stm_gpio_irqmux {
@@ -112,7 +78,7 @@
 	int port_first;
 };
 
-
+static struct sysdev_class stm_gpio_sysdev_class;
 
 
 int stm_gpio_num; /* Number of available internal PIOs (pins) */
@@ -374,7 +340,6 @@
 static inline void __stm_gpio_set(struct stm_gpio_port *port, unsigned offset,
 		int value)
 {
-	gpio_pm_set_value(&port->pins[offset], value);
 	if (value)
 		set__PIO_SET_POUT__SET_POUT__SET(port->base, offset);
 	else
@@ -390,8 +355,11 @@
 			direction != STM_GPIO_DIRECTION_ALT_OUT &&
 			direction != STM_GPIO_DIRECTION_ALT_BIDIR);
 
-	gpio_pm_set_direction(&port->pins[offset], direction);
+	port->pins[offset].direction = direction;
 	set__PIO_PCx(port->base, offset, direction);
+
+	if (!port->pins[offset].stpio.pin_name)
+                port->pins[offset].stpio.pin_name = "-----";
 }
 
 
@@ -424,7 +392,11 @@
 
 static int stm_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 {
-	stm_pad_configure_gpio(chip->base + offset, STM_GPIO_DIRECTION_IN);
+	struct stm_gpio_port *port = to_stm_gpio_port(chip);
+
+	set__PIO_PCx__INPUT_HIGH_IMPEDANCE(port->base, offset);
+	if (!port->pins[offset].stpio.pin_name)
+		port->pins[offset].stpio.pin_name = "-----";
 
 	return 0;
 }
@@ -436,7 +408,9 @@
 
 	__stm_gpio_set(port, offset, value);
 
-	stm_pad_configure_gpio(chip->base + offset, STM_GPIO_DIRECTION_OUT);
+	set__PIO_PCx__OUTPUT_PUSH_PULL(port->base, offset);
+	if (!port->pins[offset].stpio.pin_name)
+		port->pins[offset].stpio.pin_name = "-----";
 
 	return 0;
 }
@@ -504,12 +478,17 @@
 	gpio_pin->stpio.port_no = port_no;
 	gpio_pin->stpio.pin_no = pin_no;
 
+	gpio_pin->stpio.pin_name = (name==NULL) ? "-----" : name;
 	return &gpio_pin->stpio;
 }
 EXPORT_SYMBOL(__stpio_request_pin);
 
 void stpio_free_pin(struct stpio_pin *pin)
 {
+	stpio_configure_pin(pin, STPIO_IN);
+	pin->pin_name = NULL;
+	pin->func = 0;
+	pin->dev = 0;
 	stm_pad_release_gpio(stm_gpio(pin->port_no, pin->pin_no));
 }
 EXPORT_SYMBOL(stpio_free_pin);
@@ -625,6 +604,88 @@
 }
 EXPORT_SYMBOL(stpio_set_irq_type);
 
+#ifdef CONFIG_PROC_FS
+
+static struct proc_dir_entry *proc_stpio;
+
+static inline const char *stpio_get_direction_name(unsigned int direction)
+{
+	switch (direction) {
+	case STPIO_NONPIO:    return "IN (pull-up) ";
+	case STPIO_BIDIR:     return "BI (open-drain) ";
+	case STPIO_OUT:       return "OUT (push-pull) ";
+	case STPIO_IN:        return "IN (Hi-Z) ";
+	case STPIO_ALT_OUT:   return "Alt-OUT (push-pull)";
+	case STPIO_ALT_BIDIR: return "Alt-BI (open-drain)";
+	default:              return "forbidden ";
+	}
+};
+
+static inline const char *stpio_get_handler_name(void *func)
+{
+	static char sym_name[KSYM_NAME_LEN];
+	char *modname;
+	unsigned long symbolsize, offset;
+	const char *symb;
+
+	if (func == NULL)
+		return "";
+
+	symb = kallsyms_lookup((unsigned long)func, &symbolsize, &offset,
+		&modname, sym_name);
+
+	return symb ? symb : "???";
+}
+
+static int stpio_read_proc(char *page, char **start, off_t off, int count,
+                           int *eof, void *data_unused)
+{
+	int len;
+	int port_no, pin_no;
+	off_t begin = 0;
+	int num_ports = stm_gpio_num / STM_GPIO_PINS_PER_PORT;
+	const char *name;
+	struct stm_gpio_port *port;
+	struct stm_gpio_pin *pin;
+
+	len = sprintf(page, " port     name           direction\n");
+	for (port_no = 0; port_no < num_ports; port_no++)
+	{
+		for (pin_no = 0; pin_no < STM_GPIO_PINS_PER_PORT; pin_no++)
+		{
+			port = &stm_gpio_ports[port_no];
+			if (!port)
+				continue;
+			pin = &port->pins[pin_no];
+			if (!pin)
+				continue;
+			name = pin->stpio.pin_name ? pin->stpio.pin_name : "";
+			len += sprintf(page + len,
+				"PIO %d.%d [%-10s] [%s] [%s]\n",
+				port_no, pin_no, name,
+				stpio_get_direction_name(pin->direction),
+				stpio_get_handler_name(pin->stpio.func));
+
+			if (len + begin > off + count)
+				goto done;
+			if (len + begin < off) {
+				begin += len;
+				len = 0;
+			}
+		}
+	}
+
+	*eof = 1;
+
+done:
+	if (off >= len + begin)
+		return 0;
+	*start = page + (off - begin);
+	return ((count < begin + len - off) ? count : begin + len - off);
+}
+
+#endif /* CONFIG_PROC_FS */
+
 #endif /* CONFIG_STPIO */
 
 
@@ -801,6 +862,7 @@
 	struct stm_gpio_port *port = &stm_gpio_ports[port_no];
 	struct resource *memory;
 	int irq;
+	int ret;
 
 	BUG_ON(port_no < 0);
 	BUG_ON(port_no >= stm_gpio_num);
@@ -828,7 +890,11 @@
 	port->gpio_chip.label = dev_name(&pdev->dev);
 	dev_set_drvdata(&pdev->dev, port);
 
-	return 0;
+	port->sysdev.id = port_no;
+	port->sysdev.cls = &stm_gpio_sysdev_class;
+	ret = sysdev_register(&port->sysdev);
+	if (ret)
+		return ret;
 
 	/* This is a good time to check consistency of linux/stm/gpio.h
 	 * declarations with the proper source... */
@@ -920,46 +986,18 @@
 /*** Drivers initialization ***/
 
 #ifdef CONFIG_PM
-#ifdef CONFIG_HIBERNATION
-/*
- * platform_allow_pm_gpio
- * Every platform implementation of this function has to check if
- * a specific gpio_pin can be managed or not in the PM core code
- */
-int __weak platform_allow_pm_gpio(int gpio, int freezing)
-{
-	return 1;
-}
-
-static int stm_gpio_port_restore(struct stm_gpio_port *port)
+static int stm_gpio_hibernation_resume(struct stm_gpio_port *port)
 {
 	int pin_no;
 
-	for (pin_no = 0; pin_no < port->gpio_chip.ngpio; ++pin_no) {
-		struct stm_gpio_pin *pin = &port->pins[pin_no];
-
-		if (!platform_allow_pm_gpio(
-			stm_gpio(port - stm_gpio_ports, pin_no), 0))
-			continue;
+	for (pin_no = 0; pin_no < port->gpio_chip.ngpio; ++pin_no)
 		/*
-		 * Direction can not be zero! Zero means 'un-claimed'
-		 */
-		if (!gpio_pm_get_direction(pin)) {
-			/*
-			 * On some chip the reset value ins't DIRECTION_IN...
-			 */
+		* Direction can not be zero!
+		* Zero means 'un-claimed'
+		*/
+		if (port->pins[pin_no].direction)
 			__stm_gpio_direction(port, pin_no,
-					STM_GPIO_DIRECTION_IN);
-			/* reset again to say 'un-claimed' as it was */
-			gpio_pm_set_direction(pin, 0);
-			continue;
-		}
-
-		/*
-		 * In case of Direction_Out set the Out value
-		 */
-		if (STM_GPIO_DIRECTION_OUT == gpio_pm_get_direction(pin))
-			__stm_gpio_set(port, pin_no, gpio_pm_get_value(pin));
+				port->pins[pin_no].direction);
 
 		__stm_gpio_direction(port, pin_no, gpio_pm_get_direction(pin));
 
@@ -967,21 +1005,7 @@
 	return 0;
 }
 
-static int stm_gpio_restore(void)
-{
-	int port_no, ret = 0;
-	int port_num = stm_gpio_num / STM_GPIO_PINS_PER_PORT;
-
-	for (port_no = 0; port_no < port_num; ++port_no)
-		ret |= stm_gpio_port_restore(&stm_gpio_ports[port_no]);
-
-	return ret;
-}
-#else
-#define stm_gpio_restore	NULL
-#endif
-
-static int stm_gpio_port_suspend(struct stm_gpio_port *port)
+static int stm_gpio_suspend(struct stm_gpio_port *port)
 {
 	int port_no = port - stm_gpio_ports;
 	int pin_no;
@@ -1000,37 +1024,61 @@
 	return 0;
 }
 
-static int stm_gpio_suspend(void)
+static int stm_gpio_sysdev_suspend(struct sys_device *dev, pm_message_t state)
 {
-	int port_no, ret = 0;
-	int port_num = stm_gpio_num / STM_GPIO_PINS_PER_PORT;
+	struct stm_gpio_port *port = sysdev_to_stm_gpio(dev);
+	int ret = 0;
 
-	for (port_no = 0; port_no < port_num; ++port_no)
-		ret |= stm_gpio_port_suspend(&stm_gpio_ports[port_no]);
+	switch (state.event) {
+	case PM_EVENT_ON:
+		if (port->pm_state.event != PM_EVENT_FREEZE)
+			break;
+		ret = stm_gpio_hibernation_resume(port);
+		break;
 
-	return ret;
-}
+	case PM_EVENT_SUSPEND:
+		ret = stm_gpio_suspend(port);
+			break;
+
+	case PM_EVENT_FREEZE:
+		/* do nothing */
+		break;
+	}
+ 
+	port->pm_state = state;
 
 
-static struct stm_system stm_gpio_system = {
-	.name = "gpio",
-	.priority = stm_gpio_pr,
-	.suspend = stm_gpio_suspend,
-	.freeze = stm_gpio_suspend,
-	.restore = stm_gpio_restore,
-};
+	return ret;
+}
 
-static int stm_gpio_subsystem_init(void)
+static int stm_gpio_sysdev_resume(struct sys_device *dev)
 {
-	return stm_register_system(&stm_gpio_system);
+	return stm_gpio_sysdev_suspend(dev, PMSG_ON);
 }
 
-module_init(stm_gpio_subsystem_init);
+#else
+#define stm_gpio_sysdev_suspend NULL
+#define stm_gpio_sysdev_resume NULL
 #endif
 
+static struct sysdev_class stm_gpio_sysdev_class = {
+	.name = "stm-gpio",
+	.suspend = stm_gpio_sysdev_suspend,
+	.resume = stm_gpio_sysdev_resume,
+};
+
 static int __init stm_gpio_init(void)
 {
 	int ret;
+#ifdef CONFIG_PROC_FS
+	proc_stpio = create_proc_entry("stpio", 0, NULL);
+	if (proc_stpio)
+		proc_stpio->read_proc = stpio_read_proc;
+#endif
+
+	ret = sysdev_class_register(&stm_gpio_sysdev_class);
+	if (ret)
+		return ret;
 
 	ret = platform_driver_register(&stm_gpio_driver);
 	if (ret)
--- a/drivers/net/phy/phy_device.c.org
+++ b/drivers/net/phy/phy_device.c
@@ -1104,7 +1104,7 @@
 		return retval;
 	}
 
-	pr_debug("%s: Registered new driver\n", new_driver->name);
+ 	pr_info("%s: Registered new driver (0x%08x)\n", new_driver->name, new_driver->phy_id);
 
 	return 0;
 }
--- a/drivers/net/stmmac/stmmac_mdio.c.org
+++ b/drivers/net/stmmac/stmmac_mdio.c
@@ -194,12 +194,23 @@
 			 * and no PHY number was provided to the MAC,
 			 * use the one probed here.
 			 */
-			if ((priv->plat->bus_id == mdio_bus_data->bus_id) &&
-			    (priv->plat->phy_addr == -1))
+
+			act = 0;
+
+			if ((priv->plat->bus_id == mdio_bus_data->bus_id) && (/*(priv->plat->phy_addr == -1) ||*/
+					(phydev->phy_id == 0x0181b880) || // Davicom DM9161E
+					(phydev->phy_id == 0x0181b8a0) || // Davicom DM9161A
+					(phydev->phy_id == 0x00181b80) || // Davicom DM9131
+					(phydev->phy_id == 0x1c040011) || // STe100p
+					(phydev->phy_id == 0x00061c50) || // STe101p
+					(phydev->phy_id == 0x00008201) || // RTL8201
+					(phydev->phy_id == 0x0007c0f1) ||
+					(phydev->phy_id == 0x001cc912)))  // RTL821x
+			{
 				priv->plat->phy_addr = addr;
-
-			act = (priv->plat->bus_id == mdio_bus_data->bus_id) &&
-				(priv->plat->phy_addr == addr);
+				act = 1;
+			}
+
 			switch (phydev->irq) {
 			case PHY_POLL:
 				irq_str = "POLL";
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -83,6 +83,26 @@
 	---help---
 	  This is the driver for the STe100p and STe101p PHYs.
 
+choice
+        depends on STE10XP
+        prompt "PHY devices"
+
+config STE100P
+        bool "STE100P"
+        help
+          Say Y here to select the STE100P PHY
+
+config STE101P
+        bool "STE101P"
+        help
+          Say Y here to select the STE101P PHY
+endchoice
+
+
+config RTL8201 
+	depends on PHYLIB
+        bool "Driver for Realtek RTL8201 PHY"
+
 config LSI_ET1011C_PHY
 	tristate "Driver for LSI ET1011C PHY"
 	---help---
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -21,3 +21,5 @@
 obj-$(CONFIG_NATIONAL_PHY)	+= national.o
 obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 obj-$(CONFIG_MICREL_PHY)	+= micrel.o
+obj-$(CONFIG_RTL8201)		+= rtl8201.o
+
--- a/drivers/net/phy/rtl8201.c
+++ b/drivers/net/phy/rtl8201.c
@@ -0,0 +1,139 @@
+/* ============================================================================
+ * This is a driver for the RTL8201 PHY controller.
+ *  (based on STE10XP driver)
+ *
+ *	soon@dgstation.co.kr
+ *
+ * ----------------------------------------------------------------------------
+ * Changelog:
+ *	first release for cuberevo
+ *	second release for opticum/orton/globo HD (TS) 9600 HD (Prima)
+ *
+ * ===========================================================================*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+
+#undef PHYDEBUG
+#define DEFAULT_PHY_ID       0
+#define RESOURCE_NAME        "rtl8201"
+
+#define MII_XCIIS            0x11   /* Configuration Info IRQ & Status Reg*/
+#define MII_XIE              0x12   /* Interrupt Enable Register*/
+#define MII_XIE_DEFAULT_MASK 0x0070 /* ANE complete, Remote Fault, Link Down */
+
+/* RTL8201 phy identifier values */
+#define RTL8201_PHY_ID		 0x00008201  // 0x00061c51
+
+static int rtl8201_config_init(struct phy_device *phydev)
+{
+	int value, err;
+
+	printk("%s >\n", __func__);
+
+	/* Software Reset PHY */
+	value = phy_read(phydev, MII_BMCR);
+	if (value < 0)
+	{
+		return value;
+	}
+
+	value |= BMCR_RESET;
+	err = phy_write(phydev, MII_BMCR, value);
+	if (err < 0)
+	{
+		return err;
+	}
+
+	do
+	{
+		value = phy_read(phydev, MII_BMCR);
+	} while (value & BMCR_RESET);
+
+	return 0;
+}
+
+/* RTL8201 don't have interrupt */
+static int rtl8201_config_intr(struct phy_device *phydev)
+{
+	int err, value;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+	{
+		/* Enable all STe101P interrupts (PR12) */
+		err = phy_write(phydev, MII_XIE, MII_XIE_DEFAULT_MASK);
+		/* clear any pending interrupts */
+		if (err == 0)
+		{
+			value = phy_read(phydev, MII_XCIIS);
+			if (value < 0)
+			{
+				err = value;
+			}
+		}
+	}
+	else
+	{
+		err = phy_write(phydev, MII_XIE, 0);
+	}
+	return err;
+}
+
+static int rtl8201_ack_interrupt(struct phy_device *phydev)
+{
+	int err = phy_read(phydev, MII_XCIIS);
+
+	if (err < 0)
+	{
+		return err;
+	}
+
+	return 0;
+}
+
+static struct phy_driver rtl8201_pdriver =
+{
+	.phy_id         = RTL8201_PHY_ID,
+	.phy_id_mask    = 0xfffffffe,
+	.name           = "RTL8201",
+	.features       = PHY_BASIC_FEATURES,
+	.flags          = 0,  // PHY_HAS_INTERRUPT,
+	.config_init    = rtl8201_config_init,
+	.config_aneg    = genphy_config_aneg,
+	.read_status    = genphy_read_status,
+	.ack_interrupt  = rtl8201_ack_interrupt,
+	.config_intr    = rtl8201_config_intr,
+	.suspend        = genphy_suspend,
+	.resume         = genphy_resume,
+	.driver         =
+	{
+		.owner      = THIS_MODULE
+	}
+};
+
+static int __init rtl8201_init(void)
+{
+	int retval;
+
+	return phy_driver_register(&rtl8201_pdriver);
+}
+
+static void __exit rtl8201_exit(void)
+{
+	phy_driver_unregister(&rtl8201_pdriver);
+}
+
+module_init(rtl8201_init);
+module_exit(rtl8201_exit);
+
+MODULE_DESCRIPTION("RTL8201 PHY driver");
+MODULE_LICENSE("GPL");
+//vim:ts=4

