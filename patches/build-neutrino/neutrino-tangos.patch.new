--- neutrino-mp-tangos.org/acinclude.m4
+++ neutrino-mp-tangos/acinclude.m4
@@ -435,45 +435,13 @@
 AC_ARG_WITH(boxtype,
 	AS_HELP_STRING([--with-boxtype], [valid values: tripledragon, coolstream, spark, azbox, generic, armbox, duckbox, spark7162, mipsbox]),
 	[case "${withval}" in
-		tripledragon|coolstream|azbox|generic|armbox)
+		tripledragon|coolstream|azbox|generic|armbox|duckbox)
 			BOXTYPE="$withval"
 		;;
 		spark|spark7162)
 			BOXTYPE="spark"
 			BOXMODEL="$withval"
 		;;
-		ufs*)
-			BOXTYPE="duckbox"
-			BOXMODEL="$withval"
-		;;
-		atevio*)
-			BOXTYPE="duckbox"
-			BOXMODEL="$withval"
-		;;
-		fortis*)
-			BOXTYPE="duckbox"
-			BOXMODEL="$withval"
-		;;
-		octagon*)
-			BOXTYPE="duckbox"
-			BOXMODEL="$withval"
-		;;
-		hs7*)
-			BOXTYPE="duckbox"
-			BOXMODEL="$withval"
-		;;
-		cuberevo*)
-			BOXTYPE="duckbox"
-			BOXMODEL="$withval"
-		;;
-		ipbox*)
-			BOXTYPE="duckbox"
-			BOXMODEL="$withval"
-		;;
-		tf*)
-			BOXTYPE="duckbox"
-			BOXMODEL="$withval"
-		;;
 		hd51|hd60|hd61|bre2ze4k|osmio4k|osmio4kplus|h7|vusolo4k|vuduo4k|vuultimo4k|vuzero4k|vuuno4kse|vuuno4k)
 			BOXTYPE="armbox"
 			BOXMODEL="$withval"
@@ -490,8 +458,8 @@
 
 AC_ARG_WITH(boxmodel,
 	AS_HELP_STRING([--with-boxmodel], [valid for coolstream: hd1, hd2])
-AS_HELP_STRING([], [valid for duckbox: ufs910, ufs912, ufs913, ufs922, atevio7500, fortis_hdbox, octagon1008, cuberevo, cuberevo_mini, cuberevo_mini2, cuberevo_250hd, cuberevo_2000hd, cuberevo_3000hd, ipbox9900, ipbox99, ipbox55, tf7700])
 AS_HELP_STRING([], [valid for spark: spark, spark7162])
+AS_HELP_STRING([], [valid for duckbox: ufs910, ufs912, ufs913, ufs922, atevio7500, fortis_hdbox, octagon1008, hs7110, hs7420, hs7810a, hs7119, hs7429, hs7819, dp7000, cuberevo, cuberevo_mini, cuberevo_mini2, cuberevo_250hd, cuberevo_2000hd, cuberevo_3000hd, ipbox9900, ipbox99, ipbox55, arivalink200, tf7700, hl101, adb_box, vitamin_hd5000])
 AS_HELP_STRING([], [valid for armbox: hd51, hd60, hd61, bre2ze4k, osmio4k, osmio4kplus, h7, vusolo4k, vuduo4k, vuultimo4k, vuzero4k, vuuno4kse, vuuno4k])
 AS_HELP_STRING([], [valid for mipsbox: vuduo])
 AS_HELP_STRING([], [valid for generic: raspi]),
@@ -515,7 +483,7 @@
 				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
 			fi
 		;;
-		ufs910|ufs912|ufs913|ufs922|atevio7500|fortis_hdbox|octagon1008|cuberevo|cuberevo_mini|cuberevo_mini2|cuberevo_250hd|cuberevo_2000hd|cuberevo_3000hd|ipbox9900|ipbox99|ipbox55|tf7700)
+		ufs910|ufs912|ufs913|ufs922|atevio7500|fortis_hdbox|octagon1008|hs7110|hs7420|hs7810a|hs7119|hs7429|hs7819|dp7000|cuberevo|cuberevo_mini|cuberevo_mini2|cuberevo_250hd|cuberevo_2000hd|cuberevo_3000hd|ipbox9900|ipbox99|ipbox55|arivalink200|tf7700|hl101|adb_box|vitamin_hd5000)
 			if test "$BOXTYPE" = "duckbox"; then
 				BOXMODEL="$withval"
 			else
@@ -579,6 +547,13 @@
 AM_CONDITIONAL(BOXMODEL_ATEVIO7500, test "$BOXMODEL" = "atevio7500")
 AM_CONDITIONAL(BOXMODEL_FORTIS_HDBOX, test "$BOXMODEL" = "fortis_hdbox")
 AM_CONDITIONAL(BOXMODEL_OCTAGON1008, test "$BOXMODEL" = "octagon1008")
+AM_CONDITIONAL(BOXMODEL_HS7110, test "$BOXMODEL" = "hs7110")
+AM_CONDITIONAL(BOXMODEL_HS7420,test "$BOXMODEL" = "hs7420")
+AM_CONDITIONAL(BOXMODEL_HS7810A, test "$BOXMODEL" = "hs7810a")
+AM_CONDITIONAL(BOXMODEL_HS7119, test "$BOXMODEL" = "hs7119")
+AM_CONDITIONAL(BOXMODEL_HS7429,test "$BOXMODEL" = "hs7429")
+AM_CONDITIONAL(BOXMODEL_HS7819, test "$BOXMODEL" = "hs7819")
+AM_CONDITIONAL(BOXMODEL_DP7000, test "$BOXMODEL" = "dp7000")
 
 AM_CONDITIONAL(BOXMODEL_CUBEREVO, test "$BOXMODEL" = "cuberevo")
 AM_CONDITIONAL(BOXMODEL_CUBEREVO_MINI, test "$BOXMODEL" = "cuberevo_mini")
@@ -589,7 +564,11 @@
 AM_CONDITIONAL(BOXMODEL_IPBOX9900, test "$BOXMODEL" = "ipbox9900")
 AM_CONDITIONAL(BOXMODEL_IPBOX99, test "$BOXMODEL" = "ipbox99")
 AM_CONDITIONAL(BOXMODEL_IPBOX55, test "$BOXMODEL" = "ipbox55")
+AM_CONDITIONAL(BOXMODEL_ARIVALINK200, test "$BOXMODEL" = "arivalink200")
 AM_CONDITIONAL(BOXMODEL_TF7700, test "$BOXMODEL" = "tf7700")
+AM_CONDITIONAL(BOXMODEL_HL101, test "$BOXMODEL" = "hl101")
+AM_CONDITIONAL(BOXMODEL_ADB_BOX, test "$BOXMODEL" = "adb_box")
+AM_CONDITIONAL(BOXMODEL_VITAMIN_HD5000, test "$BOXMODEL" = "vitamin_hd5000")
 
 AM_CONDITIONAL(BOXMODEL_HD51, test "$BOXMODEL" = "hd51")
 AM_CONDITIONAL(BOXMODEL_HD60, test "$BOXMODEL" = "hd60")
@@ -657,6 +636,20 @@
 	AC_DEFINE(BOXMODEL_FORTIS_HDBOX, 1, [fortis_hdbox])
 elif test "$BOXMODEL" = "octagon1008"; then
 	AC_DEFINE(BOXMODEL_OCTAGON1008, 1, [octagon1008])
+elif test "$BOXMODEL" = "hs7110"; then
+	AC_DEFINE(BOXMODEL_HS7110, 1, [hs7110])
+elif test "$BOXMODEL" = "hs7420"; then
+	AC_DEFINE(BOXMODEL_HS7420, 1, [hs7420])
+elif test "$BOXMODEL" = "hs7810a"; then
+	AC_DEFINE(BOXMODEL_HS7810A, 1, [hs7810a])
+elif test "$BOXMODEL" = "hs7119"; then
+	AC_DEFINE(BOXMODEL_HS7119, 1, [hs7119])
+elif test "$BOXMODEL" = "hs7429"; then
+	AC_DEFINE(BOXMODEL_HS7429, 1, [hs7429])
+elif test "$BOXMODEL" = "hs7819"; then
+	AC_DEFINE(BOXMODEL_HS7819, 1, [hs7819])
+elif test "$BOXMODEL" = "dp7000"; then
+	AC_DEFINE(BOXMODEL_DP7000, 1, [dp7000])
 elif test "$BOXMODEL" = "cuberevo"; then
 	AC_DEFINE(BOXMODEL_CUBEREVO, 1, [cuberevo])
 elif test "$BOXMODEL" = "cuberevo_mini"; then
@@ -675,8 +668,16 @@
 	AC_DEFINE(BOXMODEL_IPBOX99, 1, [ipbox99])
 elif test "$BOXMODEL" = "ipbox55"; then
 	AC_DEFINE(BOXMODEL_IPBOX55, 1, [ipbox55])
+elif test "$BOXMODEL" = "arivalink200"; then
+	AC_DEFINE(BOXMODEL_ARIVALINK200, 1, [arivalink200])
 elif test "$BOXMODEL" = "tf7700"; then
 	AC_DEFINE(BOXMODEL_TF7700, 1, [tf7700])
+elif test "$BOXMODEL" = "hl101"; then
+	AC_DEFINE(BOXMODEL_HL101, 1, [hl101])
+elif test "$BOXMODEL" = "adb_box"; then
+	AC_DEFINE(BOXMODEL_ADB_BOX, 1, [adb_box])
+elif test "$BOXMODEL" = "vitamin_hd5000"; then
+	AC_DEFINE(BOXMODEL_VITAMIN_HD5000, 1, [vitamin_hd5000])
 elif test "$BOXMODEL" = "hd51"; then
 	AC_DEFINE(BOXMODEL_HD51, 1, [hd51])
 elif test "$BOXMODEL" = "hd60"; then
--- neutrino-mp-tangos.org/src/neutrino.cpp
+++ neutrino-mp-tangos/src/neutrino.cpp
@@ -4850,6 +4850,9 @@
 
 		CVFD::getInstance()->Clear();
 		CVFD::getInstance()->setMode(CVFD::MODE_STANDBY);
+#if defined (FORTIS_HDBOX) || defined (TF7700)
+		CVFD::getInstance()->setlcdparameter(g_settings.lcd_setting[SNeutrinoSettings::LCD_STANDBY_BRIGHTNESS], 0);
+#endif
 		CVFD::getInstance()->setBacklight(g_settings.backlight_standby);
 
 		InfoClock->enableInfoClock(false);
@@ -4885,7 +4888,13 @@
 		// Active standby off
 		powerManager->SetStandby(false, false);
 		CVFD::getInstance()->setMode(CVFD::MODE_TVRADIO);
-		CVFD::getInstance()->ShowText("resume");
+#if defined (FORTIS_HDBOX) || defined (TF7700)
+		CVFD::getInstance()->setlcdparameter(g_settings.lcd_setting[SNeutrinoSettings::LCD_BRIGHTNESS], 1);
+#endif
+#ifdef HAVE_DUCKBOX_HARDWARE
+		CVFD::getInstance()->ClearIcons();
+#endif
+		CVFD::getInstance()->ShowText("Resume");
 		cpuFreq->SetCpuFreq(g_settings.cpufreq * 1000 * 1000);
 		videoDecoder->Standby(false);
 		CEpgScan::getInstance()->Stop();
--- neutrino-mp-tangos.org/src/driver/vfd.cpp
+++ neutrino-mp-tangos/src/driver/vfd.cpp
@@ -52,25 +52,40 @@
 #include <stropts.h>
 #define VFD_DEVICE "/dev/vfd"
 
-#if defined (BOXMODEL_OCTAGON1008) || defined (BOXMODEL_TF7700)
+#if defined (BOXMODEL_OCTAGON1008) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7429) \
+ || defined (BOXMODEL_DP7000) \
+ || defined (BOXMODEL_TF7700)
 #define VFDLENGTH 8
-#elif defined (BOXMODEL_FORTIS_HDBOX) || defined (BOXMODEL_ATEVIO7500)
+#elif defined (BOXMODEL_FORTIS_HDBOX) \
+ ||   defined (BOXMODEL_ATEVIO7500)
 #define VFDLENGTH 12
-#elif  defined (BOXMODEL_CUBEREVO_250HD) || defined (BOXMODEL_IPBOX55)
+#elif defined (BOXMODEL_HS7810A) \
+ ||   defined (BOXMODEL_HS7119) \
+ ||   defined (BOXMODEL_HS7819) \
+ ||   defined (BOXMODEL_CUBEREVO_250HD) \
+ ||   defined (BOXMODEL_IPBOX55)
 #define VFDLENGTH 4
-#elif defined (BOXMODEL_IPBOX9900) || defined (BOXMODEL_IPBOX99)
+#elif defined (BOXMODEL_HS7110)
+#define VFDLENGTH 0
+#elif defined (BOXMODEL_IPBOX9900) \
+ ||   defined (BOXMODEL_IPBOX99)
 #define VFDLENGTH 14
+#elif defined (BOXMODEL_ADB_BOX)
+#define VFDLENGTH 15
 #else
 #define VFDLENGTH 16
 #endif
 
-#define SCROLL_TIME 100000
+#define SCROLL_TIME 500000
 
 bool invert = false;
 bool blocked = false;
 int blocked_counter = 0;
 int file_vfd = -1;
 bool active_icon[16] = { false };
+int adb_led = -1;
 
 pthread_t vfd_scrollText;
 
@@ -79,6 +94,33 @@
 	unsigned char data[64];
 	unsigned char length;
 };
+
+#if defined (BOXMODEL_ADB_BOX)
+int get_adb_variant()
+{
+	FILE *adb_file;
+	char adb_model[5] = { 0x00 };
+	int  ret;
+
+	adb_file = fopen("/proc/stb/info/adb_variant", "r");
+	if (adb_file != NULL)
+	{
+		fread(adb_model, 4, 1, adb_file);
+		printf("[CVFD] get_adb_variant: detected ADB model %s\n", adb_model);
+		if (strcmp(adb_model, "bska") == 0 || strcmp(adb_model, "bxzb") == 0)
+		{
+			printf("[CVFD] get_adb_variant: LED display assumed.\n");
+			ret = 1;
+		}
+		else
+		{
+			printf("[CVFD] get_adb_variant: VFD display assumed.\n");
+			ret = 0;
+		}
+	}
+	return ret;
+}
+#endif
 
 static void write_to_vfd(unsigned int DevType, struct vfd_ioctl_data * data, bool force = false)
 {
@@ -117,7 +159,8 @@
 	}
 }
 
-#if defined (BOXMODEL_UFS910) || defined (BOXMODEL_UFS922)
+#if defined (BOXMODEL_UFS910) \
+ || defined (BOXMODEL_UFS922)
 static void writeCG (unsigned char adress, unsigned char pixeldata[5])
 {
 	struct vfd_ioctl_data data;
@@ -135,7 +178,16 @@
 
 static void ShowNormalText(char * str, bool fromScrollThread = false)
 {
-	if (blocked)
+	int colon_at_2 = 0;
+	int disp_len = 0;
+
+#if defined (BOXMODEL_HS7119) || defined (BOXMODEL_HS7810A) || defined (BOXMODEL_HS7819)
+	if (str[2] == 0x3a)
+	{
+		colon_at_2++;
+	}
+#endif
+ 	if (blocked)
 	{
 		printf("[CVFD] - blocked\n");
 		usleep(SCROLL_TIME);
@@ -154,39 +206,49 @@
 			vfd_scrollText = 0;
 		}
 	}
-	if ((strlen(str) > VFDLENGTH && !fromScrollThread) && (g_settings.lcd_vfd_scroll >= 1))
+	disp_len = (adb_led == 1 ? 4 : VFDLENGTH);
+#if defined (BOXMODEL_HS7119) || defined (BOXMODEL_HS7810A) || defined (BOXMODEL_HS7819)
+	if ((strlen(str) > disp_len + colon_at_2 && !fromScrollThread) && (g_settings.lcd_vfd_scroll >= 1))
+#else
+	if ((strlen(str) > disp_len && !fromScrollThread) && (g_settings.lcd_vfd_scroll >= 1))
+#endif
 	{
 		CVFD::getInstance()->ShowScrollText(str);
 		return;
 	}
-
-	if (strlen(str) < VFDLENGTH && VFDLENGTH > 7) // do not center on small displays
-		ws = (VFDLENGTH-strlen(str))/2;
+	if (strlen(str) < disp_len && disp_len > 7) // do not center on small displays
+	{
+		ws = (disp_len - strlen(str)) / 2;
+	}
 	else
+	{
 		ws = 0;
+	}
 	memset(data.data, ' ', 63);
+	data.start = 0;
 	if (!fromScrollThread)
 	{
-		memcpy (data.data+ws, str, VFDLENGTH-ws);
-		data.start = 0;
-		if ((strlen(str) % 2) == 1 && VFDLENGTH > 7) // do not center on small displays
-			data.length = VFDLENGTH-ws-1;
-		else
-			data.length = VFDLENGTH-ws;
+		memcpy(data.data + ws, str, disp_len - ws + colon_at_2);
+//		if ((strlen(str) % 2) == 1 && disp_len > 7) // if text length odd
+//		{
+//			data.length = disp_len - ws - 1 + colon_at_2;
+//		}
+//		else
+//		{
+			data.length = disp_len - ws + colon_at_2;
+//		}
 	}
 	else
 	{
-		memcpy ( data.data, str, VFDLENGTH);
-		data.start = 0;
-		data.length = VFDLENGTH;
-	}
+		memcpy(data.data, str, disp_len + colon_at_2);
+		data.length = disp_len + colon_at_2;
+	}
+//	printf("CVFD::ShowNormalText: [%s]\n", str);
 	write_to_vfd(VFDDISPLAYCHARS, &data);
 	return;
 }
 void CVFD::ShowScrollText(char *str)
 {
-	printf("CVFD::ShowScrollText: [%s]\n", str);
-
 	if (blocked)
 	{
 		printf("[CVFD] - blocked\n");
@@ -215,17 +277,18 @@
 	int i;
 	char *str = (char *)arg;
 	int len = strlen(str);
-	char out[VFDLENGTH+1];
-	char buf[VFDLENGTH+65];
-
-	memset(out, 0, VFDLENGTH+1);
+	char out[17];
+	char buf[81];
+	int disp_len = adb_led == 1 ? 4 : VFDLENGTH;
+
+	memset(out, 0, disp_len + 1);
 
 	int retries = g_settings.lcd_vfd_scroll;
 
-	if (len > VFDLENGTH)
+	if (len > disp_len)
 	{
 		printf("CVFD::ThreadScrollText: [%s], length %d\n", str, len);
-		memset(buf, ' ', (len + VFDLENGTH));
+		memset(buf, ' ', len + disp_len);
 		memcpy(buf, str, len);
 
 		while(retries--)
@@ -235,13 +298,13 @@
 			for (i = 0; i <= (len-1); i++)
 			{
 				// scroll text until end
-				memcpy(out, buf+i, VFDLENGTH);
+				memcpy(out, buf + i, disp_len);
 				ShowNormalText(out,true);
 				usleep(SCROLL_TIME);
 			}
 		}
 	}
-	memcpy(out, str, VFDLENGTH); // display first VFDLENGTH chars after scrolling
+	memcpy(out, str, disp_len); // display first VFDLENGTH chars after scrolling
 	ShowNormalText(out,true);
 
 	pthread_exit(0);
@@ -339,47 +402,62 @@
 	return lcdd;
 }
 
-void CVFD::count_down() {
-	if (timeout_cnt > 0) {
+void CVFD::count_down()
+{
+	if (timeout_cnt > 0)
+	{
 		timeout_cnt--;
-		if (timeout_cnt == 0 ) {
-			if (g_settings.lcd_setting_dim_brightness > -1) {
+		if (timeout_cnt == 0 )
+		{
+			if (g_settings.lcd_setting_dim_brightness > -1)
+			{
 				// save lcd brightness, setBrightness() changes global setting
 				int b = g_settings.lcd_setting[SNeutrinoSettings::LCD_BRIGHTNESS];
 				setBrightness(g_settings.lcd_setting_dim_brightness);
 				g_settings.lcd_setting[SNeutrinoSettings::LCD_BRIGHTNESS] = b;
-			} else {
+			}
+			else
+			{
 				setPower(0);
 			}
 		}
 	}
-	if (g_settings.lcd_info_line && switch_name_time_cnt > 0) {
+	if (g_settings.lcd_info_line && switch_name_time_cnt > 0)
+	{
 	  switch_name_time_cnt--;
-		if (switch_name_time_cnt == 0) {
-			if (g_settings.lcd_setting_dim_brightness > -1) {
+		if (switch_name_time_cnt == 0)
+		{
+			if (g_settings.lcd_setting_dim_brightness > -1)
+			{
 				CVFD::getInstance()->showTime(true);
 			}
 		}
 	}
 }
 
-void CVFD::wake_up() {
-	if(fd < 0) return;
-
-	if (atoi(g_settings.lcd_setting_dim_time.c_str()) > 0) {
+void CVFD::wake_up()
+{
+	if (fd < 0)
+	{
+		return;
+	}
+	if (atoi(g_settings.lcd_setting_dim_time.c_str()) > 0)
+	{
 		timeout_cnt = atoi(g_settings.lcd_setting_dim_time.c_str());
 		g_settings.lcd_setting_dim_brightness > -1 ?
 			setBrightness(g_settings.lcd_setting[SNeutrinoSettings::LCD_BRIGHTNESS]) : setPower(1);
 	}
 	else
+	{
 		setPower(1);
-	if(g_settings.lcd_info_line){
+	}
+	if (g_settings.lcd_info_line)
+	{
 		switch_name_time_cnt = g_settings.handling_infobar[SNeutrinoSettings::HANDLING_INFOBAR] + 10;
 	}
 #if defined (BOXMODEL_OCTAGON1008)
 	ShowIcon(ICON_COLON2, false);
 #endif
-
 }
 
 void* CVFD::TimeThread(void *)
@@ -387,17 +465,24 @@
 	while(1) {
 		sleep(1);
 		struct stat buf;
-                if (stat("/tmp/vfd.locked", &buf) == -1) {
-                        CVFD::getInstance()->showTime();
-                        CVFD::getInstance()->count_down();
-                } else
-                        CVFD::getInstance()->wake_up();
+                if (stat("/tmp/vfd.locked", &buf) == -1)
+		{
+                	CVFD::getInstance()->showTime();
+                	CVFD::getInstance()->count_down();
+                }
+		else
+		{
+                	CVFD::getInstance()->wake_up();
+		}
 	}
 	return NULL;
 }
 
 void CVFD::init(const char * /*fontfile*/, const char * /*fontname*/)
 {
+#if defined (BOXMODEL_ADB_BOX)
+	adb_led = get_adb_variant();
+#endif		
 	//InitNewClock(); /FIXME
 
 	brightness = -1;
@@ -426,7 +511,7 @@
 
 	brightness = dimm;
 
-printf("CVFD::setlcdparameter dimm %d power %d\n", dimm, power);
+	printf("CVFD::setlcdparameter dimm %d power %d\n", dimm, power);
 #if !HAVE_DUCKBOX_HARDWARE
 	int ret = ioctl(fd, IOC_FP_SET_BRIGHT, dimm);
 	if(ret < 0)
@@ -438,39 +523,78 @@
 	data.start = brightness & 0x07;
 	data.length = 0;
 	write_to_vfd(VFDBRIGHTNESS, &data);
-#endif
-#if defined (BOXMODEL_FORTIS_HDBOX) || defined (BOXMODEL_ATEVIO7500)
+#if defined (BOXMODEL_FORTIS_HDBOX) \
+ || defined (BOXMODEL_ATEVIO7500)
 	usleep(100000);
 	memset(&data, 0, sizeof(struct vfd_ioctl_data));
-	data.start = 0;
+	if (power) {
+		data.start = 0x01; // red led
+	}
+	else
+	{
+		data.start = 0xf2; // cross plus blue led
+	}
+	data.data[3] = 0; // off
+	data.data[0] = 0;
+	data.data[1] = 0;
+	data.data[4] = 0;
 	data.length = 5;
-	if (power) {
-		data.data[0] = 0x01; // red led
-	}
-	else
-	{
-		data.data[0] = 0xf2; // cross plus blue led
-	}
-	data.start = 0;
-	data.data[4] = 0; // off
-	data.length = 5;
-	write_to_vfd(VFDPWRLED, &data);
+	write_to_vfd(VFDSETLED, &data);
 	usleep(100000);
 	memset(&data, 0, sizeof(struct vfd_ioctl_data));
-	data.start = 0;
+	if (power) {
+		data.start = 0xf2; // cross plus blue led
+	}
+	else
+	{
+		data.start = 0x01; // red led
+	}
+	data.data[3] = brightness * 2;
+	data.data[0] = 0;
+	data.data[1] = 0;
+	data.data[4] = 0;
 	data.length = 5;
-	if (power) {
-		data.data[0] = 0xf2; // cross plus blue led
+	write_to_vfd(VFDSETLED, &data);
+#elif defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7810A) \
+ || defined (BOXMODEL_HS7429) \
+ || defined (BOXMODEL_HS7819) \
+ || defined (BOXMODEL_DP7000)
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+	data.start = 0x02; // logo
+	data.data[3] = (brightness & 0x07);
+	data.data[0] = 0;
+	data.data[1] = 0;
+	data.data[4] = 0;
+	data.length = 5;
+	write_to_vfd(VFDSETLED, &data);
+#elif defined (BOXMODEL_ADB_BOX)
+	if (adb_led)
+	{
+		memset(&data, 0, sizeof(struct vfd_ioctl_data));
+		data.start = brightness & 0x07;
+		data.length = 0;
+		write_to_vfd(VFDLEDBRIGHTNESS, &data);
+	}
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+	data.start = 0x01; // power LED
+	data.data[0] = 0;
+	data.data[1] = 0;
+	data.data[4] = 0;
+	data.length = 5;
+	if (power)
+	{
+		data.data[3] = 2;  // green
 	}
 	else
 	{
-		data.data[0] = 0x01; // red led
-	}
-	data.start = 0;
-	data.data[4] = brightness*2;
-	data.length = 5;
-	write_to_vfd(VFDPWRLED, &data);
-#elif !defined (BOXMODEL_UFS912) && !defined (BOXMODEL_UFS913) && !defined (BOXMODEL_OCTAGON1008)
+		data.data[3] = 1;  // red
+	}
+	write_to_vfd(VFDSETLED, &data);
+
+#elif !defined (BOXMODEL_UFS912) \
+ &&   !defined (BOXMODEL_UFS913) \
+ &&   !defined (BOXMODEL_OCTAGON1008)
 // Power on/off
 	if (power) {
 		data.start = 0x01;
@@ -480,6 +604,7 @@
 	data.length = 0;
 	write_to_vfd(VFDDISPLAYWRITEONOFF, &data, true);
 #endif
+#endif
 }
 
 void CVFD::setlcdparameter(void)
@@ -523,6 +648,10 @@
 		return;
 
 	int led1 = -1, led2 = -1;
+#if defined(BOXMODEL_ADB_BOX)
+	int led3 = -1, led4 = -1;
+#endif
+
 	if(on_off){//on
 		switch(g_settings.led_rec_mode) {
 			case 1:
@@ -554,16 +683,18 @@
 				break;
 	      }
 	}
-
 	setled(led1, led2);
 }
 
 void CVFD::setled(void)
 {
+	int led1 = -1, led2 = -1;
+#if defined(BOXMODEL_ADB_BOX)
+	int led3 = -1, led4 = -1;
+#endif
+	int select = 0;
+
 	if(fd < 0) return;
-
-	int led1 = -1, led2 = -1;
-	int select = 0;
 
 	if(mode == MODE_MENU_UTF8 || mode == MODE_TVRADIO  )
 		  select = g_settings.led_tv_mode;
@@ -590,21 +721,31 @@
 }
 #endif
 
-void CVFD::showServicename(const std::string & name, int number) // UTF-8
+void CVFD::showServicename(const std::string &name, int number) // UTF-8
 {
 	if(fd < 0) return;
 
-printf("CVFD::showServicename: %s\n", name.c_str());
+//	printf("CVFD::showServicename: %s\n", name.c_str());
 	servicename = name;
 	service_number = number;
 
 	if (mode != MODE_TVRADIO)
 		return;
 
-	if (support_text)
+	if (strlen(name.c_str()) < 1)
+	{
+		return;
+	}
+	if (((support_text) && (VFDLENGTH > 7)) || service_number < 0)
+	{
+		printf("CVFD::showServicename (text): [%s]\n", name.c_str());
 		ShowText(name.c_str());
+	}
 	else
+	{
+		printf("CVFD::showServicename(number): [%d]\n", service_number);
 		ShowNumber(service_number);
+	}
 	wake_up();
 }
 
@@ -612,64 +753,101 @@
 {
 	//unsigned int system_rev = cs_get_revision();
 	static int recstatus = 0;
+
 #if 0
 	if(!has_lcd)
 		return;
 #endif
-	if(fd >= 0 && mode == MODE_SHUTDOWN) {
+	if (fd >= 0 && mode == MODE_SHUTDOWN)
+	{
 		ShowIcon(FP_ICON_CAM1, false);
 		return;
 	}
-	if (fd >= 0 && showclock) {
-		if (mode == MODE_STANDBY || ( g_settings.lcd_info_line && (MODE_TVRADIO == mode))) {
+	if (fd >= 0 && showclock)
+	{
+		if (mode == MODE_STANDBY || ( g_settings.lcd_info_line && (MODE_TVRADIO == mode)))
+		{
 			char timestr[21];
 			struct timeb tm;
 			struct tm * t;
-			static int hour = 0, minute = 0;
+			static int hour = 0, minute = 0, second = 0;
 
 			ftime(&tm);
 			t = localtime(&tm.time);
-			if(force || ( switch_name_time_cnt == 0 && ((hour != t->tm_hour) || (minute != t->tm_min))) ) {
+			if (force || ( switch_name_time_cnt == 0 && ((hour != t->tm_hour) || (minute != t->tm_min) || (second != t->tm_sec))) )
+			{
 				hour = t->tm_hour;
 				minute = t->tm_min;
-#if defined (BOXMODEL_OCTAGON1008)
-				ShowIcon(ICON_COLON2, true);
-#elif defined (BOXMODEL_OCTAGON1008) || defined (BOXMODEL_CUBEREVO_250HD)
+				second = t->tm_sec;
+#if defined (BOXMODEL_OCTAGON1008) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7429) \
+ || defined (BOXMODEL_DP7000)
+				ShowIcon(ICON_COLON2, second % 2 == 0 ? true : false);
+				strftime(timestr, 5, "%H%M", t);
+#elif defined (BOXMODEL_HS7119) \
+ || defined (BOXMODEL_HS7810A) \
+ || defined (BOXMODEL_HS7819)
+
+				strftime(timestr, 5, "%H%M", t);
+				ShowIcon(ICON_COLON, second % 2 == 0 ? true : false);
+#elif defined (BOXMODEL_FORTIS_HDBOX)
+				ShowIcon(ICON_COLON3, second % 2 == 0 ? true : false);
+				strftime(timestr, 13, "        %H%M", t);
+#elif defined (BOXMODEL_ADB_BOX)
+				if (adb_led)
+				{
+					strftime(timestr, 5, "%H%M", t);
+				}
+				else
+				{
+					strftime(timestr, 6, (second % 2 == 0 ? "%H:%M" : "%H %M"), t);
+				}
+#elif  defined (BOXMODEL_CUBEREVO_250HD)
 				strftime(timestr, 5, "%H%M", t);
 #else
 				strftime(timestr, 6, "%H:%M", t);
 #endif
 				ShowText(timestr);
-				if (support_text) {
+				if (support_text)
+				{
 					strftime(timestr, 20, "%H:%M", t);
 					ShowText(timestr);
-				} else if (support_numbers && has_led_segment) {
+				}
+				else if (support_numbers && has_led_segment)
+				{
 					ShowNumber((t->tm_hour*100) + t->tm_min);
 				}
 			}
 		}
 	}
-
 	int tmp_recstatus = CNeutrinoApp::getInstance()->recordingstatus;
-	if (tmp_recstatus) {
-		if(clearClock) {
+
+	if (tmp_recstatus)
+	{
+		if (clearClock)
+		{
 			clearClock = 0;
-			if(has_lcd)
+			if (has_lcd)
 				ShowIcon(FP_ICON_CAM1, false);
 #if !HAVE_DUCKBOX_HARDWARE
 			setled(false);//off
 #endif
-		} else {
+		}
+		else
+		{
 			clearClock = 1;
-			if(has_lcd)
+			if (has_lcd)
 				ShowIcon(FP_ICON_CAM1, true);
 #if !HAVE_DUCKBOX_HARDWARE
 			setled(true);//on
 #endif
 		}
-	} else if(clearClock || (recstatus != tmp_recstatus)) { // in case icon ON after record stopped
+	}
+	else if (clearClock || (recstatus != tmp_recstatus))
+	{ // in case icon ON after record stopped
 		clearClock = 0;
-		if(has_lcd)
+		if (has_lcd)
 			ShowIcon(FP_ICON_CAM1, false);
 
 #if !HAVE_DUCKBOX_HARDWARE
@@ -689,7 +867,9 @@
 		ShowIcon(FP_ICON_HD,chan->isHD());
 		ShowIcon(FP_ICON_LOCK,!chan->camap.empty());
 		if (chan->getAudioChannel() != NULL)
+		{
 			ShowIcon(FP_ICON_DD, chan->getAudioChannel()->audioChannelType == CZapitAudioChannel::AC3);
+		}
 	}
 }
 #endif
@@ -729,7 +909,8 @@
 		int pp = (int) round((double) vol / (double) 2);
 		if(oldpp != pp)
 		{
-#if defined (BOXMODEL_UFS910) || defined (BOXMODEL_UFS922)
+#if defined (BOXMODEL_UFS910) \
+ || defined (BOXMODEL_UFS922)
 			int i;
 			unsigned char speaker[5] = {0x1C, 0x1C, 0x1C, 0x3E, 0x7F}; // speaker symbol
 			writeCG(0, speaker);
@@ -776,15 +957,32 @@
 			char vol_chr[64] = "";
 			snprintf(vol_chr, sizeof(vol_chr)-1, "VOL: %d%%", (int)vol);
 			ShowText(vol_chr);
-#elif defined (BOXMODEL_OCTAGON1008)
+#elif defined (BOXMODEL_OCTAGON1008) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7429) \
+ || defined (BOXMODEL_DP7000)
 			char vol_chr[64] = "";
-			snprintf(vol_chr, sizeof(vol_chr)-1, "VOL=%3d", (int)vol);
+			snprintf(vol_chr, sizeof(vol_chr)-1, "VOL=%3d%%", (int)vol);
 			ShowText(vol_chr);
-#elif defined (BOXMODEL_CUBEREVO_250HD) || defined (BOXMODEL_IPBOX55)
+#elif defined (BOXMODEL_HS7119) \
+ ||   defined (BOXMODEL_HS7810A) \
+ ||   defined (BOXMODEL_HS7819) \
+ ||   defined (BOXMODEL_CUBEREVO_250HD) \
+ ||   defined (BOXMODEL_IPBOX55)
 			char vol_chr[64] = "";
 			snprintf(vol_chr, sizeof(vol_chr)-1, "v%3d", (int)vol);
 			ShowText(vol_chr);
-#elif defined (BOXMODEL_FORTIS_HDBOX) || defined (BOXMODEL_ATEVIO7500) || defined (BOXMODEL_UFS912) || defined (BOXMODEL_UFS913) || defined (BOXMODEL_CUBEREVO) || defined (BOXMODEL_CUBEREVO_MINI) || defined (BOXMODEL_CUBEREVO_MINI2) || defined (BOXMODEL_CUBEREVO_2000HD) || defined (BOXMODEL_CUBEREVO_3000HD) || defined (BOXMODEL_IPBOX9900) || defined (BOXMODEL_IPBOX99)
+#elif defined (BOXMODEL_FORTIS_HDBOX) \
+ ||   defined (BOXMODEL_ATEVIO7500) \
+ ||   defined (BOXMODEL_UFS912) \
+ ||   defined (BOXMODEL_UFS913) \
+ ||   defined (BOXMODEL_CUBEREVO) \
+ ||   defined (BOXMODEL_CUBEREVO_MINI) \
+ ||   defined (BOXMODEL_CUBEREVO_MINI2) \
+ ||   defined (BOXMODEL_CUBEREVO_2000HD) \
+ ||   defined (BOXMODEL_CUBEREVO_3000HD) \
+ ||   defined (BOXMODEL_IPBOX9900) \
+ ||   defined (BOXMODEL_IPBOX99)
 			char vol_chr[64] = "";
 			snprintf(vol_chr, sizeof(vol_chr)-1, "Volume: %d%%", (int)vol);
 			ShowText(vol_chr);
@@ -796,15 +994,18 @@
 		int pp = (int) round((double) vol * (double) 8 / (double) 100);
 		if(pp > 8) pp = 8;
 
-		if(force_update || oldpp != pp) {
-printf("CVFD::showVolume: %d, bar %d\n", (int) vol, pp);
+		if(force_update || oldpp != pp)
+		{
+			printf("CVFD::showVolume: %d, bar %d\n", (int) vol, pp);
 			int i;
 			int j = 0x00000200;
-			for(i = 0; i < pp; i++) {
+			for (i = 0; i < pp; i++)
+			{
 				ShowIcon((fp_icon) j, true);
 				j /= 2;
 			}
-			for(;i < 8; i++) {
+			for (;i < 8; i++)
+			{
 				ShowIcon((fp_icon) j, false);
 				j /= 2;
 			}
@@ -842,7 +1043,7 @@
 		if(pp > 8) pp = 8;
 
 		if(pp != ppold) {
-//printf("CVFD::showPercentOver: %d, bar %d\n", (int) perc, pp);
+//			printf("CVFD::showPercentOver: %d, bar %d\n", (int) perc, pp);
 			int i;
 			int j = 0x00000200;
 			for(i = 0; i < pp; i++) {
@@ -874,7 +1075,7 @@
 	if(fd < 0) return;
 	if (mode != MODE_AUDIO)
 		return;
-printf("CVFD::showAudioTrack: %s\n", title.c_str());
+	printf("CVFD::showAudioTrack: %s\n", title.c_str());
 	ShowText(title.c_str());
 	wake_up();
 
@@ -943,6 +1144,10 @@
 
 void CVFD::setMode(const MODES m, const char * const title)
 {
+#if defined (BOXMODEL_ADB_BOX)
+	struct vfd_ioctl_data data;
+
+#endif
 	if(fd < 0) return;
 
 	// Clear colon in display if it is still there
@@ -959,7 +1164,38 @@
 		ShowIcon(FP_ICON_COL2, false);
 	}
 #endif
-
+#if defined (BOXMODEL_OCTAGON1008) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7429)
+	else if (mode == MODE_STANDBY)
+	{
+		ShowIcon(ICON_COLON2, true);
+	}
+#elif defined (BOXMODEL_HS7119) \
+ || defined (BOXMODEL_HS7810A) \
+ || defined (BOXMODEL_HS7819)
+	else if (mode == MODE_STANDBY)
+	{
+		ShowIcon(ICON_COLON, true);
+	}
+#elif defined (BOXMODEL_FORTIS_HDBOX)
+	else if (mode == MODE_STANDBY)
+	{
+		ShowIcon(ICON_COLON3, true);
+	}
+#elif defined (BOXMODEL_ADB_BOX)
+	else if (mode == MODE_STANDBY)
+	{
+		memset(&data, 0, sizeof(struct vfd_ioctl_data));
+		data.start = 0x01; // power LED
+		data.data[0] = 0;
+		data.data[1] = 0;
+		data.data[3] = 1;  // red
+		data.data[4] = 0;
+		data.length = 5;
+		write_to_vfd(VFDSETLED, &data);
+	}
+#endif
 	if(strlen(title))
 		ShowText(title);
 	mode = m;
@@ -981,6 +1217,10 @@
 			showPercentOver(percentOver, false);
 			break;
 #endif
+		}
+		if (servicename.size() < 1)
+		{
+			servicename = "                ";
 		}
 		showServicename(servicename);
 		showclock = true;
@@ -1062,7 +1302,17 @@
 int CVFD::getBrightness()
 {
 	//FIXME for old neutrino.conf
-#if defined (BOXMODEL_OCTAGON1008) || defined (BOXMODEL_FORTIS_HDBOX) || defined (BOXMODEL_ATEVIO7500)
+#if defined (BOXMODEL_OCTAGON1008) \
+ || defined (BOXMODEL_FORTIS_HDBOX) \
+ || defined (BOXMODEL_ATEVIO7500) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7810A) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7119) \
+ || defined (BOXMODEL_HS7429) \
+ || defined (BOXMODEL_HS7819) \
+ || defined (BOXMODEL_DP7000) \
+ || defined (BOXMODEL_ADB_BOX)
 	if(g_settings.lcd_setting[SNeutrinoSettings::LCD_BRIGHTNESS] > 7)
 		g_settings.lcd_setting[SNeutrinoSettings::LCD_BRIGHTNESS] = 7;
 #else
@@ -1084,7 +1334,17 @@
 int CVFD::getBrightnessStandby()
 {
 	//FIXME for old neutrino.conf
-#if defined (BOXMODEL_OCTAGON1008) || defined (BOXMODEL_FORTIS_HDBOX) || defined (BOXMODEL_ATEVIO7500)
+#if defined (BOXMODEL_OCTAGON1008) \
+ || defined (BOXMODEL_FORTIS_HDBOX) \
+ || defined (BOXMODEL_ATEVIO7500) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7810A) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7119) \
+ || defined (BOXMODEL_HS7429) \
+ || defined (BOXMODEL_HS7819) \
+ || defined (BOXMODEL_DP7000) \
+ || defined (BOXMODEL_ADB_BOX)
 	if(g_settings.lcd_setting[SNeutrinoSettings::LCD_STANDBY_BRIGHTNESS] > 7)
 		g_settings.lcd_setting[SNeutrinoSettings::LCD_STANDBY_BRIGHTNESS] = 7;
 #else
@@ -1105,7 +1365,17 @@
 int CVFD::getBrightnessDeepStandby()
 {
 	//FIXME for old neutrino.conf
-#if defined (BOXMODEL_OCTAGON1008) || defined (BOXMODEL_FORTIS_HDBOX) || defined (BOXMODEL_ATEVIO7500)
+#if defined (BOXMODEL_OCTAGON1008) \
+ || defined (BOXMODEL_FORTIS_HDBOX) \
+ || defined (BOXMODEL_ATEVIO7500) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7810A) \
+ || defined (BOXMODEL_HS7420) \
+ || defined (BOXMODEL_HS7119) \
+ || defined (BOXMODEL_HS7429) \
+ || defined (BOXMODEL_HS7819) \
+ || defined (BOXMODEL_DP7000) \
+ || defined (BOXMODEL_ADB_BOX)
 	if(g_settings.lcd_setting[SNeutrinoSettings::LCD_DEEPSTANDBY_BRIGHTNESS] > 7)
 		g_settings.lcd_setting[SNeutrinoSettings::LCD_DEEPSTANDBY_BRIGHTNESS] = 7;
 #else
@@ -1176,14 +1446,28 @@
 	else
 		text.clear();
 #else
-#if defined (BOXMODEL_CUBEREVO_250HD) || defined (BOXMODEL_IPBOX55)
+#if defined (BOXMODEL_HS7810A) \
+ || defined (BOXMODEL_HS7119) \
+ || defined (BOXMODEL_HS7819) \
+ || defined (BOXMODEL_CUBEREVO_250HD) \
+ || defined (BOXMODEL_IPBOX55)
 	ShowText("    ");
-#elif defined (BOXMODEL_OCTAGON1008) || defined (BOXMODEL_TF7700)
+#elif defined (BOXMODEL_OCTAGON1008) \
+ ||   defined (BOXMODEL_HS7420) \
+ ||   defined (BOXMODEL_HS7429) \
+ ||   defined (BOXMODEL_DP7000) \
+ ||   defined (BOXMODEL_TF7700)
 	ShowText("        ");
-#elif defined (BOXMODEL_FORTIS_HDBOX) || defined (BOXMODEL_ATEVIO7500)
+#elif defined (BOXMODEL_FORTIS_HDBOX) \
+ ||   defined (BOXMODEL_ATEVIO7500)
 	ShowText("            ");
-#elif defined (BOXMODEL_IPBOX9900) || defined (BOXMODEL_IPBOX99)
+#elif defined (BOXMODEL_IPBOX9900) \
+ ||   defined (BOXMODEL_IPBOX99)
 	ShowText("              ");
+#elif defined (BOXMODEL_ADB_BOX)
+	ShowText("               ");
+#elif !defined (BOXMODEL_HS7110)
+	ShowText("                ");
 #endif
 #endif
 }
@@ -1191,25 +1475,52 @@
 void CVFD::ShowIcon(fp_icon icon, bool show)
 {
 #if !HAVE_DUCKBOX_HARDWARE
-	if(!has_lcd || fd < 0) return;
-//printf("CVFD::ShowIcon %s %x\n", show ? "show" : "hide", (int) icon);
+	if (!has_lcd || fd < 0)
+		return;
+//	printf("CVFD::ShowIcon %s %02d\n", show ? "show" : "hide", (int) icon);
 	int ret = ioctl(fd, show ? IOC_FP_SET_ICON : IOC_FP_CLEAR_ICON, icon);
 	if(ret < 0)
 		perror(show ? "IOC_FP_SET_ICON" : "IOC_FP_CLEAR_ICON");
 #else
-#if defined (BOXMODEL_ATEVIO7500)
+    #if defined (BOXMODEL_HS7110)
 	return;
-#endif
+    #endif
 	if (icon == 0)
 		return;
 
+  #if !defined (BOXMODEL_OCTAGON1008) \
+   && !defined (BOXMODEL_FORTIS_HDBOX) \
+   && !defined (BOXMODEL_ATEVIO7500) \
+   && !defined (BOXMODEL_HS7420) \
+   && !defined (BOXMODEL_HS7810A) \
+   && !defined (BOXMODEL_HS7420) \
+   && !defined (BOXMODEL_HS7119) \
+   && !defined (BOXMODEL_HS7429) \
+   && !defined (BOXMODEL_HS7819) \
+   && !defined (BOXMODEL_DP7000) \
+   && !defined (BOXMODEL_ADB_BOX)
 	if (active_icon[icon & 0x0F] == show)
 		return;
 	else
 		active_icon[icon & 0x0F] = show;
-
-	//printf("CVFD::ShowIcon %s %x\n", show ? "show" : "hide", (int) icon);
+  #endif
+//	printf("CVFD::ShowIcon %s #%02d\n", show ? "show" : "hide", (int) icon);
+
 	struct vfd_ioctl_data data;
+
+  #if defined (BOXMODEL_ADB_BOX)
+	if ((adb_led == 1 && icon == FP_ICON_CLOCK) || (adb_led == 0 && icon == FP_ICON_REC))
+	{
+		memset(&data, 0, sizeof(struct vfd_ioctl_data));
+		data.start = 0x02;  // timer/REC LED
+		data.data[0] = 0;
+		data.data[1] = 0;
+		data.data[3] = show;
+		data.data[4] = 0;
+		data.length = 5;
+		write_to_vfd(VFDSETLED, &data);
+	}  // and fall through to
+  #endif
 	memset(&data, 0, sizeof(struct vfd_ioctl_data));
 	data.start = 0x00;
 	data.data[0] = icon;
@@ -1223,17 +1534,12 @@
 #ifdef HAVE_DUCKBOX_HARDWARE
 void CVFD::ClearIcons()
 {
-#if defined (BOXMODEL_ATEVIO7500)
+  #if defined (BOXMODEL_HS7110)
 	return;
-#endif
-	for (int id = 0x10; id < FP_ICON_MAX; id++) {
-#if defined (BOXMODEL_OCTAGON1008)
+  #endif
+//	printf("CVFD::ClearIcons, min=%02d, max=%02d\n", FP_ICON_MIN, FP_ICON_MAX);
+	for (int id = FP_ICON_MIN; id < FP_ICON_MAX; id++) {
 		if (id != FP_ICON_USB && id != FP_ICON_HDD)
-#elif defined(BOXMODEL_FORTIS_HDBOX) || defined (BOXMODEL_TF7700)
-		if (id != FP_ICON_USB)
-#else
-		if (id != 0x10 && id != 0x12)
-#endif
 			ShowIcon((fp_icon)id, false);
 	}
 	return;
@@ -1244,8 +1550,14 @@
 	memset(g_str, 0, sizeof(g_str));
 	memcpy(g_str, str, sizeof(g_str)-1);
 
+	if (! str)
+	{
+		printf("CVFD::ShowText: str is NULL!\n");
+		return;
+	}
 	int i = strlen(str);
-	if (i > 63) {
+	if (i > 63)
+	{
 		g_str[60] = '.';
 		g_str[61] = '.';
 		g_str[62] = '.';
@@ -1254,10 +1566,13 @@
 	}
 	ShowNormalText(g_str, false);
 }
+
 void CVFD::repaintIcons()
 {
-#if BOXMODEL_UFS912 || BOXMODEL_UFS913
+#if BOXMODEL_UFS912 \
+ || BOXMODEL_UFS913
 	bool tmp_icon[16] = {false};
+
 	printf("VFD repaint icons\n");
 	for (int i = 0x10; i < FP_ICON_MAX; i++)
 	{
@@ -1267,7 +1582,7 @@
 	}
 #endif
 }
-#else
+#else // non-duckbox
 void CVFD::ShowText(const char * str)
 {
 	if (fd < 0 || !support_text)
@@ -1307,11 +1622,26 @@
 	if (number < 0)
 		return;
 	
+//	printf("CVFD::ShowNumber: [%d]\n", number);
 #ifdef BOXMODEL_CS_HD2
 	int ret = ioctl(fd, IOC_FP_SET_NUMBER, number);
-	if(ret < 0) {
+	if (ret < 0)
+	{
 		support_numbers = false;
 		perror("IOC_FP_SET_NUMBER");
+	}
+#else
+	{
+		char buffer[VFDLENGTH + 1];
+		int n;
+
+		memset(buffer, 0, sizeof(buffer));
+  #if defined (BOXMODEL_HS7119) || defined (BOXMODEL_HS7810A) || defined (BOXMODEL_HS7819)
+		n = sprintf(buffer, "%04d", number);
+  #else
+		n = sprintf(buffer, "%4d", number);
+  #endif
+		CVFD::ShowText(buffer);
 	}
 #endif
 }
@@ -1640,5 +1970,4 @@
 }
 /*****************************************************************************************/
 #endif // VFD_UPDATE
-
-
+//vim:ts=4
#--- neutrino-mp-tangos/src/driver/pictureviewer/pictureviewer.cpp
#+++ neutrino-mp-tangos/src/driver/pictureviewer/pictureviewer.cpp
#@@ -566,8 +566,10 @@
# 
# 		// add neccessary paths to v_path
# 		v_path.clear();
#+#ifdef ENABLE_LCD4LINUX
# 		if (lcd4l_mode)
# 			v_path.push_back(g_settings.lcd4l_logodir);
#+#endif
# 		v_path.push_back(g_settings.logo_hdd_dir);
# 		if (g_settings.logo_hdd_dir != LOGODIR_VAR)
# 			v_path.push_back(LOGODIR_VAR);
#@@ -669,9 +671,11 @@
# 
# 		for (size_t f = 0; f < v_file.size(); f++)
# 		{
#+#ifdef ENABLE_LCD4LINUX
# 			// process g_settings.lcd4l_logodir
# 			if (lcd4l_mode)
# 				v_path.push_back(g_settings.lcd4l_logodir + "/" + v_file[f] + fileType[i]);
#+#endif
# 			// process g_settings.logo_hdd_dir
# 			v_path.push_back(g_settings.logo_hdd_dir + "/" + v_file[f] + fileType[i]);
# 			// process LOGODIR_VAR
--- neutrino-mp-tangos.org/lib/jsoncpp/jsoncpp.cpp
+++ neutrino-mp-tangos/lib/jsoncpp/jsoncpp.cpp
@@ -101,6 +101,8 @@
 #ifndef JSONCPP_NO_LOCALE_SUPPORT
 #include <clocale>
 #endif
+
+#include <stdio.h>
 
 /* This header provides common string manipulation support, such as UTF-8,
  * portable conversion from/to string...
--- neutrino-mp-tangos.org/src/gui/weather.h
+++ neutrino-mp-tangos/src/gui/weather.h
@@ -115,11 +115,11 @@
 		};
 		std::string getCurrentPressure()
 		{
-			return to_string(current.pressure);
+			return to_string((int)current.pressure);
 		};
 		std::string getCurrentWindSpeed()
 		{
-			return to_string(current.windSpeed);
+			return to_string((int)current.windSpeed);
 		};
 		std::string getCurrentWindBearing()
 		{
@@ -157,7 +157,7 @@
 		{
 			if (i > (int)v_forecast.size())
 				i = (int)v_forecast.size();
-			return to_string(v_forecast[i].windSpeed);
+			return to_string((int)v_forecast[i].windSpeed);
 		};
 		std::string getForecastWindBearing(int i = 0)
 		{
--- neutrino-mp-tangos.org/src/gui/movieplayer.cpp
+++ neutrino-mp-tangos/src/gui/movieplayer.cpp
@@ -82,10 +82,10 @@
 #include <iconv.h>
 #include <libdvbsub/dvbsub.h>
 #include <hardware/audio.h>
-#ifdef ENABLE_GRAPHLCD
-#include <driver/nglcd.h>
+//#ifdef ENABLE_GRAPHLCD
+//#include <driver/nglcd.h>
 bool glcd_play = false;
-#endif
+//#endif
 #include <gui/widget/stringinput_ext.h>
 #include <gui/screensetup.h>
 #include <gui/widget/msgbox.h>
@@ -1438,15 +1438,15 @@
 #if HAVE_SH4_HARDWARE
 	old3dmode = frameBuffer->get3DMode();
 #endif
-#ifdef ENABLE_GRAPHLCD
-	nGLCD::MirrorOSD(false);
-	if (p_movie_info)
-		nGLCD::lockChannel(p_movie_info->channelName, p_movie_info->epgTitle);
-	else {
-		glcd_play = true;
-		nGLCD::lockChannel(g_Locale->getText(LOCALE_MOVIEPLAYER_HEAD), file_name.c_str(), file_prozent);
-	}
-#endif
+//#ifdef ENABLE_GRAPHLCD
+//	nGLCD::MirrorOSD(false);
+//	if (p_movie_info)
+//		nGLCD::lockChannel(p_movie_info->channelName, p_movie_info->epgTitle);
+//	else {
+//		glcd_play = true;
+//		nGLCD::lockChannel(g_Locale->getText(LOCALE_MOVIEPLAYER_HEAD), file_name.c_str(), file_prozent);
+//	}
+//#endif
 	pthread_t thrStartHint = 0;
 	if (is_file_player) {
 		showStartingHint = true;
@@ -1671,14 +1671,14 @@
 
 	while (playstate >= CMoviePlayerGui::PLAY)
 	{
-#ifdef ENABLE_GRAPHLCD
-		if (p_movie_info)
-			nGLCD::lockChannel(p_movie_info->channelName, p_movie_info->epgTitle, duration ? (100 * position / duration) : 0);
-		else {
-			glcd_play = true;
-			nGLCD::lockChannel(g_Locale->getText(LOCALE_MOVIEPLAYER_HEAD), file_name.c_str(), file_prozent);
-		}
-#endif
+//#ifdef ENABLE_GRAPHLCD
+//		if (p_movie_info)
+//			nGLCD::lockChannel(p_movie_info->channelName, p_movie_info->epgTitle, duration ? (100 * position / duration) : 0);
+//		else {
+//			glcd_play = true;
+//			nGLCD::lockChannel(g_Locale->getText(LOCALE_MOVIEPLAYER_HEAD), file_name.c_str(), file_prozent);
+//		}
+//#endif
 		if (update_lcd || g_settings.movieplayer_display_playtime) {
 			update_lcd = false;
 			updateLcd(g_settings.movieplayer_display_playtime);
@@ -2262,12 +2262,12 @@
 	CScreenSetup cSS;
 	cSS.showBorder(CZapit::getInstance()->GetCurrentChannelID());
 #endif
-#ifdef ENABLE_GRAPHLCD
-	if (p_movie_info || glcd_play == true) {
-		glcd_play = false;
-		nGLCD::unlockChannel();
-	}
-#endif
+//#ifdef ENABLE_GRAPHLCD
+//	if (p_movie_info || glcd_play == true) {
+//		glcd_play = false;
+//		nGLCD::unlockChannel();
+//	}
+//#endif
 	if (iso_file) {
 		iso_file = false;
 		if (umount2(ISO_MOUNT_POINT, MNT_FORCE))
@@ -2387,10 +2387,10 @@
 		}
 		if (!movie_info.channelName.empty() || !movie_info.epgTitle.empty())
 			p_movie_info = &movie_info;
-#ifdef ENABLE_GRAPHLCD
-		if (p_movie_info)
-			nGLCD::lockChannel(p_movie_info->channelName, p_movie_info->epgTitle);
-#endif
+//#ifdef ENABLE_GRAPHLCD
+//		if (p_movie_info)
+//			nGLCD::lockChannel(p_movie_info->channelName, p_movie_info->epgTitle);
+//#endif
 	}
 
 	if (p_movie_info) {
@@ -2905,10 +2905,10 @@
 		tuxtx_pause_subtitle(true);
 		frameBuffer->paintBackground();
 	}
-#ifdef ENABLE_GRAPHLCD
-	if (enable_glcd_mirroring)
-		nGLCD::MirrorOSD(g_settings.glcd_mirror_osd);
-#endif
+//#ifdef ENABLE_GRAPHLCD
+//	if (enable_glcd_mirroring)
+//		nGLCD::MirrorOSD(g_settings.glcd_mirror_osd);
+//#endif
 #endif
 }
 
@@ -2946,9 +2946,9 @@
 {
 #if HAVE_SH4_HARDWARE || HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
 	printf("[CMoviePlayerGui] %s: %s\n", __FUNCTION__, show ? "Show" : "Not show");
-#ifdef ENABLE_GRAPHLCD
-	nGLCD::MirrorOSD(false);
-#endif
+//#ifdef ENABLE_GRAPHLCD
+//	nGLCD::MirrorOSD(false);
+//#endif
 
 	if(!show)
 		return;
--- neutrino-mp-tangos.org/src/gui/components/cc_timer.h
+++ neutrino-mp-tangos/src/gui/components/cc_timer.h
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2013-2019, Thilo Graf 'dbt'
+	Copyright (C) 2013-2015, Thilo Graf 'dbt'
 
 	License: GPL
 
@@ -30,9 +30,9 @@
 #endif
 
 #include <sigc++/signal.h>
-#include <sigc++/adaptors/retype_return.h>
-#include <thread>
-#include <mutex>
+#include <OpenThreads/ScopedLock>
+#include <OpenThreads/Thread>
+#include <OpenThreads/Condition>
 
 /**CComponentsTimer
 * 	Member of CComponents. Provides a generic timer class
@@ -43,85 +43,95 @@
 {
 	private:
 		///thread
-		std::thread  *tm_thread;
-		std::mutex tm_mutex;
-		///flag to control thread state
-		bool tm_enable;
+		pthread_t  tm_thread;
 
 		///refresh interval in seconds
-		int64_t tm_interval;
-		uint64_t tm_ticks;
+		int tm_interval;
+		
+		bool tm_enable_nano;
 
-		///runs shared timer action provided inside OnTimer() signal
-		static void threadCallback(CComponentsTimer *tm);
-
-		sigc::slot<void> sl_cleanup_timer;
-
-		std::string tn;
-
-	protected: ///name for thread
-		std::string tm_thread_name;
+		///init function to init shared timer action
+		static void* initThreadAction(void *arg);
 
 		///init function to start/stop timer in own thread
 		void initThread();
 		void stopThread();
 
+		///runs shared timer action provided inside OnTimer() signal
+		void runSharedTimerAction();
+
+		///flag to control thread state
+		bool tm_enable;
+
+		///name for the thread
+		std::string name;
+		std::string tn;
+		///mutex for timer
+		OpenThreads::Mutex tm_mutex;
+		///slot for restart signals
+		sigc::slot0<bool> sl_stop_timer;
+
+		///sleep generated with nanosleep
+		int getSleep(long miliseconds);
 	public:
 		/**Constructor for timer class
 		*
 		* @param[in]  interval
-		* 	@li int64_t interval in miliseconds, default value=1000 ms (1 sec)
+		* 	@li int interval in seconds, default value=1 (1 sec)
+		* 	If init value for interval > 0, timer starts immediately
+		* 	@li bool default = false as seconds mode, true = nano seconds mode
 		* @see
 		* 	setTimerInterval();
 		*/
-		CComponentsTimer(const int64_t& interval = 1000);
+		CComponentsTimer(const int& interval = 1, bool is_nano = false);
 
 		virtual ~CComponentsTimer();
 
-		/**Acivate timer
+		/**Starts timer thread
+		* @return
+		*	bool
+		*	returns true, if timer is running in thread
 		* @see
 		* 	stopTimer()
 		*/
-		void startTimer();
+		bool startTimer();
 
-		/**Disable timer
+		/**Stops timer thread
+		* @return
+		*	bool
+		*	returns true, if timer thread stopped
 		* @see
 		* 	startTimer()
 		*/
-		void stopTimer();
-
-		/**Cancel timer thread
-		* @see
-		* 	stopTimer()
-		*/
-		void cancelTimerThread(){stopThread();}
+		bool stopTimer();
 
 		/**get current timer status
 		* @return
 		*	bool
-		*	returns true, if timer is active
+		*	returns true, if timer is running in thread
 		* @see
 		* 	startTimer()
 		* 	stopTimer()
 		*/
-		bool isRun() const;
+		bool isRun() const {return tm_thread;};
 
 		/**set timer interval
 		* @param[in]  interval
-		* 	@li int64_t default interval in miliseconds
+		* 	@li int default interval in seconds, if second parameter = true interval is used as nano seconds
+		* 	@li bool default = false as seconds mode, true = nano seconds mode
 		* @return
 		*	void
 		* @see
 		* 	tm_interval
 		*/
-		void setTimerInterval(const int64_t& interval);
+		void setTimerInterval(const int& interval, bool is_nano = false);
 
 		/**set thread name
 		* @param[in] thread name
 		* @return
 		* 	void
 		*/
-		void setThreadName(const std::string& n) { tm_thread_name = tn = n; }
+		void setThreadName(const std::string& n) { name = tn = n; }
 
 		/**Provides a signal handler to receive any function or methode.
 		* Use this in your class where ever you need time controled actions.
--- neutrino-mp-tangos.org/src/gui/components/cc_frm.h
+++ neutrino-mp-tangos/src/gui/components/cc_frm.h
@@ -25,24 +25,21 @@
 #define __CC_FORM_H__
 
 
-
 #include "config.h"
 #include "cc_base.h"
 #include "cc_item.h"
-#include <mutex>
-#define DEFAULT_SEL_FRAME_WIDTH 1
+
 
 class CComponentsForm : public CComponentsItem
 {
 	protected:
 		std::vector<CComponentsItem*>	v_cc_items;
-		void paintForm(const bool &do_save_bg);
+		void paintForm(bool do_save_bg);
 		///generates next possible index for an item, see also cc_item_index, getIndex(), setIndex()
 		int genIndex();
 
 		///scrollbar object
 		CComponentsScrollBar *sb;
-		std::mutex cc_frm_mutex;
 
 		int append_x_offset;
 		int append_y_offset;
@@ -78,7 +75,7 @@
 		virtual ~CComponentsForm();
 
 		///paints current form on screen, for paint a page use paintPage()
-		void paint(const bool &do_save_bg = CC_SAVE_SCREEN_YES);
+		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 
 		///same like CComponentsItem::kill(), but erases all embedded items inside of parent at once, this = parent
 		///NOTE: Items always have parent bindings to "this" and use the parent background color as default! Set parameter 'ignore_parent=true' to ignore parent background color!
@@ -100,26 +97,10 @@
 		int addCCItem(const std::vector<CComponentsItem*> &cc_items);
 		void insertCCItem(const uint& cc_item_id, CComponentsItem* cc_Item);
 
-		/**Function to remove item from item collection and deallocates instance.
-		 * @param[in]  cc_item_id
-		 * 	@li item id as unsigned int
-		*/
+		///removes item object from container and deallocates instance
 		void removeCCItem(const uint& cc_item_id);
-
-		/**Function to remove item from item collection and deallocates instance.
-		 * @param[in]  cc_Item
-		 * 	@li CComponentsItem*
-		 */
+		///removes item object from container and deallocates instance
 		void removeCCItem(CComponentsItem* cc_Item);
-
-		/**Function to remove item from item collection and deallocates instance.
-		 * @param[in]  item_name
-		 * 	@li std::string
-		 * NOTE: Requires that unique names are assigned!
-		 * @see
-		 * 	getItemName()
-		 */
-		void removeCCItem(const std::string &item_name);
 
 		void replaceCCItem(const uint& cc_item_id, CComponentsItem* new_cc_Item);
 		void replaceCCItem(CComponentsItem* old_cc_Item, CComponentsItem* new_cc_Item);
@@ -132,19 +113,7 @@
 		* @return
 		*	int, in case of not found item returns -1
 		*/
-		int getCCItemId(CComponentsItem* cc_Item) const;
-
-		/**Function to get current item id from passed item name.
-		 * @param[in]  item_name
-		 * 	@li std::string
-		 * @return
-		 *	int, in case of not found item returns -1
-		 * NOTE: Requires that unique names are assigned!
-		 * @see
-		 * 	setItemName()
-		 * 	getItemName()
-		 */
-		int getCCItemId(const std::string &item_name) const;
+		int getCCItemId(CComponentsItem* cc_Item);
 
 		/**Function to get current item from item collection.
 		* @param[in]  cc_item_id
@@ -152,15 +121,7 @@
 		* @return
 		*	CComponentsItem*, in case of not found item returns NULL
 		*/
-		CComponentsItem* getCCItem(const uint& cc_item_id) const;
-
-		/**Function to get current item from item collection by name.
-		 * @param[in]  item_name
-		 * 	@li std::string
-		 * @return
-		 *	CComponentsItem*, in case of not found item returns NULL
-		 */
-		CComponentsItem* getCCItem(const std::string &item_name) const;
+		CComponentsItem* getCCItem(const uint& cc_item_id);
 
 		/**Function to get previous item from item collection.
 		* @param[in]  current_cc_item
@@ -168,7 +129,7 @@
 		* @return
 		*	CComponentsItem*, in case of not found item returns NULL
 		*/
-		CComponentsItem* getPrevCCItem(CComponentsItem* current_cc_item) const;
+		CComponentsItem* getPrevCCItem(CComponentsItem* current_cc_item);
 
 		/**Function to get next item from item collection.
 		* @param[in]  current_cc_item
@@ -176,20 +137,20 @@
 		* @return
 		*	CComponentsItem*, in case of not found item returns NULL
 		*/
-		CComponentsItem* getNextCCItem(CComponentsItem* current_cc_item) const;
+		CComponentsItem* getNextCCItem(CComponentsItem* current_cc_item);
 
 		void paintCCItems();
 
 		///clean up and deallocate existant items from v_cc_items at once
 		void clear();
 		///return true, if no items available
-		bool empty() const {return v_cc_items.empty();}
+		bool empty(){return v_cc_items.empty();};
 		///return size (count) of available items
-		size_t size() const {return v_cc_items.size();}
+		size_t size(){return v_cc_items.size();};
 		///return reference to first item
-		CComponentsItem* front() const {return v_cc_items.front();}
+		CComponentsItem* front(){return v_cc_items.front();};
 		///return reference to last item
-		CComponentsItem* back() const {return v_cc_items.back();}
+		CComponentsItem* back(){return v_cc_items.back();};
 
 		///sets alignment offset between items
 		void setAppendOffset(const int &x_offset, const int& y_offset){append_x_offset = x_offset; append_y_offset = y_offset;};
@@ -205,9 +166,9 @@
 		///sets current page
 		void setCurrentPage(const uint8_t& current_page){cur_page = current_page;};
 		///get current page
-		uint8_t getCurrentPage() const {return cur_page;}
+		uint8_t getCurrentPage(){return cur_page;};
 		///paint defined page number 0...n
-		void paintPage(const uint8_t& page_number, const bool &do_save_bg = CC_SAVE_SCREEN_NO);
+		void paintPage(const uint8_t& page_number, bool do_save_bg = CC_SAVE_SCREEN_NO);
 		///enum page scroll modes
 		enum
 		{
@@ -221,50 +182,50 @@
 		///set width of scrollbar
 		void setScrollBarWidth(const int& scrollbar_width){w_sb = scrollbar_width;};
 		///returns id of selected item, return value as int, returns -1: if is nothing selected
-		int getSelectedItem() const;
+		int getSelectedItem();
 
 		/**Function to get consumed  space of items inside form in y direction.
 		* @return
 		*	int, used lines
 		*/
-		int getUsedDY() const;
+		int getUsedDY();
 
 		/**Function to get consumed  space of items inside form in x direction.
 		* @return
 		*	int, used lines
 		*/
-		int getUsedDX() const;
+		int getUsedDX();
 
 		/**Function to get free usable space of items inside form in y direction.
 		* @return
 		*	int, free lines
 		*/
-		int getFreeDY() const {return height - getUsedDY();}
+		int getFreeDY(){return height - getUsedDY();}
 
 		/**Function to get free usable space of items inside form in x direction.
 		* @return
 		*	int, free lines
 		*/
-		int getFreeDX() const {return width - getUsedDX();}
+		int getFreeDX(){return width - getUsedDX();}
 
 		///returns pointer to selected item, return value as CComponentsItem*, returns NULL: if is nothing selected
-		CComponentsItem* getSelectedItemObject() const;
+		CComponentsItem* getSelectedItemObject();
 		///select a definied item, parameter1 as size_t
 		void setSelectedItem(	int item_id,
 						const fb_pixel_t& sel_frame_col = COL_MENUCONTENTSELECTED_PLUS_0,
 						const fb_pixel_t& frame_col = COL_FRAME_PLUS_0,
 						const fb_pixel_t& sel_body_col = COL_MENUCONTENT_PLUS_0,
 						const fb_pixel_t& body_col = COL_MENUCONTENT_PLUS_0,
-						const int& frame_w = DEFAULT_SEL_FRAME_WIDTH,
-						const int& sel_frame_w = DEFAULT_SEL_FRAME_WIDTH);
+						const int& frame_w = 3,
+						const int& sel_frame_w = 3);
 		///select a definied item, parameter1 as CComponentsItem*
 		void setSelectedItem(	CComponentsItem* cc_item,
 						const fb_pixel_t& sel_frame_col = COL_MENUCONTENTSELECTED_PLUS_0,
 						const fb_pixel_t& frame_col = COL_FRAME_PLUS_0,
 						const fb_pixel_t& sel_body_col = COL_MENUCONTENT_PLUS_0,
 						const fb_pixel_t& body_col = COL_MENUCONTENT_PLUS_0,
-						const int& frame_w = DEFAULT_SEL_FRAME_WIDTH,
-						const int& sel_frame_w = DEFAULT_SEL_FRAME_WIDTH);
+						const int& frame_w = 3,
+						const int& sel_frame_w = 3);
 
 		///exec main method, see also sub exec methods
 		int exec();
--- neutrino-mp-tangos.org/src/gui/components/cc_frm_clock.h
+++ neutrino-mp-tangos/src/gui/components/cc_frm_clock.h
@@ -3,7 +3,7 @@
 	Copyright (C) 2001 by Steffen Hehn 'McClean'
 
 	Classes for generic GUI-related components.
-	Copyright (C) 2012-2019, Thilo Graf 'dbt'
+	Copyright (C) 2012-2015, Thilo Graf 'dbt'
 
 	License: GPL
 
@@ -36,7 +36,6 @@
 #include "cc_frm.h"
 #include "cc_text_screen.h"
 #include "cc_timer.h"
-
 //! Sub class of CComponents. Show clock with digits on screen. 
 /*!
 Usable as simple fixed display or as ticking clock.
@@ -46,19 +45,22 @@
 class CComponentsFrmClock : public CComponentsForm, public CCTextScreen
 {
 	private:
+		CComponentsTimer *cl_timer;
 		void ShowTime();
 		bool may_blit;
 
 	protected:
-		CComponentsTimer *cl_timer;
-
-		std::mutex cl_mutex;
+		///slot for timer event, reserved for ShowTime()
+		sigc::slot0<void> cl_sl_show;
 
 		///refresh interval in seconds
-		int64_t cl_interval;
+		int cl_interval;
 
 		///raw time chars
 		char cl_timestr[32];
+
+		///handle paint clock within thread and is not similar to cc_allow_paint
+		bool cl_blocked;
 
 		///object: font render object
 		Font *cl_font;
@@ -76,8 +78,6 @@
 		std::string cl_format_str;
 		///secondary time format for blink
 		std::string cl_blink_str;
-
-		int cl_width;
 
 		///initialize clock contents  
 		void initCCLockItems();
@@ -98,9 +98,9 @@
 		CComponentsFrmClock( 	const int& x_pos = 1, const int& y_pos = 1,
 					Font * font = NULL,
 					const char* format_str = "%H:%M",
-					const char* secformat_str = "%H.%M",
+					const char* secformat_str = NULL,
 					bool activ=false,
-					const int64_t& interval_seconds = 1,
+					const int& interval_seconds = 1,
 					CComponentsForm *parent = NULL,
 					int shadow_mode = CC_SHADOW_OFF,
 					fb_pixel_t color_frame = COL_FRAME_PLUS_0,
@@ -125,9 +125,6 @@
 		///return pointer of font object
 		Font* getClockFont();
 
-		///return pointer of timer object
-		CComponentsTimer* getTimer(){return cl_timer;}
-
 		///set text color
 		void setTextColor(fb_pixel_t color_text){ cl_col_text = color_text;}
 
@@ -135,8 +132,6 @@
 		void setHeight(const int& h);
 		///set width of clock on screen
 		void setWidth(const int& w);
-		
-		int getWidth() const;
 
 		///use string expession: "%H:%M" = 12:22, "%H:%M:%S" = 12:22:12
 		///set current time format string, 1st parameter set the default format, 2nd parameter sets an alternatively format for use as blink effect
@@ -147,21 +142,21 @@
 		///start and paint ticking clock
 		bool Start();
 		///same like Start() but for usage as simple call without return value
-		void unblock(){if (cl_timer) cl_timer->OnTimer.unblock();}
+		void unblock(){Start();}
 		///stop ticking clock, but don't hide, use kill() or hide() to remove from screen
 		bool Stop();
 		///same like Stop() but for usage as simple call without return value
-		void block(){if (cl_timer) cl_timer->OnTimer.block();}
+		void block(){Stop();}
 		///return true on blocked status, blocked means clock can be initalized but would be not paint, to unblock use unblock()
-		bool isBlocked(void) const {return cl_timer ? cl_timer->OnTimer.blocked() : true;}
+		bool isBlocked(void) {return cl_blocked;}
 
 		///returns true, if clock is running
 		bool isRun() const {return cl_timer ? cl_timer->isRun() : false;}
 		///set refresh interval in seconds, default value=1 (=1 sec)
-		void setClockInterval(const int64_t& seconds){cl_interval = seconds*1000;}
+		void setClockInterval(const int& seconds){cl_interval = seconds;}
 
 		///show clock on screen
-		void paint(const bool &do_save_bg = CC_SAVE_SCREEN_YES);
+		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 		///hide clock on screen
 		void hide(){Stop(); CComponentsForm::hide();}
 		///does the same like kill() from base class, but stopping clock before kill
@@ -190,9 +185,6 @@
 		///set color gradient on/off, returns true if gradient mode was changed
 		bool enableColBodyGradient(const int& enable_mode, const fb_pixel_t& sec_color = 255 /*=COL_BACKGROUND*/);
 
-		///slot for timer event, reserved for ShowTime()
-		sigc::slot0<void> cl_sl_show;
-
 		///enable/disable automatic blitting
 		void setBlit(bool _may_blit = true) { may_blit = _may_blit; }
 };
--- neutrino-mp-tangos.org/src/gui/components/cc_item_text.h
+++ neutrino-mp-tangos/src/gui/components/cc_item_text.h
@@ -31,7 +31,6 @@
 #include "cc_text_screen.h"
 #include <gui/widget/textbox.h>
 #include <string>
-#include <mutex>
 
 //! Sub class of CComponentsItem. Shows a text box.
 /*!
@@ -77,8 +76,6 @@
 		///helper: convert int to string
 		static std::string iToString(int int_val); //helper to convert int to string
 
-		std::mutex ct_mutex;
-
 		///initialize all required attributes
 		void initVarText(	const int x_pos, const int y_pos, const int w, const int h,
 					std::string text,
@@ -99,7 +96,7 @@
 		void initCBox();
 
 		///paint CCItem backckrond (if paint_bg=true), apply initCCText() and send paint() to the CTextBox object
-		void paintText(const bool &do_save_bg = CC_SAVE_SCREEN_YES);
+		void paintText(bool do_save_bg = CC_SAVE_SCREEN_YES);
 	public:
 		enum {
 			FONT_STYLE_REGULAR	= 0,
@@ -139,7 +136,7 @@
 		///remove textbox from screen
 		void kill(const fb_pixel_t& bg_color = COL_BACKGROUND_PLUS_0, const int& corner_radius = -1, const int& fblayer_type = CC_FBDATA_TYPES);
 		///paint text box, parameter do_save_bg: default = true, causes fill of backckrond pixel buffer
-		void paint(const bool &do_save_bg = CC_SAVE_SCREEN_YES);
+		void paint(bool do_save_bg = CC_SAVE_SCREEN_YES);
 
 		///send options for text font (size and type), color and mode (allignment)
 		 void setTextFont(Font* font_text);
@@ -277,8 +274,7 @@
 					fb_pixel_t color_shadow = COL_SHADOW_PLUS_0)
 					:CComponentsText(x_pos, y_pos, w, h, text, mode, font_text, font_style, parent, shadow_mode, color_text, color_frame, color_body, color_shadow)
 		{
-			cc_item_type.id 	= CC_ITEMTYPE_LABEL;
-			cc_item_type.name	="cc_label_box";
+			cc_item_type 	= CC_ITEMTYPE_LABEL;
 		};
 
 		CComponentsLabel(	CComponentsForm *parent,
@@ -294,8 +290,7 @@
 					fb_pixel_t color_shadow = COL_SHADOW_PLUS_0)
 					:CComponentsText(x_pos, y_pos, w, h, text, mode, font_text, font_style, parent, shadow_mode, color_text, color_frame, color_body, color_shadow)
 		{
-			cc_item_type.id		= CC_ITEMTYPE_LABEL;
-			cc_item_type.name	="cc_label_box";
+			cc_item_type 	= CC_ITEMTYPE_LABEL;
 		};
 };
 

