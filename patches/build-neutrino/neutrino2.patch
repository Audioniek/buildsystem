# Commit 0d83b45f970203e4b910eddee97ee907479578a8  09/07/2022
--- neutrino2.org/acinclude.m4
+++ neutrino2/acinclude.m4
@@ -171,10 +171,14 @@
 AC_DEFUN([TUXBOX_BOXTYPE],[
 
 AC_ARG_WITH(boxtype,
-	[  --with-boxtype          valid values: generic,dgs,gigablue,dreambox,xtrend,fulan,kathrein,ipbox,topfield,fortis_hdbox,octagon,atevio,adb_box,whitebox,vip,homecast,vuplus,azbox,technomate,coolstream,hypercube,venton,xp1000,odin,ixuss,iqonios,e3hd,ebox5000,wetek,edision,hd,gi,xpeedc,formuler,miraclebox,spycat,xsarius,zgemma,wwio],
+	[  --with-boxtype          valid values: generic,duckbox,dgs,gigablue,dreambox,xtrend,fulan,kathrein,ipbox,topfield,fs9000,octagon,atevio,hs7,adb_box,adb_2850,vip_v1,vip_2,vip2,homecast,vitamin_hd5000,pace7241,opt9600,vuplus,azbox,technomate,coolstream,hypercube,venton,xp1000,odin,ixuss,iqonios,e3hd,ebox5000,wetek,edision,hd,gi,xpeedc,formuler,miraclebox,spycat,xsarius,zgemma],
 	[case "${withval}" in
-		generic|dgs|gigablue|dreambox|xtrend|fulan|kathrein|ipbox|hl101|topfield|fortis_hdbox|octagon|atevio|adb_box|whitebox|vip|homecast|vuplus|azbox|technomate|coolstream|hypercube|venton|xp1000|odin|ixuss|iqonios|e3hd|ebox5000|wetek|edision|hd|gi|xpeedc|formuler|miraclebox|spycat|xsarius|zgemma|wwio)
+		generic|duckbox|dgs|gigablue|dreambox|xtrend|fulan|kathrein|ipbox|hl101|vuplus|azbox|technomate|coolstream|hypercube|venton|xp1000|odin|ixuss|iqonios|e3hd|ebox5000|wetek|edision|hd|gi|xpeedc|formuler|miraclebox|spycat|xsarius|zgemma)
 			BOXTYPE="$withval"
+			;;
+		atemio*)
+			BOXTYPE="atemio"
+			BOXMODEL="$withval"
 			;;
 		cu*)
 			BOXTYPE="dgs"
@@ -184,7 +188,6 @@
 			BOXTYPE="gigablue"
 			BOXMODEL="$withval"
 			;;
-
 		tf*)
 			BOXTYPE="topfield"
 			BOXMODEL="$withval"
@@ -213,12 +216,32 @@
 			BOXTYPE="duckbox"
 			BOXMODEL="$withval"
 			;;	
-		at*)
-			BOXTYPE="atevio"
-			BOXMODEL="$withval"
-			;;
-		oct*)
-			BOXTYPE="octagon"
+		fs9*)
+			BOXTYPE="fortis"
+			BOXMODEL="$withval"
+			;;
+		hs*)
+			BOXTYPE="fortis"
+			BOXMODEL="$withval"
+			;;
+		vip*)
+			BOXTYPE="vip"
+			BOXMODEL="$withval"
+			;;
+		adb*)
+			BOXTYPE="adb"
+			BOXMODEL="$withval"
+			;;
+		pace*)
+			BOXTYPE="pace"
+			BOXMODEL="$withval"
+			;;
+		vita*)
+			BOXTYPE="vitamin"
+			BOXMODEL="$withval"
+			;;
+		opt*)
+			BOXTYPE="opticum"
 			BOXMODEL="$withval"
 			;;
 		vu*)
@@ -323,9 +346,13 @@
 				valid for kathrein: ufs910, ufs922, ufs912, ufs913, ufc960
 				valid for ipbox: ipbox55, ipbox99, ipbox9900
 				valid for ipbox: hl101
-				valid for atevio: atevio700,atevio7000,atevio7500,atevio7600
-				valid for octagon: octagon1008
 				valid for topfield: tf7700
+				valid for vip: vip1_v1, vip1_v2, vip2
+				valid for adb: adb_box, adb_2850
+				valid for atemio: atemio520
+				valid for pace: pace7241
+				valid for vitamin_hd5000: vitamin_hd5000
+				valid for opticum: opt9600
 				valid for vuplus: vusolo,vuduo,vuuno,vuultimo,vuduo2,vusolo2,vusolo4k,vusolose,vuzero,vuduo4k
 				valid for azbox: azboxhd,azboxme,azboxminime
 				valid for technomate: tmtwin,tm2t,tmsingle,tmnano
@@ -387,6 +414,13 @@
 				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
 			fi
 			;;
+		tf7700)
+			if test "$BOXTYPE" = "topfield"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
 		ufs910|ufs912|ufs913|ufs922|ufc960)
 			if test "$BOXTYPE" = "kathrein"; then
 				BOXMODEL="$withval"
@@ -408,15 +442,50 @@
 				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
 			fi
 			;;
-		atevio700|atevio7000|atevio7500|atevio7600)
-			if test "$BOXTYPE" = "atevio"; then
-				BOXMODEL="$withval"
-			else
-				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
-			fi
-			;;
-		octagon1008)
-			if test "$BOXTYPE" = "octagon"; then
+		fs9000|hs7110|hs7420|hs7810a|hs7119|hs7429|hs7819|hs8200|hs9510)
+			if test "$BOXTYPE" = "fortis"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		vip1_v1|vip1_v2|vip2)
+			if test "$BOXTYPE" = "vip"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		adb_box|adb_2850)
+			if test "$BOXTYPE" = "adb"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		atemio520)
+			if test "$BOXTYPE" = "atemio"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		pace7241)
+			if test "$BOXTYPE" = "pace"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		vitamin_hd5000)
+			if test "$BOXTYPE" = "vitamin"; then
+				BOXMODEL="$withval"
+			else
+				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
+			fi
+			;;
+		opt9600)
+			if test "$BOXTYPE" = "opticum"; then
 				BOXMODEL="$withval"
 			else
 				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
@@ -594,7 +663,7 @@
 			AC_MSG_ERROR([unsupported value $withval for --with-boxmodel])
 			;;
 	esac],
-	[if test "$BOXTYPE" = "dgs" -o "$BOXTYPE" = "gigablue" -o "$BOXTYPE" = "dreambox" -o "$BOXTYPE" = "xtrend" -o "$BOXTYPE" = "fulan" -o "$BOXTYPE" = "kathrein" -o "$BOXTYPE" = "ipbox" -o "$BOXTYPE" = "atevio" -o "$BOXTYPE" = "octagon" -o "$BOXTYPE" = "vuplus" -o "$BOXTYPE" = "technomate" -o "$BOXTYPE" = "venton" -o "$BOXTYPE" = "ixuss" -o "$BOXTYPE" = "iqonios" -o "$BOXTYPE" = "odin" -o "$BOXTYPE" = "edision" -o "$BOXTYPE" = "hd" -o "$BOXTYPE" = "gi" -o "$BOXTYPE" = "formuler" -o "$BOXTYPE" = "miraclebox" -o "$BOXTYPE" = "spycat" -o "$BOXTYPE" = "xsarius" -o "$BOXTYPE" = "zgemma" -o "$BOXTYPE" = "wwio" && test -z "$BOXMODEL"; then
+	[if test "$BOXTYPE" = "dgs" -o "$BOXTYPE" = "duckbox"-o "$BOXTYPE" = "gigablue" -o "$BOXTYPE" = "dreambox" -o "$BOXTYPE" = "xtrend" -o "$BOXTYPE" = "fulan" -o "$BOXTYPE" = "kathrein" -o "$BOXTYPE" = "ipbox" -o "$BOXTYPE" = "atevio" -o "$BOXTYPE" = "octagon" -o "$BOXTYPE" = "hs7" -o "$BOXTYPE" = "pace" -o "$BOXTYPE" = "adb" -o "$BOXTYPE" = "vitamin" -o "$BOXTYPE" = "vuplus" -o "$BOXTYPE" = "technomate" -o "$BOXTYPE" = "venton" -o "$BOXTYPE" = "ixuss" -o "$BOXTYPE" = "iqonios" -o "$BOXTYPE" = "odin" -o "$BOXTYPE" = "edision" -o "$BOXTYPE" = "hd" -o "$BOXTYPE" = "gi" -o "$BOXTYPE" = "formuler" -o "$BOXTYPE" = "miraclebox" -o "$BOXTYPE" = "spycat" -o "$BOXTYPE" = "xsarius" -o "$BOXTYPE" = "zgemma" && test -z "$BOXMODEL"; then
 		AC_MSG_ERROR([this boxtype $BOXTYPE needs --with-boxmodel])
 	fi])
 
@@ -610,11 +679,10 @@
 AM_CONDITIONAL(BOXTYPE_KATHREIN, test "$BOXTYPE" = "kathrein")
 AM_CONDITIONAL(BOXTYPE_IPBOX, test "$BOXTYPE" = "ipbox")
 AM_CONDITIONAL(BOXTYPE_HL101, test "$BOXTYPE" = "hl101")
-AM_CONDITIONAL(BOXTYPE_TOPFIELD, test "$BOXTYPE" = "toptfield")
-AM_CONDITIONAL(BOXTYPE_FORTIS_HDBOX, test "$BOXTYPE" = "fortis_hdbox")
-AM_CONDITIONAL(BOXTYPE_OCTAGON, test "$BOXTYPE" = "octagon")
-AM_CONDITIONAL(BOXTYPE_ATEVIO, test "$BOXTYPE" = "atevio")
+AM_CONDITIONAL(BOXTYPE_TOPFIELD, test "$BOXTYPE" = "topfield")
+AM_CONDITIONAL(BOXTYPE_FORTIS, test "$BOXTYPE" = "fortis")
 AM_CONDITIONAL(BOXTYPE_ADB_BOX, test "$BOXTYPE" = "adb_box")
+AM_CONDITIONAL(BOXTYPE_ATEMIO, test "$BOXTYPE" = "atemio")
 AM_CONDITIONAL(BOXTYPE_WHITEBOX, test "$BOXTYPE" = "whitebox")
 AM_CONDITIONAL(BOXTYPE_VIP, test "$BOXTYPE" = "vip")
 AM_CONDITIONAL(BOXTYPE_HOMECAST, test "$BOXTYPE" = "homecast")
@@ -644,6 +712,7 @@
 AM_CONDITIONAL(BOXTYPE_ZGEMMA, test "$BOXTYPE" = "zgemma")
 AM_CONDITIONAL(BOXTYPE_WWIO, test "$BOXTYPE" = "wwio")
 
+# BOXMODEL is a model within a brand
 AM_CONDITIONAL(BOXMODEL_CUBEREVO, test "$BOXMODEL" = "cuberevo")
 AM_CONDITIONAL(BOXMODEL_CUBEREVO_MINI, test "$BOXMODEL" = "cuberevo_mini")
 AM_CONDITIONAL(BOXMODEL_CUBEREVO_MINI2, test "$BOXMODEL" = "cuberevo_mini2")
@@ -686,6 +755,8 @@
 AM_CONDITIONAL(BOXMODEL_SPARK,test "$BOXMODEL" = "spark")
 AM_CONDITIONAL(BOXMODEL_SPARK7162,test "$BOXMODEL" = "spark7162")
 
+AM_CONDITIONAL(BOXMODEL_TF7700, test "$BOXMODEL" = "tf7700")
+
 AM_CONDITIONAL(BOXMODEL_UFS910, test "$BOXMODEL" = "ufs910")
 AM_CONDITIONAL(BOXMODEL_UFS912, test "$BOXMODEL" = "ufs912")
 AM_CONDITIONAL(BOXMODEL_UFS913, test "$BOXMODEL" = "ufs913")
@@ -698,12 +769,25 @@
 
 AM_CONDITIONAL(BOXMODEL_HL101, test "$BOXMODEL" = "hl101")
 
-AM_CONDITIONAL(BOXMODEL_ATEVIO700, test "$BOXMODEL" = "atevio700")
-AM_CONDITIONAL(BOXMODEL_ATEVIO7000, test "$BOXMODEL" = "atevio7000")
-AM_CONDITIONAL(BOXMODEL_ATEVIO7500, test "$BOXMODEL" = "atevio7500")
-AM_CONDITIONAL(BOXMODEL_ATEVIO7600, test "$BOXMODEL" = "atevio7600")
-
-AM_CONDITIONAL(BOXMODEL_OCTAGON_1008, test "$BOXMODEL" = "octagon1008")
+AM_CONDITIONAL(BOXMODEL_FS9000, test "$BOXMODEL" = "fs9000")
+AM_CONDITIONAL(BOXMODEL_HS7110, test "$BOXMODEL" = "hs7110")
+AM_CONDITIONAL(BOXMODEL_HS7420, test "$BOXMODEL" = "hs7420")
+AM_CONDITIONAL(BOXMODEL_HS7810A, test "$BOXMODEL" = "hs7810a")
+AM_CONDITIONAL(BOXMODEL_HS7119, test "$BOXMODEL" = "hs7119")
+AM_CONDITIONAL(BOXMODEL_HS7429, test "$BOXMODEL" = "hs7429")
+AM_CONDITIONAL(BOXMODEL_HS7819, test "$BOXMODEL" = "hs7819")
+AM_CONDITIONAL(BOXMODEL_HS8200, test "$BOXMODEL" = "hs8200")
+AM_CONDITIONAL(BOXMODEL_HS9510, test "$BOXMODEL" = "hs9510")
+
+AM_CONDITIONAL(BOXMODEL_VIP1_V1, test "$BOXMODEL" = "vip1_v1")
+AM_CONDITIONAL(BOXMODEL_VIP1_V2, test "$BOXMODEL" = "vip1_v2")
+AM_CONDITIONAL(BOXMODEL_VIP2, test "$BOXMODEL" = "vip2")
+AM_CONDITIONAL(BOXMODEL_ADB_BOX, test "$BOXMODEL" = "adb_box")
+AM_CONDITIONAL(BOXMODEL_ADB_2850, test "$BOXMODEL" = "adb_2850")
+AM_CONDITIONAL(BOXMODEL_PACE7241, test "$BOXMODEL" = "pace7241")
+AM_CONDITIONAL(BOXMODEL_VITAMIN_HD5000, test "$BOXMODEL" = "vitamin_hd5000")
+AM_CONDITIONAL(BOXMODEL_OPT9600, test "$BOXMODEL" = "opt9600")
+AM_CONDITIONAL(BOXMODEL_ATEMIO520, test "$BOXMODEL" = "atemio520")
 
 AM_CONDITIONAL(BOXMODEL_VUSOLO2, test "$BOXMODEL" = "vusolo2")
 AM_CONDITIONAL(BOXMODEL_VUDUO2, test "$BOXMODEL" = "vuduo2")
@@ -793,6 +877,7 @@
 
 AM_CONDITIONAL(BOXMODEL_BRE2ZE4K, test "$BOXMODEL" = "bre2ze4k")
 
+# PLATFORM is derived from a BOXTYPE (a brand)
 if test "$BOXTYPE" = "generic"; then
 	AC_DEFINE(PLATFORM_GENERIC, 1, [building for generic])
 elif test "$BOXTYPE" = "dgs"; then
@@ -813,18 +898,20 @@
 	AC_DEFINE(HAVE_DUCKBOX_HARDWARE, 1, [building for a duckbox])	
 elif test "$BOXTYPE" = "topfield"; then
 	AC_DEFINE(PLATFORM_TF7700, 1, [building for topfield])
-elif test "$BOXTYPE" = "fortis_hdbox"; then
-	AC_DEFINE(PLATFORM_FORTIS_HDBOX, 1, [building for fortis_hdbox])
-elif test "$BOXTYPE" = "octagon"; then
-	AC_DEFINE(PLATFORM_OCTAGON, 1, [building for octagon])
-elif test "$BOXTYPE" = "atevio"; then
-	AC_DEFINE(PLATFORM_ATEVIO, 1, [building for atevio])
-elif test "$BOXTYPE" = "adb_box"; then
-	AC_DEFINE(PLATFORM_ADB_BOX, 1, [building for adb_box])
-elif test "$BOXTYPE" = "whitebox"; then
-	AC_DEFINE(PLATFORM_WHITEBOX, 1, [building for whitebox])
+elif test "$BOXTYPE" = "fortis"; then
+	AC_DEFINE(PLATFORM_FORTIS, 1, [building for fortis])
+elif test "$BOXTYPE" = "adb"; then
+	AC_DEFINE(PLATFORM_ADB, 1, [building for adb])
+elif test "$BOXTYPE" = "atemio"; then
+	AC_DEFINE(PLATFORM_ATEMIO, 1, [building for atemio])
+elif test "$BOXTYPE" = "pace"; then
+	AC_DEFINE(PLATFORM_PACE, 1, [building for pace])
+elif test "$BOXTYPE" = "vitamin"; then
+	AC_DEFINE(PLATFORM_VITAMIN, 1, [building for vitamin])
 elif test "$BOXTYPE" = "vip"; then
 	AC_DEFINE(PLATFORM_VIP, 1, [building for vip])
+elif test "$BOXTYPE" = "opticum"; then
+	AC_DEFINE(PLATFORM_OPTICUM, 1, [building for opticum])
 elif test "$BOXTYPE" = "homecast"; then
 	AC_DEFINE(PLATFORM_HOMECAST, 1, [building for homecast])
 elif test "$BOXTYPE" = "vuplus"; then
@@ -875,6 +962,7 @@
 	AC_DEFINE(PLATFORM_WWIO, 1, [building for wwio])
 fi
 
+# Define the BOXMODELs
 if test "$BOXMODEL" = "cuberevo"; then
 	AC_DEFINE(PLATFORM_CUBEREVO, 1, [building for cuberevo])
 elif test "$BOXMODEL" = "cuberevo_mini"; then
@@ -948,6 +1036,9 @@
 elif test "$BOXMODEL" = "spark7162"; then
 	AC_DEFINE(PLATFORM_SPARK7162, 1, [building for spark 7162])
 
+elif test "$BOXMODEL" = "tf7700"; then
+	AC_DEFINE(BOXMODEL_TF7700, 1, [building for topfield tf7700])
+
 elif test "$BOXMODEL" = "ufs910"; then
 	AC_DEFINE(PLATFORM_UFS910, 1, [building for ufs910])
 elif test "$BOXMODEL" = "ufs912"; then
@@ -969,17 +1060,16 @@
 elif test "$BOXMODEL" = "hl101"; then
 	AC_DEFINE(BOXMODEL_HL101, 1, [hl101])
 
-elif test "$BOXMODEL" = "atevio700"; then
-	AC_DEFINE(BOXMODEL_ATEVIO700, 1, [building for atevio700])
-elif test "$BOXMODEL" = "atevio7000"; then
-	AC_DEFINE(BOXMODEL_ATEVIO7000, 1, [building for atevio7000])
-elif test "$BOXMODEL" = "atevio7500"; then
-	AC_DEFINE(BOXMODEL_ATEVIO7500, 1, [building for atevio7500])
-elif test "$BOXMODEL" = "atevio7600"; then
-	AC_DEFINE(BOXMODEL_ATEVIO7600, 1, [building for atevio7600])
-
-elif test "$BOXMODEL" = "octagon1008"; then
-	AC_DEFINE(BOXMODEL_OCTAGON_1008, 1, [building for octagon1008])
+elif test "$BOXMODEL" = "opt9600"; then
+	AC_DEFINE(BOXMODEL_OPT9600, 1, [building for opticum hd 9600])
+
+elif test "$BOXMODEL" = "adb_box"; then
+	AC_DEFINE(BOXMODEL_ADB_BOX, 1, [building for adb iti-5800])
+elif test "$BOXMODEL" = "adb2850"; then
+	AC_DEFINE(BOXMODEL_ADB2850, 1, [building for adb iti-2850])
+
+elif test "$BOXMODEL" = "atemio520"; then
+	AC_DEFINE(BOXMODEL_ATEMIO520, 1, [building for atemio am 520 hd])
 
 elif test "$BOXMODEL" = "vusolo2"; then
 	AC_DEFINE(BOXMODEL_VUSOLO2, 1, [vuplus solo2])
--- neutrino2.org/lib/libdvbsub/dvbsubtitle.cpp
+++ neutrino2/lib/libdvbsub/dvbsubtitle.cpp
@@ -21,9 +21,16 @@
 #include <libavformat/avformat.h>
 #include <libavcodec/avcodec.h>
 #include <libavutil/avutil.h>
+#include <libavcodec/version.h>
 }
 #include "driver/framebuffer.h"
 #include "Debug.hpp"
+
+#if LIBAVCODEC_VERSION_INT <= AV_VERSION_INT(57, 1, 99)
+	#define CODEC_DVB_SUB CODEC_ID_DVB_SUBTITLE
+#else
+	#define CODEC_DVB_SUB AV_CODEC_ID_DVB_SUBTITLE
+#endif
 
 //#if LIBAVCODEC_VERSION_INT <= AV_VERSION_INT(57, 1, 99)
 //	#define CODEC_DVB_SUB CODEC_ID_DVB_SUBTITLE
--- neutrino2.org/lib/libeplayer3/container/container_ffmpeg.c
+++ neutrino2/lib/libeplayer3/container/container_ffmpeg.c
@@ -38,14 +38,10 @@
 #include <pthread.h>
 
 #include <libavutil/avutil.h>
-#if LIBAVCODEC_VERSION_MAJOR > 54
 #include <libavutil/time.h>
-#endif
 #include <libavformat/avformat.h>
-#if LIBAVCODEC_VERSION_MAJOR > 54
 #include <libavutil/opt.h>
-#endif
-
+#include <libavcodec/avcodec.h>
 #include "common.h"
 #include "misc.h"
 #include "debug.h"
@@ -64,9 +60,7 @@
 #endif
 
 
-#if LIBAVCODEC_VERSION_MAJOR > 54
 #define AVCODEC_MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audio
-#endif
 
 /* ***************************** */
 /* Makros/Constants              */
@@ -179,9 +173,6 @@
 			return "V_RMV";
 			
 		case AV_CODEC_ID_MPEG4:
-#if LIBAVCODEC_VERSION_MAJOR < 53
-		case CODEC_ID_XVID:
-#endif
 		case AV_CODEC_ID_MSMPEG4V1:
 		case AV_CODEC_ID_MSMPEG4V2:
 		case AV_CODEC_ID_MSMPEG4V3:
@@ -203,9 +194,7 @@
 			return "V_VC1";
 			
 		case AV_CODEC_ID_H264:
-#if LIBAVCODEC_VERSION_MAJOR < 54
-		case CODEC_ID_FFH264:
-#endif
+//		case AV_CODEC_ID_FFH264:
 			return "V_MPEG4/ISO/AVC";
 		
 		case AV_CODEC_ID_AVS:
@@ -226,11 +215,6 @@
 		case AV_CODEC_ID_DTS:
 			return "A_DTS";
 		
-//#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 72, 2)			
-//		case AV_CODEC_ID_EAC3:
-//			return "A_EAC3";
-//#endif			
-			
 		case AV_CODEC_ID_WMAV1:
 		case AV_CODEC_ID_WMAV2:
 		case 86056: //CODEC_ID_WMAPRO
@@ -280,7 +264,6 @@
 			else
 				ffmpeg_err("ERROR! CODEC NOT FOUND -> %d\n",codec->codec_id);
 	}
-	
 	return NULL;
 }
 
@@ -341,28 +324,16 @@
 /* search for metatdata in context and stream
  * and map it to our metadata.
  */
-#if LIBAVCODEC_VERSION_MAJOR < 54
-static char* searchMeta(AVMetadata *metadata, char* ourTag)
-#else
 static char* searchMeta(AVDictionary * metadata, char* ourTag)
-#endif
 {
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	AVMetadataTag *tag = NULL;
-#else
 	AVDictionaryEntry *tag = NULL;
-#endif
 	int i = 0;
 
 	while (metadata_map[i] != NULL)
 	{
 		if (strcmp(ourTag, metadata_map[i]) == 0)
 		{
-#if LIBAVCODEC_VERSION_MAJOR < 54
-			while ((tag = av_metadata_get(metadata, "", tag, AV_METADATA_IGNORE_SUFFIX)))
-#else
 			while ((tag = av_dict_get(metadata, "", tag, AV_DICT_IGNORE_SUFFIX)))
-#endif
 			{
 				if (strcmp(tag->key, metadata_map[ i + 1 ]) == 0)
 				{
@@ -503,11 +474,7 @@
 			}
 			else
 			{
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				lastSeek = currentReadPosition = url_ftell(avContext->pb);
-#else
 				lastSeek = currentReadPosition = avio_tell(avContext->pb);
-#endif
 				gotlastPts = 1;
 
 #ifndef use_sec_to_seek
@@ -547,11 +514,7 @@
 
 			int index = packet.stream_index;
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-			currentReadPosition = url_ftell(avContext->pb);
-#else
 			currentReadPosition = avio_tell(avContext->pb);
-#endif
 
 			if (context->manager->video->Command(context, MANAGER_GET_TRACK, &videoTrack) < 0)
 				ffmpeg_err("error getting video track\n");
@@ -657,13 +620,7 @@
 						{
 							int decoded_data_size = samples_size;
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(57, 1, 99)
 							bytesDone = avcodec_decode_audio4(( (AVStream*) audioTrack->stream)->codec, (short *)(samples), &decoded_data_size, &avpkt);
-#elif LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
-							bytesDone = avcodec_decode_audio3(( (AVStream*) audioTrack->stream)->codec, (short *)(samples), &decoded_data_size, &avpkt);
-#else
-							bytesDone = avcodec_decode_audio2(( (AVStream*) audioTrack->stream)->codec, (short *)(samples), &decoded_data_size, avpkt.data, avpkt.size);
-#endif
 
 							if(bytesDone < 0) // Error Happend
 							    break;
@@ -793,11 +750,7 @@
 							AVSubtitle sub;
 							int got_sub_ptr;
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)			   
 							if (avcodec_decode_subtitle2(((AVStream*) subtitleTrack->stream)->codec, &sub, &got_sub_ptr, &packet) < 0)
-#else
-							if (avcodec_decode_subtitle( ((AVStream*) subtitleTrack->stream)->codec, &sub, &got_sub_ptr, packet.data, packet.size ) < 0)
-#endif
 							{
 							    ffmpeg_err("error decoding subtitle\n");
 							} 
@@ -930,19 +883,11 @@
 	ao_initialize();
 #endif
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	if ((err = av_open_input_file(&avContext, filename, NULL, 0, NULL)) != 0) 
-#else
 	if ((err = avformat_open_input(&avContext, filename, NULL, 0)) != 0)
-#endif
 	{
 		char error[512];
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-		ffmpeg_err("av_open_input_file failed %d (%s)\n", err, filename);
-#else
 		ffmpeg_err("avformat_open_input failed %d (%s)\n", err, filename);
-#endif
 		//av_strerror(err, error, 512);
 		ffmpeg_err("Cause: %s\n", error);
 
@@ -960,26 +905,16 @@
 
 	ffmpeg_printf(20, "find_streaminfo\n");
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	if (av_find_stream_info(avContext) < 0) 
-	{
-		ffmpeg_err("Error av_find_stream_info\n");
-#else
 	if (avformat_find_stream_info(avContext, NULL) < 0) 
 	{
 		ffmpeg_err("Error avformat_find_stream_info\n");
-#endif
 
 #ifdef this_is_ok
 		/* crow reports that sometimes this returns an error
 		* but the file is played back well. so remove this
 		* until other works are done and we can prove this.
 		*/
-#if LIBAVFORMAT_VERSION_MAJOR < 54
- 		av_close_input_file(avContext);
-#else
 		avformat_close_input(&avContext);
-#endif		
 		releaseMutex(FILENAME, __FUNCTION__,__LINE__);
 		return cERR_CONTAINER_FFMPEG_STREAM;
 #endif
@@ -987,11 +922,7 @@
 
 	ffmpeg_printf(20, "dump format\n");
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	dump_format(avContext, 0, filename, 0);
-#else
 	av_dump_format(avContext, 0, filename, 0);
-#endif
 
 	ffmpeg_printf(1, "number streams %d\n", avContext->nb_streams);
 
@@ -1015,11 +946,7 @@
 		switch (stream->codec->codec_type) 
 		{
 			// video
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)	  
 			case AVMEDIA_TYPE_VIDEO:
-#else
-			case CODEC_TYPE_VIDEO:
-#endif        
 			ffmpeg_printf(10, "CODEC_TYPE_VIDEO %d\n",stream->codec->codec_type);
 
 			if (encoding != NULL) 
@@ -1093,11 +1020,7 @@
 			break;
 	    
 			// audio codec
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)	  
 			case AVMEDIA_TYPE_AUDIO:
-#else
-			case CODEC_TYPE_AUDIO:
-#endif        
 			ffmpeg_printf(10, "CODEC_TYPE_AUDIO %d\n",stream->codec->codec_type);
 
 			if (encoding != NULL) 
@@ -1105,17 +1028,9 @@
 				track.type = eTypeES;
 				
 				// language description
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				AVMetadataTag *lang;
-#else
 				AVDictionaryEntry *lang;
-#endif
-
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				lang = av_metadata_get(stream->metadata, "language", NULL, 0);
-#else
+
 				lang = av_dict_get(stream->metadata, "language", NULL, 0);
-#endif
 
 				if (lang)
 					track.Name = strdup(lang->value);
@@ -1148,11 +1063,7 @@
 
 				AVCodec *codec = avcodec_find_decoder(stream->codec->codec_id);
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				if(codec != NULL && !avcodec_open(stream->codec, codec))
-#else
 				if(codec != NULL && !avcodec_open2(stream->codec, codec, NULL))
-#endif					  
 					printf("AVCODEC__INIT__SUCCESS\n");
 				else
 					printf("AVCODEC__INIT__FAILED\n");
@@ -1166,11 +1077,7 @@
 
 					AVCodec *codec = avcodec_find_decoder(stream->codec->codec_id);
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-					if(codec != NULL && !avcodec_open(stream->codec, codec))
-#else
 					if(codec != NULL && !avcodec_open2(stream->codec, codec, NULL))
-#endif					  
 						printf("AVCODEC__INIT__SUCCESS\n");
 					else
 						printf("AVCODEC__INIT__FAILED\n");
@@ -1272,7 +1179,7 @@
 					switch(stream->codec->codec_id) 
 					{
 						//TODO: What code for lossless ?
-						case 86056/*CODEC_ID_WMAPRO*/:
+						case 86056/*AV_CODEC_ID_WMAPRO*/:
 							codec_id = WMA_VERSION_9_PRO;
 							break;
 						case AV_CODEC_ID_WMAV2:
@@ -1333,21 +1240,12 @@
 			break;
 	    
 			// subtitle
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 64, 0)
 			case AVMEDIA_TYPE_SUBTITLE:
 			{
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				AVMetadataTag * lang;
-#else
 				AVDictionaryEntry * lang;
-#endif
 				ffmpeg_printf(10, "CODEC_TYPE_SUBTITLE %d\n",stream->codec->codec_type);
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-				lang = av_metadata_get(stream->metadata, "language", NULL, 0);
-#else
 				lang = av_dict_get(stream->metadata, "language", NULL, 0);
-#endif	     
 
 				if (lang)
 					track.Name        = strdup(lang->value);
@@ -1408,7 +1306,6 @@
 			default:
 				ffmpeg_err("not handled or unknown codec_type %d\n", stream->codec->codec_type);
 				break;	 
-#endif	 
 		} /* switch (stream->codec->codec_type) */
 
 	} /* for */
@@ -1510,12 +1407,7 @@
 
 	if (avContext != NULL) 
 	{
-#if LIBAVFORMAT_VERSION_MAJOR < 54
- 		av_close_input_file(avContext);
- 		avContext = NULL;
-#else
 		avformat_close_input(&avContext);
-#endif		
 	}
 
 	isContainerRunning = 0;
@@ -1537,11 +1429,7 @@
 static int container_ffmpeg_seek_bytes(off_t pos) 
 {
 	int flag = AVSEEK_FLAG_BYTE;
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	off_t current_pos = url_ftell(avContext->pb);
-#else
 	off_t current_pos = avio_tell(avContext->pb);
-#endif
 
 	ffmpeg_printf(20, "seeking to position %lld (bytes)\n", pos);
 
@@ -1554,11 +1442,7 @@
 		return cERR_CONTAINER_FFMPEG_ERR;
 	}    
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	ffmpeg_printf(30, "current_pos after seek %lld\n", url_ftell(avContext->pb));
-#else
 	ffmpeg_printf(30, "current_pos after seek %lld\n", avio_tell(avContext->pb));
-#endif
 
 	return cERR_CONTAINER_FFMPEG_NO_ERROR;
 }
@@ -1568,11 +1452,7 @@
 {
 	int flag = AVSEEK_FLAG_BYTE;
 	off_t newpos;
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	off_t current_pos = url_ftell(avContext->pb);
-#else
 	off_t current_pos = avio_tell(avContext->pb);
-#endif
 
 	if (start == -1)
 		start = current_pos;
@@ -1601,11 +1481,7 @@
 		return cERR_CONTAINER_FFMPEG_ERR;
 	}    
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-	ffmpeg_printf(30, "current_pos after seek %lld\n", url_ftell(avContext->pb));
-#else
 	ffmpeg_printf(30, "current_pos after seek %lld\n", avio_tell(avContext->pb));
-#endif
 
 	return cERR_CONTAINER_FFMPEG_NO_ERROR;
 }
@@ -1636,11 +1512,7 @@
 
 	if (pos == -1)
 	{
-#if LIBAVCODEC_VERSION_MAJOR < 54
-		pos = url_ftell(avContext->pb);
-#else
 		pos = avio_tell(avContext->pb);
-#endif
 	}
 
 	if (pts == -1)
@@ -1769,11 +1641,7 @@
  * about 10 seconds, backward does not work.
  */
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-		off_t pos = url_ftell(avContext->pb);
-#else
 		off_t pos = avio_tell(avContext->pb);
-#endif
 
 		ffmpeg_printf(10, "pos %lld %d\n", pos, avContext->bit_rate);
 
--- neutrino2.org/src/neutrino.h
+++ neutrino2/src/neutrino.h
@@ -264,11 +264,11 @@
 		
 		// 0 - halt
 		// 1 - reboot
-		// 2 - restart 
+		// 3 - restart 
 		enum {
 			SHUTDOWN = 0,
 			REBOOT,
-			RESTART
+			RESTART = 3
 		};
 		
 		void ExitRun(int retcode = SHUTDOWN, bool save = true);
--- neutrino-hd2.org/src/driver/rcinput.h
+++ neutrino-hd2/src/driver/rcinput.h
@@ -84,7 +84,7 @@
 #define KEY_GAMES        0x1a1
 #endif
 
-// this values are token from cuberevo3000hd
+// these values are taken from cuberevo3000hd
 #ifndef KEY_PIP	
 #define KEY_PIP	0x041
 #endif
@@ -168,7 +168,8 @@
 
 	RC_standby	= KEY_POWER,	    
 			
-	RC_home         = KEY_HOME,         
+	RC_home         = KEY_HOME,  // most receivers use this for EXIT
+	RC_exit         = KEY_EXIT,  // but some use this
 	RC_setup	= KEY_MENU,	    
 			
 	RC_page_up	= KEY_PAGEUP,	   
@@ -324,6 +325,7 @@
 
 		neutrino_msg_t key_standby;
 		neutrino_msg_t key_home;
+		neutrino_msg_t key_exit;
 		neutrino_msg_t key_setup;				
 			
 		neutrino_msg_t key_page_up;
--- neutrino-hd2.org/src/driver/rcinput.cpp
+++ neutrino-hd2/src/driver/rcinput.cpp
@@ -115,6 +115,7 @@
 			
 #if defined (__sh__)
 	key_home = configfile.getInt32("key_home", KEY_HOME);
+	key_exit = configfile.getInt32("key_exit", KEY_EXIT);
 #else
 	key_home = configfile.getInt32("key_home", 0xAE);
 #endif			
@@ -272,6 +273,7 @@
 	configfile.setInt32("key_standby", key_standby);
 			
 	configfile.setInt32("key_home", key_home);
+	configfile.setInt32("key_exit", key_exit);
 			
 	configfile.setInt32("key_setup", key_setup);
 				
@@ -557,7 +559,7 @@
 	{
 		g_RCInput->getMsgAbsoluteTimeout(&msg, &data, &timeoutEnd);
 
-		if ( ( msg == RC_timeout ) || ( msg == RC_home ) || ( msg == RC_ok ) )
+		if ( ( msg == RC_timeout ) || ( msg == RC_home ) || ( msg == RC_exit ) || ( msg == RC_ok ) )
 		{
 			doLoop = false;
 		}
@@ -1636,6 +1638,9 @@
 		case RC_home:
 			return "RC_home";
 
+		case RC_exit:
+			return "RC_home";
+
 		case RC_setup:
 			return "RC_setup";
 
@@ -1862,6 +1867,7 @@
 	else if (code == key_down) return RC_down;
 	else if (code == key_right) return RC_right;
 	else if (code == key_home) return RC_home;
+	else if (code == key_exit) return RC_home;
 			
 	/* special */
 	else if (code == key_recall) return RC_recall;
--- neutrino2.org/src/neutrino.h
+++ neutrino2/src/neutrino.h
@@ -262,13 +262,13 @@
 		void lockPlayBack(void);
 		void unlockPlayBack(void);
 		
-		// 0 - restart 
-		// 1 - shutdown
-		// 2 - reboot
+		// 0 - halt
+		// 1 - reboot
+		// 2 - restart 
 		enum {
-			RESTART = 0,
-			SHUTDOWN,
-			REBOOT
+			SHUTDOWN = 0,
+			REBOOT,
+			RESTART
 		};
 		
 		void ExitRun(int retcode = SHUTDOWN, bool save = true);
#--- neutrino-hd2.org/src/neutrino.cpp
#+++ neutrino-hd2.git/nhd2-exp/src/neutrino.cpp
#@@ -464,11 +464,11 @@
# 	}
# 
# 	// video
#-#ifdef __sh__	
#-	g_settings.video_Mode = configfile.getInt32("video_Mode", VIDEO_STD_PAL);
#-#else
#+//#ifdef __sh__	
#+//	g_settings.video_Mode = configfile.getInt32("video_Mode", VIDEO_STD_PAL);
#+//#else
# 	g_settings.video_Mode = configfile.getInt32("video_Mode", VIDEO_STD_720P50);
#-#endif
#+//#endif
# 	prev_video_Mode = g_settings.video_Mode;
# 	
# 	//analog mode
--- neutrino2.org/src/driver/vfd.h
+++ neutrino2/src/driver/vfd.h
@@ -37,11 +37,31 @@
 #include <cs_vfd.h>
 #endif
 
+// VFD/LED display width
+#if defined(PLATFORM_SPARK7162) \
+ || defined(BOXMODEL_HS9510) \
+ || defined(BOXMODEL_HS7420) \
+ || defined(BOXMODEL_HS7429)
+#define VFD_LENGTH 8
+#elif defined(BOXMODEL_FS9000) \
+ ||   defined(BOXMODEL_HS8200)
+#define VFD_LENGTH 12
+#elif defined(BOXMODEL_HS7119) \
+ || defined(BOXMODEL_HS7810A) \
+ || defined(BOXMODEL_HS7819)
+#define VFD_LENGTH 4
+#elif defined(BOXMODEL_HS7110)
+#define VFD_LENGTH 0
+#elif defined(BOXMODEL_ADB_BOX)
+#define VFD_LENGTH 15
+#else
+#define VFD_LENGTH 16
+#endif
 
 #if defined(PLATFORM_SPARK7162)
-/* SAB Triple VFD Icons								*/
-/* taken from aotom_main.h, with these numbers the Icons on Spark7162		*/
-/* will work right ( hopefully all Models )					*/
+/* SAB Triple VFD Icons                                               */
+/* taken from aotom_main.h, with these numbers the Icons on Spark7162 */
+/* will work right ( hopefully all Models )                           */
 typedef enum {
 //----------------------------------11G-------------------------------------
 	VFD_SPARK_PLAY_FASTBACKWARD = 1,		//11*16+1,
@@ -92,7 +112,7 @@
 	VFD_SPARK_DOT1 = 44,
 	VFD_SPARK_CAB = 45,	
 //----------------------------------end-------------------------------------
-	SPARK_ICON_ALL = 46, 		/* with this number the aotom driver set all icons on (1) or off (0) */
+	SPARK_ICON_ALL = 46,  /* with this number the aotom driver set all icons on (1) or off (0) */
 	VFD_ICON_MAX
 } spark7162_vfd_icon;
 
@@ -131,9 +151,7 @@
 	VFD_ICON_STANDBY	= VFD_SPARK_CYCLE	
 } vfd_icon;
 
-#endif //spark7162
-
-#if defined(PLATFORM_KATHREIN)
+#elif defined(PLATFORM_KATHREIN)
 typedef enum
 {
 	vfd_910_usb = 1,
@@ -177,11 +195,361 @@
 	VFD_ICON_HDD 		= vfd_910_hdd,	
 	VFD_ICON_CLOCK		= vfd_910_clock
 } vfd_icon;
-#endif //ufs910, ufs913
-
-#if !defined(PLATFORM_KATHREIN) && !defined(PLATFORM_SPARK7162) && !defined (PLATFORM_COOLSTREAM)
-// duckbox
-// token from micom
+
+#elif defined(BOXMODEL_FS9000)
+typedef enum
+{
+	HDBOX_ICON_USB = 0x1,  // 01
+	HDBOX_ICON_STANDBY,    // 02
+	HDBOX_ICON_SAT,        // 03
+	HDBOX_ICON_REC,        // 04
+	HDBOX_ICON_TIMESHIFT,  // 05
+	HDBOX_ICON_TIMER,      // 06
+	HDBOX_ICON_HD,         // 07
+	HDBOX_ICON_SCRAMBLED,  // 08
+	HDBOX_ICON_DOLBY,      // 09
+	HDBOX_ICON_MUTE,       // 10
+	HDBOX_ICON_TUNER1,     // 11
+	HDBOX_ICON_TUNER2,     // 12
+	HDBOX_ICON_MP3,        // 13
+	HDBOX_ICON_REPEAT,     // 14
+	HDBOX_ICON_PLAY,       // 15
+	HDBOX_ICON_TER,        // 16
+	HDBOX_ICON_FILE,       // 17
+	HDBOX_ICON_480i,       // 18
+	HDBOX_ICON_480p,       // 19
+	HDBOX_ICON_576i,       // 20
+	HDBOX_ICON_576p,       // 21
+	HDBOX_ICON_720p,       // 22
+	HDBOX_ICON_1080i,      // 23
+	HDBOX_ICON_1080p,      // 24
+	HDBOX_ICON_Circ0,      // 25
+	HDBOX_ICON_Circ1,      // 26
+	HDBOX_ICON_Circ2,      // 27
+	HDBOX_ICON_Circ3,      // 28
+	HDBOX_ICON_Circ4,      // 29
+	HDBOX_ICON_Circ5,      // 30
+	HDBOX_ICON_Circ6,      // 31
+	HDBOX_ICON_Circ7,      // 32
+	HDBOX_ICON_Circ8,      // 33
+	HDBOX_ICON_COLON1,     // 34
+	HDBOX_ICON_COLON2,     // 35
+	HDBOX_ICON_COLON3,     // 36
+	HDBOX_ICON_COLON4,     // 37
+	HDBOX_ICON_TV,         // 38
+	HDBOX_ICON_RADIO,      // 39
+	ICON_ALL               // 40 new nuvoton will set/clear all icons with this number
+} fs9000_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= HDBOX_ICON_MUTE,
+	VFD_ICON_DOLBY		= HDBOX_ICON_DOLBY,
+	VFD_ICON_POWER		= HDBOX_ICON_STANDBY,
+	VFD_ICON_TIMESHIFT	= HDBOX_ICON_TIMESHIFT,
+	VFD_ICON_TV		= HDBOX_ICON_TV,
+	VFD_ICON_RADIO		= HDBOX_ICON_RADIO,
+	VFD_ICON_HD		= HDBOX_ICON_HD,
+	VFD_ICON_1080P		= HDBOX_ICON_1080p,
+	VFD_ICON_1080I		= HDBOX_ICON_1080i,
+	VFD_ICON_720P		= HDBOX_ICON_720p,
+	VFD_ICON_480P		= HDBOX_ICON_480p,
+	VFD_ICON_480I		= HDBOX_ICON_480i,
+	VFD_ICON_USB		= HDBOX_ICON_USB,
+	VFD_ICON_MP3		= HDBOX_ICON_MP3,
+	VFD_ICON_PLAY		= HDBOX_ICON_PLAY,
+	VFD_ICON_PAUSE		= HDBOX_ICON_TER,
+	VFD_ICON_LOCK 		= HDBOX_ICON_SCRAMBLED,
+	VFD_ICON_CLOCK		= HDBOX_ICON_TIMER,
+	VFD_ICON_STANDBY	= HDBOX_ICON_STANDBY
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS9510)
+typedef enum //HS9510 icon numbers and their names
+{
+	HS9510_ICON_DOLBY = 0x1,  // 01
+	HS9510_ICON_DTS,          // 02
+	HS9510_ICON_VIDEO,        // 03
+	HS9510_ICON_AUDIO,        // 04
+	HS9510_ICON_LINK,         // 05
+	HS9510_ICON_HDD,          // 06
+	HS9510_ICON_DISC,         // 07
+	HS9510_ICON_DVB,          // 08
+	HS9510_ICON_DVD,          // 09
+	HS9510_ICON_TIMER,        // 10
+	HS9510_ICON_TIME,         // 11
+	HS9510_ICON_CARD,         // 12
+	HS9510_ICON_1,            // 13
+	HS9510_ICON_2,            // 14
+	HS9510_ICON_KEY,          // 15
+	HS9510_ICON_16_9,         // 16
+	HS9510_ICON_USB,          // 17
+	HS9510_ICON_CRYPTED,      // 18
+	HS9510_ICON_PLAY,         // 19
+	HS9510_ICON_REWIND,       // 20
+	HS9510_ICON_PAUSE,        // 21
+	HS9510_ICON_FF,           // 22
+	HS9510_ICON_NONE,         // 23
+	HS9510_ICON_REC,          // 24
+	HS9510_ICON_ARROW,        // 25
+	HS9510_ICON_COLON1,       // 26
+	HS9510_ICON_COLON2,       // 27
+	HS9510_ICON_COLON3,       // 28
+	ICON_ALL                  // 29 new nuvoton will set/clear all icons with this number
+} hs9510_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= HS9510_ICON_TIME,
+	VFD_ICON_DOLBY		= HS9510_ICON_DOLBY,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= HS9510_ICON_REC,
+	VFD_ICON_TV		= HS9510_ICON_VIDEO,
+	VFD_ICON_RADIO		= HS9510_ICON_AUDIO,
+	VFD_ICON_HD		= HS9510_ICON_16_9,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= HS9510_ICON_USB,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= HS9510_ICON_PLAY,
+	VFD_ICON_PAUSE		= HS9510_ICON_PAUSE,
+	VFD_ICON_LOCK 		= HS9510_ICON_CRYPTED,
+	VFD_ICON_CLOCK		= HS9510_ICON_TIMER,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS8200)
+typedef enum //HS8200 icon numbers and their names
+{
+	HS8200_ICON_STANDBY = 1, // 01
+	HS8200_ICON_REC,         // 02
+	HS8200_ICON_TIMESHIFT,   // 03
+	HS8200_ICON_TIMER,       // 04
+	HS8200_ICON_HD,          // 05
+	HS8200_ICON_USB,         // 06
+	HS8200_ICON_SCRAMBLED,   // 07
+	HS8200_ICON_DOLBY,       // 08
+	HS8200_ICON_MUTE,        // 09
+	HS8200_ICON_TUNER1,      // 10
+	HS8200_ICON_TUNER2,      // 11
+	HS8200_ICON_MP3,         // 12
+	HS8200_ICON_REPEAT,      // 13
+	HS8200_ICON_PLAY,        // 14
+	HS8200_ICON_STOP,        // 15
+	HS8200_ICON_PAUSE,       // 16
+	HS8200_ICON_REWIND,      // 17
+	HS8200_ICON_FF,          // 18
+	HS8200_ICON_STEP_BACK,   // 19
+	HS8200_ICON_STEP_FWD,    // 20
+	HS8200_ICON_TV,          // 21
+	HS8200_ICON_RADIO,       // 22
+	ICON_ALL                 // 23 new nuvoton will set/clear all icons with this number
+} hs8200_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= HS8200_ICON_MUTE,
+	VFD_ICON_DOLBY		= HS8200_ICON_DOLBY,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= HS8200_ICON_TIMESHIFT,
+	VFD_ICON_TV		= HS8200_ICON_TV,
+	VFD_ICON_RADIO		= HS8200_ICON_RADIO,
+	VFD_ICON_HD		= HS8200_ICON_HD,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= HS8200_ICON_USB,
+	VFD_ICON_MP3		= HS8200_ICON_MP3,
+	VFD_ICON_PLAY		= HS8200_ICON_PLAY,
+	VFD_ICON_PAUSE		= HS8200_ICON_PAUSE,
+	VFD_ICON_LOCK 		= HS8200_ICON_SCRAMBLED,
+	VFD_ICON_CLOCK		= HS8200_ICON_TIMER,
+	VFD_ICON_STANDBY	= HS8200_ICON_STANDBY
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS7420) \
+ ||   defined(BOXMODEL_HS7429)
+typedef enum //HS742X icon numbers and their names
+{
+	HS742X_ICON_DOT = 1,      // 01
+	HS742X_ICON_COLON1,       // 02
+	HS742X_ICON_COLON2,       // 03
+	HS742X_ICON_COLON3,       // 04
+	ICON_ALL                  // 05 new nuvoton will set/clear all icons with this number
+} hs742x_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= 0,
+	VFD_ICON_DOLBY		= 0,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= 0,
+	VFD_ICON_TV		= 0,
+	VFD_ICON_RADIO		= 0,
+	VFD_ICON_HD		= 0,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= 0,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= 0,
+	VFD_ICON_PAUSE		= 0,
+	VFD_ICON_LOCK 		= 0,
+	VFD_ICON_CLOCK		= 0,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS7119)
+typedef enum //HS7119 icon numbers and their names
+{
+	HS7119_ICON_COLON = 1,    // 01
+	ICON_ALL                  // 02 new nuvoton will set/clear all icons with this number
+} hs7119_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= 0,
+	VFD_ICON_DOLBY		= 0,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= 0,
+	VFD_ICON_TV		= 0,
+	VFD_ICON_RADIO		= 0,
+	VFD_ICON_HD		= 0,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= 0,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= 0,
+	VFD_ICON_PAUSE		= 0,
+	VFD_ICON_LOCK 		= 0,
+	VFD_ICON_CLOCK		= 0,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS7810A) \
+ ||   defined(BOXMODEL_HS7819)
+typedef enum //HS7810A & HS7819 icon numbers and their names
+{
+	HS7810A_ICON_COLON = 1,   // 01
+	HS7810A_ICON_PERIOD1,     // 02
+	HS7810A_ICON_PERIOD2,     // 03
+	HS7810A_ICON_PERIOD3,     // 04
+	ICON_ALL                  // 05 new nuvoton will set/clear all icons with this number
+} hs7810a_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= 0,
+	VFD_ICON_DOLBY		= 0,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= 0,
+	VFD_ICON_TV		= 0,
+	VFD_ICON_RADIO		= 0,
+	VFD_ICON_HD		= 0,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= 0,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= 0,
+	VFD_ICON_PAUSE		= 0,
+	VFD_ICON_LOCK 		= 0,
+	VFD_ICON_CLOCK		= 0,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_HS7110)
+typedef enum
+{
+	ICON_ALL		= 0,
+	VFD_ICON_MUTE		= 0,
+	VFD_ICON_DOLBY		= 0,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= 0,
+	VFD_ICON_TV		= 0,
+	VFD_ICON_RADIO		= 0,
+	VFD_ICON_HD		= 0,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= 0,
+	VFD_ICON_MP3		= 0,
+	VFD_ICON_PLAY		= 0,
+	VFD_ICON_PAUSE		= 0,
+	VFD_ICON_LOCK 		= 0,
+	VFD_ICON_CLOCK		= 0,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#elif defined(BOXMODEL_ADB_BOX)
+typedef enum //ADB ITI-5800SX icon numbers and their names
+{
+	ADB_ICON_MIN,       // 00
+	ADB_ICON_REC,       // 01
+	ADB_ICON_TIMESHIFT, // 02
+	ADB_ICON_TIMER,     // 03
+	ADB_ICON_HD,        // 04
+	ADB_ICON_USB,       // 05
+	ADB_ICON_SCRAMBLED, // 06
+	ADB_ICON_DOLBY,     // 07
+	ADB_ICON_MUTE,      // 08
+	ADB_ICON_TUNER1,    // 09
+	ADB_ICON_TUNER2,    // 10
+	ADB_ICON_MP3,       // 11
+	ADB_ICON_REPEAT,    // 12
+	ADB_ICON_PLAY,      // 13
+	ADB_ICON_STOP,      // 14
+	ADB_ICON_PAUSE,     // 15
+	ADB_ICON_REWIND,    // 16
+	ADB_ICON_FF,        // 17
+	ADB_ICON_STEP_BACK, // 18
+	ADB_ICON_STEP_FWD,  // 19
+	ADB_ICON_TV,        // 20
+	ADB_ICON_RADIO,     // 21
+	ADB_ICON_MAX,       // 22
+	ADB_ICON_SPINNER    // 23
+} adb_box_vfd_icon;
+
+typedef enum
+{
+	VFD_ICON_MUTE		= ADB_ICON_MUTE,
+	VFD_ICON_DOLBY		= ADB_ICON_DOLBY,
+	VFD_ICON_POWER		= 0,
+	VFD_ICON_TIMESHIFT	= ADB_ICON_TIMESHIFT,
+	VFD_ICON_TV		= ADB_ICON_TV,
+	VFD_ICON_RADIO		= ADB_ICON_RADIO,
+	VFD_ICON_HD		= ADB_ICON_HD,
+	VFD_ICON_1080P		= 0,
+	VFD_ICON_1080I		= 0,
+	VFD_ICON_720P		= 0,
+	VFD_ICON_480P		= 0,
+	VFD_ICON_480I		= 0,
+	VFD_ICON_USB		= ADB_ICON_USB,
+	VFD_ICON_MP3		= ADB_ICON_MP3,
+	VFD_ICON_PLAY		= ADB_ICON_PLAY,
+	VFD_ICON_PAUSE		= ADB_ICON_PAUSE,
+	VFD_ICON_LOCK 		= ADB_ICON_SCRAMBLED,
+	VFD_ICON_CLOCK		= ADB_ICON_TIMER,
+	VFD_ICON_STANDBY	= 0
+} vfd_icon;
+
+#else
+// generic duckbox
+// taken from micom
 enum {
 	ICON_MIN,             // 0x00
 	ICON_STANDBY,
@@ -212,7 +580,7 @@
 	ICON_RADIO,   
 	ICON_TV,      
 	ICON_PAUSE,   
-	ICON_MAX
+	ICON_ALL
 };
 
 // neutrino common
@@ -236,19 +604,24 @@
 	VFD_ICON_PAUSE		= ICON_PAUSE,
 	VFD_ICON_LOCK 		= ICON_SCRAMBLED
 } vfd_icon;
-#endif  //common
+#endif
 
 #if defined (__sh__)
 #define VFDBRIGHTNESS         0xc0425a03
-#define VFDPWRLED             0xc0425a04 /* added by zeroone, also used in fp_control/global.h ; set PowerLed Brightness on HDBOX*/
+#define VFDPWRLED             0xc0425a04 /* Obsolete, use VFDSETLED */
 #define VFDDRIVERINIT         0xc0425a08
 #define VFDICONDISPLAYONOFF   0xc0425a0a
 #define VFDDISPLAYWRITEONOFF  0xc0425a05
 #define VFDDISPLAYCHARS       0xc0425a00
 
+#define VFDSETRF              0xc0425af7
+#if !defined (BOXMODEL_ADB_BOX)
 #define VFDCLEARICONS	      0xc0425af6
-#define VFDSETRF              0xc0425af7
 #define VFDSETFAN             0xc0425af8
+#else
+#define VFDSETFAN             0xc0425af6
+#define VFDLEDBRIGHTNESS      0xc0425af8
+#endif
 #define VFDGETWAKEUPMODE      0xc0425af9
 #define VFDGETTIME            0xc0425afa
 #define VFDSETTIME            0xc0425afb
@@ -263,8 +636,9 @@
 #define VFDSETTIMEMODE        0xc0425b03
 #define VFDDISPLAYCLR	      0xc0425b00
 
-#if defined(PLATFORM_SPARK7162)
-/* structs are needed for sending icons etc. to aotom 				*/
+#if defined(PLATFORM_SPARK7162) \
+ || defined(PLATFORM_SPARK)
+/* structs are needed for sending icons etc. to aotom */
 struct set_mode_s {
 	int compat; /* 0 = compatibility mode to vfd driver; 1 = nuvoton mode */
 };
@@ -308,31 +682,38 @@
 		struct set_time_s time;
 	} u;
 };
-#elif defined (PLATFORM_SPARK)
-/* ugly: this is copied from frontcontroller utility, but the driver
- * does not seem to provide userspace headers... :-( */
-
-
-/* this setups the mode temporarily (for one ioctl)
- * to the desired mode. currently the "normal" mode
- * is the compatible vfd mode
- */
-struct set_mode_s {
-	int compat; /* 0 = compatibility mode to vfd driver; 1 = nuvoton mode */
-};
-
-struct set_brightness_s {
+
+#elif defined(BOXMODEL_FS9000) \
+   || defined(BOXMODEL_HS9510) \
+   || defined(BOXMODEL_HS8200) \
+   || defined(BOXMODEL_HS7110) \
+   || defined(BOXMODEL_HS7420) \
+   || defined(BOXMODEL_HS7810A) \
+   || defined(BOXMODEL_HS7119) \
+   || defined(BOXMODEL_HS7429) \
+   || defined(BOXMODEL_HS7819)
+//#elif defined(PLATFORM_FORTIS)
+/* structs are needed for sending icons etc. to nuvoton */
+struct set_brightness_s
+{
 	int level;
 };
 
-struct set_icon_s {
+struct set_icon_s
+{
 	int icon_nr;
 	int on;
 };
 
-struct set_led_s {
+struct set_led_s
+{
 	int led_nr;
-	int on;
+	int level;
+};
+
+struct set_light_s
+{
+	int onoff;
 };
 
 /* time must be given as follows:
@@ -341,38 +722,49 @@
  * time[3] = min
  * time[4] = sec
  */
-struct set_standby_s {
+struct set_standby_s
+{
 	char time[5];
 };
 
-struct set_time_s {
+struct set_time_s
+{
 	char time[5];
 };
 
-struct aotom_ioctl_data {
+struct set_timeformat_s
+{
+	int format;
+};
+
+/* This will set the mode temporarily (for one ioctl)
+ * to the desired mode. Currently the "normal" mode
+ * is the compatible vfd mode
+ */
+struct set_mode_s
+{
+	int compat; /* 0 = compatibility mode to vfd driver; 1 = nuvoton mode */
+};
+
+
+struct nuvoton_ioctl_data
+{
 	union
 	{
 		struct set_icon_s icon;
 		struct set_led_s led;
 		struct set_brightness_s brightness;
+		struct set_light_s light;
 		struct set_mode_s mode;
 		struct set_standby_s standby;
 		struct set_time_s time;
+		struct set_timeformat_s timeformat;
 	} u;
 };
-
-/* a strange way of defining ioctls... but anyway... */
-#define VFDGETTIME      0xc0425afa
-#define VFDSETTIME      0xc0425afb
-#define VFDSTANDBY      0xc0425afc
-#define VFDSETLED       0xc0425afe
-#define VFDDISPLAYCHARS 0xc0425a00
-#define VFDDISPLAYCLR   0xc0425b00
-#define VFDSETMODE      0xc0425aff
-#endif //Spark7162
-
-
-struct vfd_ioctl_data {
+#endif
+
+struct vfd_ioctl_data
+{
 	unsigned char start_address;
 	unsigned char data[64];
 	unsigned char length;
--- neutrino2.org/src/driver/vfd.cpp
+++ neutrino2/src/driver/vfd.cpp
@@ -47,15 +47,30 @@
 
 
 #if defined (__sh__)
-#if defined (PLATFORM_SPARK7162)
+  #if defined (PLATFORM_SPARK7162)
 static struct aotom_ioctl_data aotom_data;
-#endif
-
-#if defined (PLATFORM_KATHREIN) || defined (PLATFORM_SPARK7162)
+  #elif defined(BOXMODEL_FS9000) \
+     || defined(BOXMODEL_HS9510) \
+     || defined(BOXMODEL_HS8200) \
+     || defined(BOXMODEL_HS7110) \
+     || defined(BOXMODEL_HS7420) \
+     || defined(BOXMODEL_HS7810A) \
+     || defined(BOXMODEL_HS7119) \
+     || defined(BOXMODEL_HS7429) \
+     || defined(BOXMODEL_HS7819)
+static struct nuvoton_ioctl_data nuvoton_data;
+  #endif
+
+  #if defined(PLATFORM_KATHREIN) \
+   || defined(PLATFORM_SPARK7162) \
+   || defined(BOXMODEL_FS9000) \
+   || defined(BOXMODEL_HS9510) \
+   || defined(BOXMODEL_HS8200) \
+   || defined(BOXMODEL_ADB_BOX)
 static bool usb_icon = false;
 static bool timer_icon = false;
 static bool hdd_icon = false;
-#endif
+  #endif
 
 //konfetti: let us share the device with evremote and fp_control
 //it does currently not support more than one user (see e.g. micom)
@@ -69,9 +84,11 @@
 		if(fd < 0)
 		{
 			printf("failed to open vfd\n");
+#if defined (BOXMODEL_TF7700)
 			fd = open("/dev/fplarge", O_RDWR);
 			if (fd < 0)
 			    printf("failed to open fplarge\n");
+#endif
 		}
 		else
 			blocked = true;
@@ -88,7 +105,7 @@
 	
 	fd = -1;
 }
-#endif
+#endif //__sh__
 
 // default: has_lcd:1, is4digits:0, has_led:0
 // constructor
@@ -208,7 +225,11 @@
 	}
 	else
 		setPower(1);
-#endif	
+#elif defined (BOXMODEL_HS9510)
+	ShowIcon((vfd_icon)HS9510_ICON_COLON2, false);
+#elif defined(BOXMODEL_HS7420) || defined(BOXMODEL_HS7429)
+	ShowIcon((vfd_icon)HS742X_ICON_COLON1, false);
+#endif
 }
 
 void * CVFD::TimeThread(void *)
@@ -245,7 +266,8 @@
 	}
 	
 	// set led color
-#if defined (PLATFORM_GIGABLUE)
+#if defined (PLATFORM_GIGABLUE) \
+ || defined (BOXMODEL_ADB_BOX)
 	vfd_led(g_settings.lcd_ledcolor);  //0:off, 1:blue, 2:red, 3:purple
 #elif defined (PLATFORM_VENTON)
 	vfd_symbol_network(0);
@@ -277,15 +299,18 @@
         struct vfd_ioctl_data data;
 	data.start_address = dimm;
 	
-	if(dimm < 1)
-		dimm = 1;
+	if (dimm < 0)
+	{
+		dimm = 0;
+	}
 	brightness = dimm;
 	
 	openDevice();
 	
-	if( ioctl(fd, VFDBRIGHTNESS, &data) < 0)  
+	if (ioctl(fd, VFDBRIGHTNESS, &data) < 0)  
+	{
 		perror("VFDBRIGHTNESS");
-	
+	}
 	closeDevice();
 #elif defined (PLATFORM_COOLSTREAM)
 	int ret = ioctl(fd, IOC_VFD_SET_BRIGHT, dimm);
@@ -356,14 +381,23 @@
 			{
 				hour = t->tm_hour;
 				minute = t->tm_min;
-#if defined (PLATFORM_KATHREIN)							/* time and date at kathrein because 16 character vfd	*/
+#if defined(PLATFORM_KATHREIN)  /* time and date at kathrein because 16 character vfd */
 				strftime(timestr, 20, "%H:%M - %d.%m.%y", t);
-#elif !defined(PLATFORM_SPARK7162) && !defined (PLATFORM_KATHREIN)		/* no time at spark7162 because clock integrated	*/
+#elif defined(BOXMODEL_HS9510)  /* no colon on hs9510: it is an icon */
+				ShowIcon((vfd_icon)HS9510_ICON_COLON2, true);
+ 				strftime(timestr, 20, "%H%M", t);
+#elif defined(BOXMODEL_HS7420) || defined(BOXMODEL_HS7429)  /* no colon on HS742X: it is an icon */
+				ShowIcon((vfd_icon)HS742X_ICON_COLON1, true);
+ 				strftime(timestr, 20, "%H%M", t);
+#elif defined(BOXMODEL_HS7810A) || defined(BOXMODEL_HS7119) || defined (BOXMODEL_HS7810)  /* do not scroll on these models */
+ 				strftime(timestr, 20, "%H:%M", t);
+
+#elif !defined(PLATFORM_SPARK7162)  /* no time at spark7162 because clock integrated */
  				strftime(timestr, 20, "%H:%M", t);
 #endif				
 				ShowText(timestr);
 			}
-		} 
+		}
 	}
 
 	if (CNeutrinoApp::getInstance()->recordingstatus) 
@@ -446,25 +480,106 @@
 	switch(m) 
 	{
 		case AUDIO_MODE_PLAY:
+		{
 			ShowIcon(VFD_ICON_PLAY, true);
 			ShowIcon(VFD_ICON_PAUSE, false);
-			break;
-			
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, false);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, false);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, false);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, false);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, false);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, false);
+			ShowIcon((vfd_icon)ADB_ICON_FF, false);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, false);
+#endif
+			break;
+		}
 		case AUDIO_MODE_STOP:
+		{
 			ShowIcon(VFD_ICON_PLAY, false);
 			ShowIcon(VFD_ICON_PAUSE, false);
-			break;
-			
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, false);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, false);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, false);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, false);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, false);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, false);
+			ShowIcon((vfd_icon)ADB_ICON_FF, false);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, false);
+#endif
+			break;
+		}
 		case AUDIO_MODE_PAUSE:
+		{
 			ShowIcon(VFD_ICON_PLAY, false);
 			ShowIcon(VFD_ICON_PAUSE, true);
-			break;
-			
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, false);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, false);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, true);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, false);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, false);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, false);
+			ShowIcon((vfd_icon)ADB_ICON_FF, false);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, true);
+#endif
+			break;
+		}
 		case AUDIO_MODE_FF:
-			break;
-			
+		{
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, true);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, false);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, true);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, false);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, false);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, true);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, false);
+			ShowIcon((vfd_icon)ADB_ICON_FF, true);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, false);
+#endif
+			break;
+		}
 		case AUDIO_MODE_REV:
-			break;
+		{
+#if defined(BOXMODEL_HS9510)
+			ShowIcon((vfd_icon)HS9510_ICON_REWIND, true);
+			ShowIcon((vfd_icon)HS9510_ICON_FF, false);
+#elif defined(BOXMODEL_HS8200)
+			ShowIcon((vfd_icon)HS8200_ICON_REWIND, true);
+			ShowIcon((vfd_icon)HS8200_ICON_FF, false);
+			ShowIcon((vfd_icon)HS8200_ICON_PAUSE, false);
+#elif defined(PLATFORM_SPARK7162)
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTBACKWARD, true);
+			ShowIcon((vfd_icon)VFD_SPARK_PLAY_FASTFORWARD, false);
+#elif defined(BOXMODEL_ADB_BOX)
+			ShowIcon((vfd_icon)ADB_ICON_REWIND, true);
+			ShowIcon((vfd_icon)ADB_ICON_FF, false);
+			ShowIcon((vfd_icon)ADB_ICON_PAUSE, false);
+#endif
+			break;
+		}
 	}
 
 	wake_up();
@@ -489,27 +604,35 @@
 	switch (m) 
 	{
 		case MODE_TVRADIO:	
+		{
 			showServicename(servicename, true, serviceNum);
 			
 #if !defined(PLATFORM_SPARK7162)			
 			ShowIcon(VFD_ICON_MP3, false);	        // NOTE: @dbo  //ICON_MP3 and ICON_DOLBY switched in infoviewer 
 #endif			
 	
-#if defined (PLATFORM_KATHREIN)
+#if defined (PLATFORM_KATHREIN) || defined(BOXMODEL_HS9510)
 			ShowIcon(VFD_ICON_USB, usb_icon);	
 			ShowIcon(VFD_ICON_HDD, hdd_icon);	
 #elif defined(PLATFORM_SPARK7162)
 			ShowIcon(VFD_ICON_USB, usb_icon);	
 			ShowDiskLevel();
 			ShowIcon(VFD_ICON_STANDBY, false);	
+#elif defined(BOXMODEL_FS9000) || defined(BOXMODEL_HS8200)
+			ShowIcon(VFD_ICON_USB, usb_icon);	
+			ShowIcon(VFD_ICON_STANDBY, false);	
+ 			showclock = true;
+#elif defined(BOX_MODEL_ADB_BOX)
+			ShowIcon(VFD_ICON_USB, usb_icon);	
 #endif
 			showclock = true;
 			//showTime();      /* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */			
 			break;
-
+		}
 		case MODE_AUDIO:
 		{
-#if defined(PLATFORM_SPARK7162)
+#if defined(PLATFORM_SPARK7162) \
+ || defined(BOXMODEL_ADB_BOX)
 			ShowIcon(VFD_ICON_AC3, false);			
 #endif		  
 			ShowIcon(VFD_ICON_MP3, true);			
@@ -524,21 +647,23 @@
 			//showTime();      /* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */
 			break;
 		}
-
 		case MODE_SCART:	  
+		{
 			ShowIcon(VFD_ICON_TV, false);	
 			showclock = true;
 			//showTime();      /* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */
 			break;
-
+		}
 		case MODE_MENU_UTF8:
+		{
 			ShowIcon(VFD_ICON_TV, false);			
 			ShowIcon(VFD_ICON_HD, false);
 			ShowIcon(VFD_ICON_DOLBY, false);
 			showclock = false;
 			break;
-
+		}
 		case MODE_SHUTDOWN:
+		{
 			//Clear();
 			/* clear all symbols */
 			ClearIcons();
@@ -551,8 +676,9 @@
 			ShowText((char *) "BYE");
 			
 			break;
-
+		}
 		case MODE_STANDBY:
+		{
 			ShowIcon(VFD_ICON_TV, false);
 			ClearIcons();
 #if defined(PLATFORM_SPARK7162)
@@ -563,21 +689,23 @@
 			showTime(true);      	/* "showclock = true;" implies that "showTime();" does a "displayUpdate();" */
 						/* "showTime()" clears the whole lcd in MODE_STANDBY */
 			break;
-		
+		}		
 		case MODE_PIC:	  
+		{
 			ShowIcon(VFD_ICON_TV, false);			
 			ShowIcon(VFD_ICON_HD, false);
 			ShowIcon(VFD_ICON_DOLBY, false);
 			
 			showclock = false;
 			break;
-			
+		}
 		case MODE_MOVIE:  
+		{
 			ShowIcon(VFD_ICON_TV, false);			
 			showclock = false;
 			break;
-	}
-
+		}
+	}
 	wake_up();
 }
 
@@ -625,13 +753,32 @@
 
 #if defined (__sh__)
 	struct vfd_ioctl_data data;
-	data.start_address = power;
+
+	data.start_address = 0;
+#if defined(BOXMODEL_FS9000) || defined(BOXMODEL_HS8200)
+	data.data[0] = power ? 0xf2 : 1;
+	data.data[4] = power * 2;
+#elif defined(BOXMODEL_HS9510) \
+   || defined(BOXMODEL_HS7420) \
+   || defined(BOXMODEL_HS7810A) \
+   || defined(BOXMODEL_HS7119) \
+   || defined(BOXMODEL_HS7429) \
+   || defined(BOXMODEL_HS7819)
+	data.data[0] = power ? 0 : 1;
+	data.data[4] = power;
+#elif defined(BOXMODEL_ADB_BOX)
+	data.data[0] = 1;  // power LED
+	data.data[4] = power ? 1 : 2;  // colour
+#else
+	data.data[4] = power;
+#endif
+	data.length = 5;
 	
 	openDevice();
-	
-	if( ioctl(fd, VFDPWRLED, &data) < 0)  
-		perror("VFDPWRLED");
-	
+	if (ioctl(fd, VFDSETLED, &data) < 0)
+	{
+		perror("VFDSETLED");
+	}
 	closeDevice();
 #endif
 }
@@ -694,22 +841,25 @@
 #if defined (ENABLE_4DIGITS)
 	ShowText("     "); // 5 empty digits
 #elif defined (__sh__)
+
+  #if defined (PLATFORM_KATHREIN)  /* using this otherwise VFD of ufs910 is black and Neutrino has a segfault */
 	struct vfd_ioctl_data data;
-	
-#if defined (PLATFORM_KATHREIN)		/* using this otherwise VFD of ufs910 is black and Neutrino has a segfault 		*/
+
 	data.start_address = 0x01;
 	data.length = 0x0;
 	openDevice();	
-	if (ioctl(fd, VFDDISPLAYCLR, &data) <0)
+	if (ioctl(fd, VFDDISPLAYCLR, &data) < 0)
+	{
 		perror("VFDDISPLAYCLR");
+	}
 	closeDevice();
-#else
-	data.start_address = 0;
-	openDevice();	
-	if( ioctl(fd, VFDDISPLAYWRITEONOFF, &data) < 0)
-		perror("VFDDISPLAYCLR");
-	closeDevice();
-#endif
+  #else
+	char buffer[VFD_LENGTH + 1];
+
+	memset(buffer, ' ', sizeof(buffer));
+	buffer[VFD_LENGTH] = 0;
+	ShowText(buffer);
+  #endif
 #elif (PLATFORM_COOLSTREAM)
 	int ret = ioctl(fd, IOC_VFD_CLEAR_ALL, 0);
 	if(ret < 0)
@@ -721,20 +871,57 @@
 #endif
 }
 
-void CVFD::ClearIcons()				/* switcht all VFD Icons off		*/
+void CVFD::ClearIcons()				/* switch all VFD Icons off */
 {
 	if(!has_lcd || is4digits) 
 		return;
 
 #if defined (__sh__)	
-#if defined(PLATFORM_SPARK7162)		/* using one command for switching off all Icons*/	 
+  #if defined(PLATFORM_SPARK7162)		/* using one command for switching off all Icons*/	 
 	openDevice();
 	aotom_data.u.icon.icon_nr = SPARK_ICON_ALL;
 	aotom_data.u.icon.on = 0;
 	if (ioctl(fd, VFDICONDISPLAYONOFF, &aotom_data) <0)
+	{
 		perror("VFDICONDISPLAYONOFF");
+	}	closeDevice();
+  #elif defined(BOXMODEL_FS9000) \
+     || defined(BOXMODEL_HS9510) \
+     || defined(BOXMODEL_HS8200) \
+     || defined(BOXMODEL_HS7420) \
+     || defined(BOXMODEL_HS7810A) \
+     || defined(BOXMODEL_HS7119) \
+     || defined(BOXMODEL_HS7429) \
+     || defined(BOXMODEL_HS7819)  /* using one command for switching off all Icons */
+  //#elif defined(PLATFORM_FORTIS)  /* using one command for switching off all Icons*/
+
+	struct vfd_ioctl_data data;
+
+	openDevice();
+	data.start_address = 0;
+	data.data[0] = ICON_ALL;
+	data.data[4] = 0;
+	data.length = 5;
+	if (ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+	{
+		perror("VFDICONDISPLAYONOFF");
+	}
 	closeDevice();
-#else
+  #elif defined(BOXMODEL_ADB_BOX)  /* using one command for switching off all Icons */
+
+	struct vfd_ioctl_data data;
+
+	openDevice();
+	data.start_address = 0;
+	data.data[0] = ADB_ICON_ALL;
+	data.data[4] = 0;
+	data.length = 5;
+	if (ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+	{
+		perror("VFDICONDISPLAYONOFF");
+	}
+	closeDevice();
+  #else
 	int i;
 	struct vfd_ioctl_data data;
 	
@@ -745,19 +932,21 @@
 		data.data[0] = i;
 		data.data[4] = 0;
 		
-		if( ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+		if (ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+		{
 			perror("VFDICONDISPLAYONOFF");
+		}
 	}
 	
 	closeDevice();
-#endif
+  #endif
 #endif
 }
 
 #if defined(PLATFORM_SPARK7162)			/* only for Spark7162 STB's which Display has a HDD Level indicator */	 
 void CVFD::ShowDiskLevel()
 {
-	int hdd_icons[9] = {24, 23, 21, 20, 19, 18, 17, 16, 22};
+	int hdd_icons[9] = {VFD_SPARK_HDD_A1, VFD_SPARK_HDD_A2, VFD_SPARK_HDD_A3, VFD_SPARK_HDD_A4, VFD_SPARK_HDD_A5, VFD_SPARK_HDD_A6, VFD_SPARK_HDD_A7, VFD_SPARK_HDD_A8, VFD_SPARK_HDD_FULL};
 	int percent, digits, i, j;
 	uint64_t t, u;
 	
@@ -790,13 +979,18 @@
 
 void CVFD::ShowIcon(vfd_icon icon, bool show)
 {
-	if(!has_lcd || is4digits) 
+	if(!has_lcd || is4digits || icon == 0) 
 		return;
 	
 	dprintf(DEBUG_DEBUG, "CVFD::ShowIcon %s %x\n", show ? "show" : "hide", (int) icon);
 
 #if defined (__sh__)
-#if defined (PLATFORM_KATHREIN) || defined(PLATFORM_SPARK7162)
+  #if defined (PLATFORM_KATHREIN) \
+   || defined(PLATFORM_SPARK7162) \
+   || defined(BOXMODEL_FS9000) \
+   || defined(BOXMODEL_HS9510) \
+   || defined(BOXMODEL_HS8200) \
+   || defined(BOXMODEL_ADB_BOX)
 	switch (icon)
 	{
 		case VFD_ICON_USB:
@@ -805,31 +999,53 @@
 		case VFD_ICON_CLOCK:
 			timer_icon = show;
 			break;
-#if defined (PLATFORM_KATHREIN)
+    #if defined (PLATFORM_KATHREIN) || defined(PLATFORM_HS9510)
 		case VFD_ICON_HDD:
 			hdd_icon = show;
 			break;
-#endif
+    #endif
 		default:
 			break;
 	}
-#endif
+  #endif
 
 	openDevice();
-#if defined(PLATFORM_SPARK7162)
+  #if defined(PLATFORM_SPARK7162)
 	aotom_data.u.icon.icon_nr = icon;
 	aotom_data.u.icon.on = show ? 1 : 0;
 	
-	if (ioctl(fd, VFDICONDISPLAYONOFF, &aotom_data) <0)
+	if (ioctl(fd, VFDICONDISPLAYONOFF, &aotom_data) < 0)
+	{
 		perror("VFDICONDISPLAYONOFF");	
+	}
+  #elif defined(BOXMODEL_FS9000) \
+     || defined(BOXMODEL_HS9510) \
+     || defined(BOXMODEL_HS8200) \
+     || defined(BOXMODEL_HS7420) \
+     || defined(BOXMODEL_HS7810A) \
+     || defined(BOXMODEL_HS7119) \
+     || defined(BOXMODEL_HS7429) \
+     || defined(BOXMODEL_HS7819) \
+     || defined(BOXMODEL_ADB_BOX)
+	struct vfd_ioctl_data data;
+
+	data.start_address = 0;
+	data.data[0] = icon;
+	data.data[4] = show ? 1 : 0;
+	data.length = 5;
+
+  	if (ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
+	{
+		perror("VFDICONDISPLAYONOFF");
+	}
 #else
-#if defined (PLATFORM_KATHREIN)
+    #if defined (PLATFORM_KATHREIN)
 	if (icon == 17)				/* returning because not existing icon at ufs910 */
 	{
 		closeDevice();	
 		return;
 	}
-#endif	
+    #endif	
 	struct vfd_ioctl_data data;
 
 	data.data[0] = (icon - 1) & 0x1F;
@@ -837,7 +1053,7 @@
 	
 	if( ioctl(fd, VFDICONDISPLAYONOFF, &data) < 0)
 		perror("VFDICONDISPLAYONOFF");
-#endif	
+  #endif	
 	closeDevice();
 #elif defined (PLATFORM_COOLSTREAM)
 	int ret = ioctl(fd, show ? IOC_VFD_SET_ICON : IOC_VFD_CLEAR_ICON, icon);
@@ -854,11 +1070,20 @@
 	dprintf(DEBUG_INFO, "CVFD::ShowText: [%s]\n", str);
 
 	int len = strlen(str);
+	if (len > 63)
+	{
+//		str[60] = '.';
+//		str[61] = '.';
+//		str[62] = '.';
+//		str[63] = '\0';
+		len = 63;
+	}
 	
 	//FIXME: some vfd treiber can not handle NULL string len
-	if(len == 0)
-		return;
-	
+	if (len == 0)
+	{
+		return;
+	}	
 	// replace
 	std::string text = str;
 
@@ -877,32 +1102,43 @@
 	 
 #if defined (__sh__)	 
 	openDevice();
-	
-	if(write(fd , text.c_str(), len > 16? 16 : len ) < 0)
+//  #if defined(BOXMODEL_HS9510) || defined(BOXMODEL_HS7420) || defined(BOXMODEL_HS7429)
+//	if (write(fd, text.c_str(), len > 8 ? 8 : len ) < 0)
+//  #elif defined(BOXMODEL_FS9000) || defined(BOXMODEL_HS8200)
+//	if (write(fd, text.c_str(), len > 12 ? 12 : len ) < 0)
+//  #elif defined(BOXMODEL_HS7810A) || defined(BOXMODEL_HS7119) || defined(BOXMODEL_HS7819)
+//	if (write(fd, text.c_str(), len > 4 ? 4 : len ) < 0)
+//  #else
+//	if (write(fd, text.c_str(), len > 16 ? 16 : len ) < 0)
+//  #endif
+	if (write(fd, text.c_str(), len > VFD_LENGTH ? VFD_LENGTH : len) < 0)
+//	if (write(fd, text.c_str(), len) < 0) // let driver do the scrolling
+	{
+		perror("write to /dev/vfd failed");
+	}
+	closeDevice();
+#else
+  #if defined (PLATFORM_ODIN) || defined (PLATFORM_GIGABLUE)
+	if (write(fd, text.c_str(), len > 5 ? 5 : len ) < 0)
+  #else
+	if (write(fd, text.c_str(), len > 12 ? 12 : len ) < 0)
+  #endif
 		perror("write to vfd failed");
-	
+#endif // __sh__
+}
+
+void CVFD::setFan(bool enable)
+{
+#if defined (__sh__)
+  #if defined(BOXMODEL_ADB_BOX)
+	 openDevice();
+	
+	if (ioctl(fd, VFDSETFAN, enable) < 0)  
+	{
+		perror("VFDSETFAN");
+	}
 	closeDevice();
-#elif defined (PLATFORM_ODIN) || defined (PLATFORM_GIGABLUE)
-	if( write(fd, text.c_str(), len > 5? 5 : len ) < 0)
-		perror("write to vfd failed");
-#else
-	if( write(fd, text.c_str(), len > 12? 12 : len ) < 0)
-		perror("write to vfd failed");
-	
-#endif
-}
-
-void CVFD::setFan(bool enable)
-{
-#if defined (__sh__)
-	/*
-	 openDevice();
-	
-	if( ioctl(fd, VFDSETFAN, enable) < 0)  
-		perror("VFDSETFAN");
-	
-	closeDevice();
-	*/
+  #endif
 #endif	
 }
 
@@ -957,7 +1193,11 @@
 	
 	dprintf(DEBUG_NORMAL, "CVFD::vfd_symbol_circle: %s\n", VFDCIRCLE[cir]);
 	
-#if defined (PLATFORM_VENTON)	
+#if defined (PLATFORM_VENTON) \
+ || defined (BOXMODEL_HS8200) \
+ || defined (BOXMODEL_FS9000) \
+ || defined (BOXMODEL_TF7700) \
+ || defined (BOXMODEL_ADB_BOX)
 	FILE *f;
 	if((f = fopen("/proc/stb/lcd/symbol_circle","w")) == NULL) 
 	{
@@ -987,14 +1227,14 @@
 	timebuf[2]=now->tm_hour;
 	timebuf[3]=now->tm_mday;
 	timebuf[4]=now->tm_mon+1;
-	timebuf[5]=now->tm_year % 100;
+	timebuf[5]=now->tm_year % 100; // BUG?, should be - 1900?
 	
 	struct vfd_ioctl_data data;
 	memset(&data, 0, sizeof(struct vfd_ioctl_data));
 	memcpy(&data, timebuf, 6); 
 	
 	if( ioctl(fd, VFDSETTIME, &data) < 0)  
-		perror("VFDPWRLED");
+		perror("VFDSETTIME");
 	
 	closeDevice();
 #else	
--- neutrino2.org/src/nhttpd/tuxboxapi/neutrinoyparser.cpp
+++ neutrino2/src/nhttpd/tuxboxapi/neutrinoyparser.cpp
@@ -671,14 +671,40 @@
 std::string  CNeutrinoYParser::func_get_boxtype(CyhookHandler *, std::string)
 {
 	//return "generic";//FIXME
-#if defined (BOXMODEL_ATEVIO700)
-	return "atevio700";
-#elif defined (BOXMODEL_ATEVIO7000)
-	return "atevio7000";
-#elif defined (BOXMODEL_ATEVIO7500)
-	return "atevio7500";
-#elif defined (BOXMODEL_ATEVIO7600)
-	return "atevio7600";
+#if defined (BOXMODEL_HS8200)
+	return "hs82000";
+#elif defined (BOXMODEL_FS9000)
+	return "fs9000";
+#elif defined (BOXMODEL_HS9510)
+	return "hs9510";
+#elif defined (BOXMODEL_HS7110)
+	return "hs7110";
+#elif defined (BOXMODEL_HS7420)
+	return "hs7420";
+#elif defined (BOXMODEL_HS7810A)
+	return "hs7810a";
+#elif defined (BOXMODEL_HS7119)
+	return "hs7119";
+#elif defined (BOXMODEL_HS7429)
+	return "hs7429";
+#elif defined (BOXMODEL_HS7819)
+	return "hs7819";
+#elif defined (BOXMODEL_TF7700)
+	return "tf7700";
+#elif defined (BOXMODEL_ADB_BOX)
+	return "adb_box";
+#elif defined (BOXMODEL_ADB2850)
+	return "adb2850";
+#elif defined (BOXMODEL_VIP1_V1)
+	return "vip1_v1";
+#elif defined (BOXMODEL_VIP1_V2)
+	return "vip1_v2";
+#elif defined (BOXMODEL_VIP2)
+	return "vip2";
+#elif defined (BOXMODEL_VITAMIN_HD5000)
+	return "vitamin_hd5000";
+#elif defined (BOXMODEL_OP9600)
+	return "opt9600";
 #elif defined (BOXMODEL_AZBOXHD)
 	return "azboxhd";
 #elif defined (BOXMODEL_AZBOXME)
#--- neutrino-hd2.org/src/gui/imageinfo.cpp
#+++ neutrino-hd2/src/gui/imageinfo.cpp
#@@ -40,7 +40,7 @@
# 
# #include <video_cs.h>
# 
#-#include <gui/version.h>
#+#include "version.h"
# 
# 
# #define GIT_BUILD "GIT Build:"

